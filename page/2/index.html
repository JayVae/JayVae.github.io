<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="持续精进">
<meta property="og:type" content="website">
<meta property="og:title" content="Jay&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Jay&#39;s Blog">
<meta property="og:description" content="持续精进">
<meta property="og:locale">
<meta property="article:author" content="史海杰">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>Jay's Blog</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?1dc984dfc86062a60470cc7297fb0653";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




<meta name="generator" content="Hexo 7.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jay's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">知而不行为不知</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-guestbook">
          <a href="/guestbook" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            留言
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2024/10/25/%E4%B8%80%E4%B8%AA%E7%AE%97%E6%B3%95%E8%AE%B2%E8%A7%A3%E7%BD%91%E7%AB%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/10/25/%E4%B8%80%E4%B8%AA%E7%AE%97%E6%B3%95%E8%AE%B2%E8%A7%A3%E7%BD%91%E7%AB%99/" itemprop="url">一个算法讲解网站</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-10-25T22:20:08+08:00">
                2024-10-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2024/10/25/%E4%B8%80%E4%B8%AA%E7%AE%97%E6%B3%95%E8%AE%B2%E8%A7%A3%E7%BD%91%E7%AB%99/" class="leancloud_visitors" data-flag-title="一个算法讲解网站">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  6 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://oi-wiki.org/dp/interval/">https://oi-wiki.org/dp/interval/</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2024/10/23/classical-algorithm-problems-recommendations/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/10/23/classical-algorithm-problems-recommendations/" itemprop="url">经典算法思想总结（含LeetCode题目推荐）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-10-23T20:13:39+08:00">
                2024-10-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2024/10/23/classical-algorithm-problems-recommendations/" class="leancloud_visitors" data-flag-title="经典算法思想总结（含LeetCode题目推荐）">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  814 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  3 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>贪心的本质是选择每一阶段的局部最优，从而达到全局最优。</p>
<h3 id="一般解题步骤"><a href="#一般解题步骤" class="headerlink" title="一般解题步骤"></a>一般解题步骤</h3><ul>
<li>将问题分解为若干个子问题</li>
<li>找出适合的贪心策略</li>
<li>求解每一个子问题的最优解</li>
<li>将局部最优解堆叠成全局最优解</li>
</ul>
<h3 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h3><p>455.分发饼干：<a href="https://leetcode.cn/problems/assign-cookies/">https://leetcode.cn/problems/assign-cookies/</a></p>
<p>121.买卖股票的最佳时机：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/</a></p>
<p>122.买卖股票的最佳时机 II：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/</a></p>
<p>55.跳跃游戏：<a href="https://leetcode.cn/problems/jump-game/">https://leetcode.cn/problems/jump-game/</a></p>
<p>45.跳跃游戏 II：<a href="https://leetcode.cn/problems/jump-game-ii/">https://leetcode.cn/problems/jump-game-ii/</a></p>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>动态规划中每一个状态一定是由上一个状态推导出来的，这一点就区分于贪心，贪心没有状态推导，而是从局部直接选最优的。</p>
<p>经典题目：01 背包、完全背包</p>
<h3 id="一般解题步骤-1"><a href="#一般解题步骤-1" class="headerlink" title="一般解题步骤"></a>一般解题步骤</h3><ul>
<li>确定 dp 数组（dp table）以及下标的含义</li>
<li>确定递推公式</li>
<li>dp 数组如何初始化</li>
<li>确定遍历顺序</li>
<li>举例推导 dp 数组</li>
</ul>
<h3 id="LeetCode-1"><a href="#LeetCode-1" class="headerlink" title="LeetCode"></a>LeetCode</h3><p>509.斐波那契数：<a href="https://leetcode.cn/problems/fibonacci-number/">https://leetcode.cn/problems/fibonacci-number/</a></p>
<p>746.使用最小花费爬楼梯：<a href="https://leetcode.cn/problems/min-cost-climbing-stairs/">https://leetcode.cn/problems/min-cost-climbing-stairs/</a></p>
<p>416.分割等和子集：<a href="https://leetcode.cn/problems/partition-equal-subset-sum/">https://leetcode.cn/problems/partition-equal-subset-sum/</a></p>
<p>518.零钱兑换：<a href="https://leetcode.cn/problems/coin-change-ii/">https://leetcode.cn/problems/coin-change-ii/</a></p>
<p>647.回文子串：<a href="https://leetcode.cn/problems/palindromic-substrings/">https://leetcode.cn/problems/palindromic-substrings/</a></p>
<p>516.最长回文子序列：<a href="https://leetcode.cn/problems/longest-palindromic-subsequence/">https://leetcode.cn/problems/longest-palindromic-subsequence/</a></p>
<h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><h3 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h3><p>回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条</p>
<p>件时，就“回溯”返回，尝试别的路径。其本质就是穷举。</p>
<p>经典题目：8 皇后</p>
<h3 id="一般解题步骤-2"><a href="#一般解题步骤-2" class="headerlink" title="一般解题步骤"></a>一般解题步骤</h3><ul>
<li>针对所给问题，定义问题的解空间，它至少包含问题的一个（最优）解。</li>
<li>确定易于搜索的解空间结构,使得能用回溯法方便地搜索整个解空间 。</li>
<li>以深度优先的方式搜索解空间，并且在搜索过程中用剪枝函数避免无效搜索。</li>
</ul>
<h3 id="leetcode"><a href="#leetcode" class="headerlink" title="leetcode"></a>leetcode</h3><p>77.组合：<a href="https://leetcode.cn/problems/combinations/">https://leetcode.cn/problems/combinations/</a></p>
<p>39.组合总和：<a href="https://leetcode.cn/problems/combination-sum/">https://leetcode.cn/problems/combination-sum/</a></p>
<p>40.组合总和 II：<a href="https://leetcode.cn/problems/combination-sum-ii/">https://leetcode.cn/problems/combination-sum-ii/</a></p>
<p>78.子集：<a href="https://leetcode.cn/problems/subsets/">https://leetcode.cn/problems/subsets/</a></p>
<p>90.子集 II：<a href="https://leetcode.cn/problems/subsets-ii/">https://leetcode.cn/problems/subsets-ii/</a></p>
<p>51.N 皇后：<a href="https://leetcode.cn/problems/n-queens/">https://leetcode.cn/problems/n-queens/</a></p>
<h2 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h2><h3 id="算法思想-3"><a href="#算法思想-3" class="headerlink" title="算法思想"></a>算法思想</h3><p>将一个规模为 N 的问题分解为 K 个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。</p>
<p>经典题目：二分查找、汉诺塔问题</p>
<h3 id="一般解题步骤-3"><a href="#一般解题步骤-3" class="headerlink" title="一般解题步骤"></a>一般解题步骤</h3><ul>
<li>将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；</li>
<li>若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题</li>
<li>将各个子问题的解合并为原问题的解。</li>
</ul>
<h3 id="LeetCode-2"><a href="#LeetCode-2" class="headerlink" title="LeetCode"></a>LeetCode</h3><p>108.将有序数组转换成二叉搜索数：<a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/</a></p>
<p>148.排序列表：<a href="https://leetcode.cn/problems/sort-list/">https://leetcode.cn/problems/sort-list/</a></p>
<p>23.合并 k 个升序链表：<a href="https://leetcode.cn/problems/merge-k-sorted-lists/">https://leetcode.cn/problems/merge-k-sorted-lists/</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2024/10/18/heap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/10/18/heap/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-10-18T19:29:46+08:00">
                2024-10-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2024/10/18/heap/" class="leancloud_visitors" data-flag-title="">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.5k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  8 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h2><p>堆是一种满足以下条件的树：</p>
<p>堆中的每一个节点值都大于等于（或小于等于）子树中所有节点的值。或者说，任意一个节点的值都大于等于（或小于等于）所有子节点的值。</p>
<blockquote>
<p>大家可以把堆(最大堆)理解为一个公司,这个公司很公平,谁能力强谁就当老大,不存在弱的人当老大,老大手底下的人一定不会比他强。这样有助于理解后续堆的操作。</p>
</blockquote>
<p><strong>!!!特别提示：</strong></p>
<ul>
<li>很多博客说堆是完全二叉树，其实并非如此，<strong>堆不一定是完全二叉树</strong>，只是为了方便存储和索引，我们通常用完全二叉树的形式来表示堆，事实上，广为人知的斐波那契堆和二项堆就不是完全二叉树,它们甚至都不是二叉树。</li>
<li>（<strong>二叉</strong>）堆是一个数组，它可以被看成是一个 <strong>近似的完全二叉树</strong>。——《算法导论》第三版</li>
</ul>
<p>大家可以尝试判断下面给出的图是否是堆？</p>
<p><img src="/./pictures/%E5%A0%86/%E5%A0%861.png"></p>
<p>第 1 个和第 2 个是堆。第 1 个是最大堆，每个节点都比子树中所有节点大。第 2 个是最小堆，每个节点都比子树中所有节点小。</p>
<p>第 3 个不是，第三个中，根结点 1 比 2 和 15 小，而 15 却比 3 大，19 比 5 大，不满足堆的性质。</p>
<h2 id="堆的用途"><a href="#堆的用途" class="headerlink" title="堆的用途"></a>堆的用途</h2><p>当我们只关心所有数据中的最大值或者最小值，存在多次获取最大值或者最小值，多次插入或删除数据时，就可以使用堆。</p>
<p>有小伙伴可能会想到用有序数组，初始化一个有序数组时间复杂度是 <code>O(nlog(n))</code>，查找最大值或者最小值时间复杂度都是 <code>O(1)</code>，但是，涉及到更新（插入或删除）数据时，时间复杂度为 <code>O(n)</code>，即使是使用复杂度为 <code>O(log(n))</code> 的二分法找到要插入或者删除的数据，在移动数据时也需要 <code>O(n)</code> 的时间复杂度。</p>
<p><strong>相对于有序数组而言，堆的主要优势在于插入和删除数据效率较高。</strong> 因为堆是基于完全二叉树实现的，所以在插入和删除数据时，只需要在二叉树中上下移动节点，时间复杂度为 <code>O(log(n))</code>，相比有序数组的 <code>O(n)</code>，效率更高。</p>
<p>不过，需要注意的是：Heap 初始化的时间复杂度为 <code>O(n)</code>，而非<code>O(nlogn)</code>。</p>
<h2 id="堆的分类"><a href="#堆的分类" class="headerlink" title="堆的分类"></a>堆的分类</h2><p>堆分为 <strong>最大堆</strong> 和 <strong>最小堆</strong>。二者的区别在于节点的排序方式。</p>
<ul>
<li><strong>最大堆</strong>：堆中的每一个节点的值都大于等于子树中所有节点的值</li>
<li><strong>最小堆</strong>：堆中的每一个节点的值都小于等于子树中所有节点的值</li>
</ul>
<p>如下图所示，图 1 是最大堆，图 2 是最小堆</p>
<p><img src="/./pictures/%E5%A0%86/%E5%A0%862.png"></p>
<h2 id="堆的存储"><a href="#堆的存储" class="headerlink" title="堆的存储"></a>堆的存储</h2><p>之前介绍树的时候说过，由于完全二叉树的优秀性质，利用数组存储二叉树即节省空间，又方便索引（若根结点的序号为 1，那么对于树中任意节点 i，其左子节点序号为 <code>2*i</code>，右子节点序号为 <code>2*i+1</code>）。</p>
<p>为了方便存储和索引，（二叉）堆可以用完全二叉树的形式进行存储。存储的方式如下图所示：</p>
<p><img src="/./pictures/%E5%A0%86/%E5%A0%86%E7%9A%84%E5%AD%98%E5%82%A8.png" alt="堆的存储"></p>
<h2 id="堆的操作"><a href="#堆的操作" class="headerlink" title="堆的操作"></a>堆的操作</h2><p>堆的更新操作主要包括两种 : <strong>插入元素</strong> 和 <strong>删除堆顶元素</strong>。操作过程需要着重掌握和理解。</p>
<blockquote>
<p>在进入正题之前，再重申一遍，堆是一个公平的公司，有能力的人自然会走到与他能力所匹配的位置</p>
</blockquote>
<h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><blockquote>
<p>插入元素，作为一个新入职的员工，初来乍到，这个员工需要从基层做起</p>
</blockquote>
<p><strong>1.将要插入的元素放到最后</strong></p>
<p><img src="/./pictures/%E5%A0%86/%E5%A0%86-%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A01.png" alt="堆-插入元素-1"></p>
<blockquote>
<p>有能力的人会逐渐升职加薪，是金子总会发光的！！！</p>
</blockquote>
<p><strong>2.从底向上，如果父结点比该元素小，则该节点和父结点交换，直到无法交换</strong></p>
<p><img src="/./pictures/%E5%A0%86/%E5%A0%86-%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A02.png" alt="堆-插入元素2"></p>
<p><img src="/./pictures/%E5%A0%86/%E5%A0%86-%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A03.png" alt="堆-插入元素3"></p>
<h3 id="删除堆顶元素"><a href="#删除堆顶元素" class="headerlink" title="删除堆顶元素"></a>删除堆顶元素</h3><p>根据堆的性质可知，最大堆的堆顶元素为所有元素中最大的，最小堆的堆顶元素是所有元素中最小的。当我们需要多次查找最大元素或者最小元素的时候，可以利用堆来实现。</p>
<p>删除堆顶元素后，为了保持堆的性质，需要对堆的结构进行调整，我们将这个过程称之为”<strong>堆化</strong>“，堆化的方法分为两种：</p>
<ul>
<li>一种是自底向上的堆化，上述的插入元素所使用的就是自底向上的堆化，元素从最底部向上移动。</li>
<li>另一种是自顶向下堆化，元素由最顶部向下移动。在讲解删除堆顶元素的方法时，我将阐述这两种操作的过程，大家可以体会一下二者的不同。</li>
</ul>
<h4 id="自底向上堆化"><a href="#自底向上堆化" class="headerlink" title="自底向上堆化"></a>自底向上堆化</h4><blockquote>
<p>在堆这个公司中，会出现老大离职的现象，老大离职之后，他的位置就空出来了</p>
</blockquote>
<p>首先删除堆顶元素，使得数组中下标为 1 的位置空出。</p>
<p><img src="/./pictures/%E5%A0%86/%E5%88%A0%E9%99%A4%E5%A0%86%E9%A1%B6%E5%85%83%E7%B4%A01.png" alt="删除堆顶元素1"></p>
<blockquote>
<p>那么他的位置由谁来接替呢，当然是他的直接下属了，谁能力强就让谁上呗</p>
</blockquote>
<p>比较根结点的左子节点和右子节点，也就是下标为 2,3 的数组元素，将较大的元素填充到根结点(下标为 1)的位置。</p>
<p><img src="/./pictures/%E5%A0%86/%E5%88%A0%E9%99%A4%E5%A0%86%E9%A1%B6%E5%85%83%E7%B4%A02.png" alt="删除堆顶元素2"></p>
<blockquote>
<p>这个时候又空出一个位置了，老规矩，谁有能力谁上</p>
</blockquote>
<p>一直循环比较空出位置的左右子节点，并将较大者移至空位，直到堆的最底部</p>
<p><img src="/./pictures/%E5%A0%86/%E5%88%A0%E9%99%A4%E5%A0%86%E9%A1%B6%E5%85%83%E7%B4%A03.png" alt="删除堆顶元素3"></p>
<p>这个时候已经完成了自底向上的堆化，没有元素可以填补空缺了，但是，我们可以看到数组中出现了“气泡”，这会导致存储空间的浪费。接下来我们试试自顶向下堆化。</p>
<h4 id="自顶向下堆化"><a href="#自顶向下堆化" class="headerlink" title="自顶向下堆化"></a>自顶向下堆化</h4><p>自顶向下的堆化用一个词形容就是“石沉大海”，那么第一件事情，就是把石头抬起来，从海面扔下去。这个石头就是堆的最后一个元素，我们将最后一个元素移动到堆顶。</p>
<p><img src="/./pictures/%E5%A0%86/%E5%88%A0%E9%99%A4%E5%A0%86%E9%A1%B6%E5%85%83%E7%B4%A04.png" alt="删除堆顶元素4"></p>
<p>然后开始将这个石头沉入海底，不停与左右子节点的值进行比较，和较大的子节点交换位置，直到无法交换位置。</p>
<p><img src="/./pictures/%E5%A0%86/%E5%88%A0%E9%99%A4%E5%A0%86%E9%A1%B6%E5%85%83%E7%B4%A05.png" alt="删除堆顶元素5"></p>
<p><img src="/./pictures/%E5%A0%86/%E5%88%A0%E9%99%A4%E5%A0%86%E9%A1%B6%E5%85%83%E7%B4%A06.png" alt="删除堆顶元素6"></p>
<h3 id="堆的操作总结"><a href="#堆的操作总结" class="headerlink" title="堆的操作总结"></a>堆的操作总结</h3><ul>
<li><strong>插入元素</strong>：先将元素放至数组末尾，再自底向上堆化，将末尾元素上浮</li>
<li><strong>删除堆顶元素</strong>：删除堆顶元素，将末尾元素放至堆顶，再自顶向下堆化，将堆顶元素下沉。也可以自底向上堆化，只是会产生“气泡”，浪费存储空间。最好采用自顶向下堆化的方式。</li>
</ul>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序的过程分为两步：</p>
<ul>
<li>第一步是建堆，将一个无序的数组建立为一个堆</li>
<li>第二步是排序，将堆顶元素取出，然后对剩下的元素进行堆化，反复迭代，直到所有元素被取出为止。</li>
</ul>
<h3 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h3><p>如果你已经足够了解堆化的过程，那么建堆的过程掌握起来就比较容易了。建堆的过程就是一个对所有非叶节点的自顶向下堆化过程。</p>
<p>首先要了解哪些是非叶节点，最后一个节点的父结点及它之前的元素，都是非叶节点。也就是说，如果节点个数为 n，那么我们需要对 n&#x2F;2 到 1 的节点进行自顶向下（沉底）堆化。</p>
<p>具体过程如下图：</p>
<p><img src="/./pictures/%E5%A0%86/%E5%BB%BA%E5%A0%861.png" alt="建堆1"></p>
<p>将初始的无序数组抽象为一棵树，图中的节点个数为 6，所以 4,5,6 节点为叶节点，1,2,3 节点为非叶节点，所以要对 1-3 号节点进行自顶向下（沉底）堆化，注意，顺序是从后往前堆化，从 3 号节点开始，一直到 1 号节点。<br>3 号节点堆化结果：</p>
<p><img src="/./pictures/%E5%A0%86/%E5%BB%BA%E5%A0%862.png" alt="建堆1"></p>
<p>2 号节点堆化结果：</p>
<p><img src="/./pictures/%E5%A0%86/%E5%BB%BA%E5%A0%863.png" alt="建堆1"></p>
<p>1 号节点堆化结果：</p>
<p><img src="/./pictures/%E5%A0%86/%E5%BB%BA%E5%A0%864.png" alt="建堆1"></p>
<p>至此，数组所对应的树已经成为了一个最大堆，建堆完成！</p>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>由于堆顶元素是所有元素中最大的，所以我们重复取出堆顶元素，将这个最大的堆顶元素放至数组末尾，并对剩下的元素进行堆化即可。</p>
<p>现在思考两个问题：</p>
<ul>
<li>删除堆顶元素后需要执行自顶向下（沉底）堆化还是自底向上（上浮）堆化？</li>
<li>取出的堆顶元素存在哪，新建一个数组存？</li>
</ul>
<p>先回答第一个问题，我们需要执行自顶向下（沉底）堆化，这个堆化一开始要将末尾元素移动至堆顶，这个时候末尾的位置就空出来了，由于堆中元素已经减小，这个位置不会再被使用，所以我们可以将取出的元素放在末尾。</p>
<p>机智的小伙伴已经发现了，这其实是做了一次交换操作，将堆顶和末尾元素调换位置，从而将取出堆顶元素和堆化的第一步(将末尾元素放至根结点位置)进行合并。</p>
<p>详细过程如下图所示：</p>
<p>取出第一个元素并堆化：</p>
<p><img src="/./pictures/%E5%A0%86/%E5%A0%86%E6%8E%92%E5%BA%8F1.png" alt="堆排序1"></p>
<p>取出第二个元素并堆化：</p>
<p><img src="/./pictures/%E5%A0%86/%E5%A0%86%E6%8E%92%E5%BA%8F2.png" alt="堆排序2"></p>
<p>取出第三个元素并堆化：</p>
<p><img src="/./pictures/%E5%A0%86/%E5%A0%86%E6%8E%92%E5%BA%8F3.png" alt="堆排序3"></p>
<p>取出第四个元素并堆化：</p>
<p><img src="/./pictures/%E5%A0%86/%E5%A0%86%E6%8E%92%E5%BA%8F4.png" alt="堆排序4"></p>
<p>取出第五个元素并堆化：</p>
<p><img src="/./pictures/%E5%A0%86/%E5%A0%86%E6%8E%92%E5%BA%8F5.png" alt="堆排序5"></p>
<p>取出第六个元素并堆化：</p>
<p><img src="/./pictures/%E5%A0%86/%E5%A0%86%E6%8E%92%E5%BA%8F6.png" alt="堆排序6"></p>
<p>堆排序完成！</p>
<!-- @include: @article-footer.snippet.md -->

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2024/10/18/common-data-structures-leetcode-recommendations/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/10/18/common-data-structures-leetcode-recommendations/" itemprop="url">常见数据结构经典LeetCode题目推荐</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-10-18T18:37:45+08:00">
                2024-10-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2024/10/18/common-data-structures-leetcode-recommendations/" class="leancloud_visitors" data-flag-title="常见数据结构经典LeetCode题目推荐">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  402 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>704.二分查找：<a href="https://leetcode.cn/problems/binary-search/">https://leetcode.cn/problems/binary-search/</a></p>
<p>80.删除有序数组中的重复项 II：<a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii">https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii</a></p>
<p>977.有序数组的平方：<a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">https://leetcode.cn/problems/squares-of-a-sorted-array/</a></p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>707.设计链表：<a href="https://leetcode.cn/problems/design-linked-list/">https://leetcode.cn/problems/design-linked-list/</a></p>
<p>206.反转链表：<a href="https://leetcode.cn/problems/reverse-linked-list/">https://leetcode.cn/problems/reverse-linked-list/</a></p>
<p>92.反转链表 II：<a href="https://leetcode.cn/problems/reverse-linked-list-ii/">https://leetcode.cn/problems/reverse-linked-list-ii/</a></p>
<p>61.旋转链表：<a href="https://leetcode.cn/problems/rotate-list/">https://leetcode.cn/problems/rotate-list/</a></p>
<h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><p>232.用栈实现队列：<a href="https://leetcode.cn/problems/implement-queue-using-stacks/">https://leetcode.cn/problems/implement-queue-using-stacks/</a></p>
<p>225.用队列实现栈：<a href="https://leetcode.cn/problems/implement-stack-using-queues/">https://leetcode.cn/problems/implement-stack-using-queues/</a></p>
<p>347.前 K 个高频元素：<a href="https://leetcode.cn/problems/top-k-frequent-elements/">https://leetcode.cn/problems/top-k-frequent-elements/</a></p>
<p>239.滑动窗口最大值：<a href="https://leetcode.cn/problems/sliding-window-maximum/">https://leetcode.cn/problems/sliding-window-maximum/</a></p>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>105.从前序与中序遍历构造二叉树：<a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</a></p>
<p>117.填充每个节点的下一个右侧节点指针 II：<a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii">https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii</a></p>
<p>236.二叉树的最近公共祖先：<a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/</a></p>
<p>129.求根节点到叶节点数字之和：<a href="https://leetcode.cn/problems/sum-root-to-leaf-numbers/">https://leetcode.cn/problems/sum-root-to-leaf-numbers/</a></p>
<p>102.二叉树的层序遍历：<a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">https://leetcode.cn/problems/binary-tree-level-order-traversal/</a></p>
<p>530.二叉搜索树的最小绝对差：<a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">https://leetcode.cn/problems/minimum-absolute-difference-in-bst/</a></p>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>200.岛屿数量：<a href="https://leetcode.cn/problems/number-of-islands/">https://leetcode.cn/problems/number-of-islands/</a></p>
<p>207.课程表：<a href="https://leetcode.cn/problems/course-schedule/">https://leetcode.cn/problems/course-schedule/</a></p>
<p>210.课程表 II：<a href="https://leetcode.cn/problems/course-schedule-ii/">https://leetcode.cn/problems/course-schedule-ii/</a></p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>215.数组中的第 K 个最大元素:<a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">https://leetcode.cn/problems/kth-largest-element-in-an-array/</a></p>
<p>216.数据流的中位数:<a href="https://leetcode.cn/problems/find-median-from-data-stream/">https://leetcode.cn/problems/find-median-from-data-stream/</a></p>
<p>217.前 K 个高频元素：<a href="https://leetcode.cn/problems/top-k-frequent-elements/">https://leetcode.cn/problems/top-k-frequent-elements/</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2024/10/09/sql-questions-02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/10/09/sql-questions-02/" itemprop="url">SQL常见面试题总结（2）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-10-09T23:57:38+08:00">
                2024-10-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/" itemprop="url" rel="index">
                    <span itemprop="name">面试问题</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2024/10/09/sql-questions-02/" class="leancloud_visitors" data-flag-title="SQL常见面试题总结（2）">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4.2k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  17 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>题目来源于：<a href="https://www.nowcoder.com/exam/oj?page=1&tab=SQL%E7%AF%87&topicId=240">牛客题霸 - SQL 进阶挑战</a></p>
</blockquote>
<h2 id="增删改操作"><a href="#增删改操作" class="headerlink" title="增删改操作"></a>增删改操作</h2><p>SQL 插入记录的方式汇总：</p>
<ul>
<li><strong>普通插入（全字段）</strong> ：<code>INSERT INTO table_name VALUES (value1, value2, ...)</code></li>
<li><strong>普通插入（限定字段）</strong> ：<code>INSERT INTO table_name (column1, column2, ...) VALUES (value1, value2, ...)</code></li>
<li><strong>多条一次性插入</strong> ：<code>INSERT INTO table_name (column1, column2, ...) VALUES (value1_1, value1_2, ...), (value2_1, value2_2, ...), ...</code></li>
<li><strong>从另一个表导入</strong> ：<code>INSERT INTO table_name SELECT * FROM table_name2 [WHERE key=value]</code></li>
<li><strong>带更新的插入</strong> ：<code>REPLACE INTO table_name VALUES (value1, value2, ...)</code>（注意这种原理是检测到主键或唯一性索引键重复就删除原记录后重新插入）</li>
</ul>
<h3 id="插入记录（一）"><a href="#插入记录（一）" class="headerlink" title="插入记录（一）"></a>插入记录（一）</h3><p><strong>描述</strong>：牛客后台会记录每个用户的试卷作答记录到 <code>exam_record</code> 表，现在有两个用户的作答记录详情如下：</p>
<ul>
<li>用户 1001 在 2021 年 9 月 1 日晚上 10 点 11 分 12 秒开始作答试卷 9001，并在 50 分钟后提交，得了 90 分；</li>
<li>用户 1002 在 2021 年 9 月 4 日上午 7 点 1 分 2 秒开始作答试卷 9002，并在 10 分钟后退出了平台。</li>
</ul>
<p>试卷作答记录表<code>exam_record</code>中，表已建好，其结构如下，请用一条语句将这两条记录插入表中。</p>
<table>
<thead>
<tr>
<th>Filed</th>
<th>Type</th>
<th>Null</th>
<th>Key</th>
<th>Extra</th>
<th>Default</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>int(11)</td>
<td>NO</td>
<td>PRI</td>
<td>auto_increment</td>
<td>(NULL)</td>
<td>自增 ID</td>
</tr>
<tr>
<td>uid</td>
<td>int(11)</td>
<td>NO</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>用户 ID</td>
</tr>
<tr>
<td>exam_id</td>
<td>int(11)</td>
<td>NO</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>试卷 ID</td>
</tr>
<tr>
<td>start_time</td>
<td>datetime</td>
<td>NO</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>开始时间</td>
</tr>
<tr>
<td>submit_time</td>
<td>datetime</td>
<td>YES</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>提交时间</td>
</tr>
<tr>
<td>score</td>
<td>tinyint(4)</td>
<td>YES</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>得分</td>
</tr>
</tbody></table>
<p><strong>答案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 存在自增主键，无需手动赋值</span><br><span class="line"><span class="keyword">INSERT INTO</span> exam_record (uid, exam_id, start_time, submit_time, score) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1001</span>, <span class="number">9001</span>, <span class="string">&#x27;2021-09-01 22:11:12&#x27;</span>, <span class="string">&#x27;2021-09-01 23:01:12&#x27;</span>, <span class="number">90</span>),</span><br><span class="line">(<span class="number">1002</span>, <span class="number">9002</span>, <span class="string">&#x27;2021-09-04 07:01:02&#x27;</span>, <span class="keyword">NULL</span>, <span class="keyword">NULL</span>);</span><br></pre></td></tr></table></figure>

<h3 id="插入记录（二）"><a href="#插入记录（二）" class="headerlink" title="插入记录（二）"></a>插入记录（二）</h3><p><strong>描述</strong>：现有一张试卷作答记录表<code>exam_record</code>，结构如下表，其中包含多年来的用户作答试卷记录，由于数据越来越多，维护难度越来越大，需要对数据表内容做精简，历史数据做备份。</p>
<p>表<code>exam_record</code>：</p>
<table>
<thead>
<tr>
<th>Filed</th>
<th>Type</th>
<th>Null</th>
<th>Key</th>
<th>Extra</th>
<th>Default</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>int(11)</td>
<td>NO</td>
<td>PRI</td>
<td>auto_increment</td>
<td>(NULL)</td>
<td>自增 ID</td>
</tr>
<tr>
<td>uid</td>
<td>int(11)</td>
<td>NO</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>用户 ID</td>
</tr>
<tr>
<td>exam_id</td>
<td>int(11)</td>
<td>NO</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>试卷 ID</td>
</tr>
<tr>
<td>start_time</td>
<td>datetime</td>
<td>NO</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>开始时间</td>
</tr>
<tr>
<td>submit_time</td>
<td>datetime</td>
<td>YES</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>提交时间</td>
</tr>
<tr>
<td>score</td>
<td>tinyint(4)</td>
<td>YES</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>得分</td>
</tr>
</tbody></table>
<p>我们已经创建了一张新表<code>exam_record_before_2021</code>用来备份 2021 年之前的试题作答记录，结构和<code>exam_record</code>表一致，请将 2021 年之前的已完成了的试题作答纪录导入到该表。</p>
<p><strong>答案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> exam_record_before_2021 (uid, exam_id, start_time, submit_time, score)</span><br><span class="line"><span class="keyword">SELECT</span> uid,exam_id,start_time,submit_time,score</span><br><span class="line"><span class="keyword">FROM</span> exam_record</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">YEAR</span>(submit_time) <span class="operator">&lt;</span> <span class="number">2021</span>;</span><br></pre></td></tr></table></figure>

<h3 id="插入记录（三）"><a href="#插入记录（三）" class="headerlink" title="插入记录（三）"></a>插入记录（三）</h3><p><strong>描述</strong>：现在有一套 ID 为 9003 的高难度 SQL 试卷，时长为一个半小时，请你将 2021-01-01 00:00:00 作为发布时间插入到试题信息表<code>examination_info</code>，不管该 ID 试卷是否存在，都要插入成功，请尝试插入它。</p>
<p>试题信息表<code>examination_info</code>：</p>
<table>
<thead>
<tr>
<th>Filed</th>
<th>Type</th>
<th>Null</th>
<th>Key</th>
<th>Extra</th>
<th>Default</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>int(11)</td>
<td>NO</td>
<td>PRI</td>
<td>auto_increment</td>
<td>(NULL)</td>
<td>自增 ID</td>
</tr>
<tr>
<td>exam_id</td>
<td>int(11)</td>
<td>NO</td>
<td>UNI</td>
<td></td>
<td>(NULL)</td>
<td>试卷 ID</td>
</tr>
<tr>
<td>tag</td>
<td>varchar(32)</td>
<td>YES</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>类别标签</td>
</tr>
<tr>
<td>difficulty</td>
<td>varchar(8)</td>
<td>YES</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>难度</td>
</tr>
<tr>
<td>duration</td>
<td>int(11)</td>
<td>NO</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>时长(分钟数)</td>
</tr>
<tr>
<td>release_time</td>
<td>datetime</td>
<td>YES</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>发布时间</td>
</tr>
</tbody></table>
<p><strong>答案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">REPLACE <span class="keyword">INTO</span> examination_info <span class="keyword">VALUES</span></span><br><span class="line"> (<span class="keyword">NULL</span>, <span class="number">9003</span>, &quot;SQL&quot;, &quot;hard&quot;, <span class="number">90</span>, &quot;2021-01-01 00:00:00&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="更新记录（一）"><a href="#更新记录（一）" class="headerlink" title="更新记录（一）"></a>更新记录（一）</h3><p><strong>描述</strong>：现在有一张试卷信息表 <code>examination_info</code>, 表结构如下图所示：</p>
<table>
<thead>
<tr>
<th>Filed</th>
<th>Type</th>
<th>Null</th>
<th>Key</th>
<th>Extra</th>
<th>Default</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>int(11)</td>
<td>NO</td>
<td>PRI</td>
<td>auto_increment</td>
<td>(NULL)</td>
<td>自增 ID</td>
</tr>
<tr>
<td>exam_id</td>
<td>int(11)</td>
<td>NO</td>
<td>UNI</td>
<td></td>
<td>(NULL)</td>
<td>试卷 ID</td>
</tr>
<tr>
<td>tag</td>
<td>char(32)</td>
<td>YES</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>类别标签</td>
</tr>
<tr>
<td>difficulty</td>
<td>char(8)</td>
<td>YES</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>难度</td>
</tr>
<tr>
<td>duration</td>
<td>int(11)</td>
<td>NO</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>时长</td>
</tr>
<tr>
<td>release_time</td>
<td>datetime</td>
<td>YES</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>发布时间</td>
</tr>
</tbody></table>
<p>请把<strong>examination_info</strong>表中<code>tag</code>为<code>PYTHON</code>的<code>tag</code>字段全部修改为<code>Python</code>。</p>
<p><strong>思路</strong>：这题有两种解题思路，最容易想到的是直接<code>update + where</code>来指定条件更新，第二种就是根据要修改的字段进行查找替换</p>
<p><strong>答案一</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> examination_info <span class="keyword">SET</span> tag <span class="operator">=</span> <span class="string">&#x27;Python&#x27;</span> <span class="keyword">WHERE</span> tag<span class="operator">=</span><span class="string">&#x27;PYTHON&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>答案二</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> examination_info</span><br><span class="line"><span class="keyword">SET</span> tag <span class="operator">=</span> REPLACE(tag,<span class="string">&#x27;PYTHON&#x27;</span>,<span class="string">&#x27;Python&#x27;</span>)</span><br><span class="line"></span><br><span class="line"># REPLACE (目标字段，&quot;查找内容&quot;,&quot;替换内容&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="更新记录（二）"><a href="#更新记录（二）" class="headerlink" title="更新记录（二）"></a>更新记录（二）</h3><p><strong>描述</strong>：现有一张试卷作答记录表 exam_record，其中包含多年来的用户作答试卷记录，结构如下表：作答记录表 <code>exam_record</code>： <strong><code>submit_time</code></strong> 为 完成时间 （注意这句话）</p>
<table>
<thead>
<tr>
<th>Filed</th>
<th>Type</th>
<th>Null</th>
<th>Key</th>
<th>Extra</th>
<th>Default</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>int(11)</td>
<td>NO</td>
<td>PRI</td>
<td>auto_increment</td>
<td>(NULL)</td>
<td>自增 ID</td>
</tr>
<tr>
<td>uid</td>
<td>int(11)</td>
<td>NO</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>用户 ID</td>
</tr>
<tr>
<td>exam_id</td>
<td>int(11)</td>
<td>NO</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>试卷 ID</td>
</tr>
<tr>
<td>start_time</td>
<td>datetime</td>
<td>NO</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>开始时间</td>
</tr>
<tr>
<td>submit_time</td>
<td>datetime</td>
<td>YES</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>提交时间</td>
</tr>
<tr>
<td>score</td>
<td>tinyint(4)</td>
<td>YES</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>得分</td>
</tr>
</tbody></table>
<p><strong>题目要求</strong>：请把 <code>exam_record</code> 表中 2021 年 9 月 1 日&#x3D;&#x3D;之前&#x3D;&#x3D;开始作答的&#x3D;&#x3D;未完成&#x3D;&#x3D;记录全部改为被动完成，即：将完成时间改为’2099-01-01 00:00:00’，分数改为 0。</p>
<p><strong>思路</strong>：注意题干中的关键字(已经高亮) <code>&quot; xxx 时间 &quot;</code>之前这个条件， 那么这里马上就要想到要进行时间的比较 可以直接 <code>xxx_time &lt; &quot;2021-09-01 00:00:00&quot;,</code> 也可以采用<code>date()</code>函数来进行比较；第二个条件就是 <code>&quot;未完成&quot;</code>， 即完成时间为 NULL，也就是题目中的提交时间 —– <code>submit_time 为 NULL</code>。</p>
<p><strong>答案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> exam_record <span class="keyword">SET</span> submit_time <span class="operator">=</span> <span class="string">&#x27;2099-01-01 00:00:00&#x27;</span>, score <span class="operator">=</span> <span class="number">0</span> <span class="keyword">WHERE</span> <span class="type">DATE</span>(start_time) <span class="operator">&lt;</span> &quot;2021-09-01&quot; <span class="keyword">AND</span> submit_time <span class="keyword">IS</span> <span class="keyword">null</span></span><br></pre></td></tr></table></figure>

<h3 id="删除记录（一）"><a href="#删除记录（一）" class="headerlink" title="删除记录（一）"></a>删除记录（一）</h3><p><strong>描述</strong>：现有一张试卷作答记录表 <code>exam_record</code>，其中包含多年来的用户作答试卷记录，结构如下表：</p>
<p>作答记录表<code>exam_record：</code> <strong><code>start_time</code></strong> 是试卷开始时间<code>submit_time</code> 是交卷，即结束时间。</p>
<table>
<thead>
<tr>
<th>Filed</th>
<th>Type</th>
<th>Null</th>
<th>Key</th>
<th>Extra</th>
<th>Default</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>int(11)</td>
<td>NO</td>
<td>PRI</td>
<td>auto_increment</td>
<td>(NULL)</td>
<td>自增 ID</td>
</tr>
<tr>
<td>uid</td>
<td>int(11)</td>
<td>NO</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>用户 ID</td>
</tr>
<tr>
<td>exam_id</td>
<td>int(11)</td>
<td>NO</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>试卷 ID</td>
</tr>
<tr>
<td>start_time</td>
<td>datetime</td>
<td>NO</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>开始时间</td>
</tr>
<tr>
<td>submit_time</td>
<td>datetime</td>
<td>YES</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>提交时间</td>
</tr>
<tr>
<td>score</td>
<td>tinyint(4)</td>
<td>YES</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>得分</td>
</tr>
</tbody></table>
<p><strong>要求</strong>：请删除<code>exam_record</code>表中作答时间小于 5 分钟整且分数不及格（及格线为 60 分）的记录；</p>
<p><strong>思路</strong>：这一题虽然是练习删除，仔细看确是考察对时间函数的用法，这里提及的分钟数比较，常用的函数有 <strong><code>TIMEDIFF</code><strong>和</strong><code>TIMESTAMPDIFF</code></strong> ，两者用法稍有区别，后者更为灵活，这都是看个人习惯。</p>
<p>1.　 <code>TIMEDIFF</code>：两个时间之间的差值</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TIMEDIFF(time1, time2)</span><br></pre></td></tr></table></figure>

<p>两者参数都是必须的，都是一个时间或者日期时间表达式。如果指定的参数不合法或者是 NULL，那么函数将返回 NULL。</p>
<p>对于这题而言，可以用在 minute 函数里面，因为 TIMEDIFF 计算出来的是时间的差值，在外面套一个 MINUTE 函数，计算出来的就是分钟数。</p>
<ol start="2">
<li><code>TIMESTAMPDIFF</code>：用于计算两个日期的时间差</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">TIMESTAMPDIFF(unit,datetime_expr1,datetime_expr2)</span><br><span class="line"># 参数说明</span><br><span class="line">#unit: 日期比较返回的时间差单位，常用可选值如下:</span><br><span class="line"><span class="keyword">SECOND</span>：秒</span><br><span class="line"><span class="keyword">MINUTE</span>：分钟</span><br><span class="line"><span class="keyword">HOUR</span>：小时</span><br><span class="line"><span class="keyword">DAY</span>：天</span><br><span class="line">WEEK：星期</span><br><span class="line"><span class="keyword">MONTH</span>：月</span><br><span class="line">QUARTER：季度</span><br><span class="line"><span class="keyword">YEAR</span>：年</span><br><span class="line"># TIMESTAMPDIFF函数返回datetime_expr2 <span class="operator">-</span> datetime_expr1的结果（人话： 后面的 <span class="operator">-</span> 前面的  即<span class="number">2</span><span class="number">-1</span>），其中datetime_expr1和datetime_expr2可以是<span class="type">DATE</span>或DATETIME类型值（人话：可以是“<span class="number">2023</span><span class="number">-01</span><span class="number">-01</span>”， 也可以是“<span class="number">2023</span><span class="number">-01</span><span class="number">-01</span><span class="operator">-</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>”）</span><br></pre></td></tr></table></figure>

<p>这题需要进行分钟的比较，那么就是 TIMESTAMPDIFF(MINUTE, 开始时间， 结束时间) &lt; 5</p>
<p><strong>答案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> exam_record <span class="keyword">WHERE</span> <span class="keyword">MINUTE</span> (TIMEDIFF(submit_time , start_time)) <span class="operator">&lt;</span> <span class="number">5</span> <span class="keyword">AND</span> score <span class="operator">&lt;</span> <span class="number">60</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> exam_record <span class="keyword">WHERE</span> TIMESTAMPDIFF(<span class="keyword">MINUTE</span>, start_time, submit_time) <span class="operator">&lt;</span> <span class="number">5</span> <span class="keyword">AND</span> score <span class="operator">&lt;</span> <span class="number">60</span></span><br></pre></td></tr></table></figure>

<h3 id="删除记录（二）"><a href="#删除记录（二）" class="headerlink" title="删除记录（二）"></a>删除记录（二）</h3><p><strong>描述</strong>：现有一张试卷作答记录表<code>exam_record</code>，其中包含多年来的用户作答试卷记录，结构如下表：</p>
<p>作答记录表<code>exam_record</code>：<code>start_time</code> 是试卷开始时间，<code>submit_time</code> 是交卷时间，即结束时间，如果未完成的话，则为空。</p>
<table>
<thead>
<tr>
<th>Filed</th>
<th>Type</th>
<th align="center">Null</th>
<th>Key</th>
<th>Extra</th>
<th>Default</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>int(11)</td>
<td align="center">NO</td>
<td>PRI</td>
<td>auto_increment</td>
<td>(NULL)</td>
<td>自增 ID</td>
</tr>
<tr>
<td>uid</td>
<td>int(11)</td>
<td align="center">NO</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>用户 ID</td>
</tr>
<tr>
<td>exam_id</td>
<td>int(11)</td>
<td align="center">NO</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>试卷 ID</td>
</tr>
<tr>
<td>start_time</td>
<td>datetime</td>
<td align="center">NO</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>开始时间</td>
</tr>
<tr>
<td>submit_time</td>
<td>datetime</td>
<td align="center">YES</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>提交时间</td>
</tr>
<tr>
<td>score</td>
<td>tinyint(4)</td>
<td align="center">YES</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>分数</td>
</tr>
</tbody></table>
<p><strong>要求</strong>：请删除<code>exam_record</code>表中未完成作答&#x3D;&#x3D;或&#x3D;&#x3D;作答时间小于 5 分钟整的记录中，开始作答时间最早的 3 条记录。</p>
<p><strong>思路</strong>：这题比较简单，但是要注意题干中给出的信息，结束时间，如果未完成的话，则为空，这个其实就是一个条件</p>
<p>还有一个条件就是小于 5 分钟，跟上题类似，但是这里是<strong>或</strong>，即两个条件满足一个就行；另外就是稍微考察到了排序和 limit 的用法。</p>
<p><strong>答案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> exam_record <span class="keyword">WHERE</span> submit_time <span class="keyword">IS</span> <span class="keyword">null</span> <span class="keyword">OR</span> TIMESTAMPDIFF(<span class="keyword">MINUTE</span>, start_time, submit_time) <span class="operator">&lt;</span> <span class="number">5</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> start_time</span><br><span class="line">LIMIT <span class="number">3</span></span><br><span class="line"># 默认就是<span class="keyword">asc</span>， <span class="keyword">desc</span>是降序排列</span><br></pre></td></tr></table></figure>

<h3 id="删除记录（三）"><a href="#删除记录（三）" class="headerlink" title="删除记录（三）"></a>删除记录（三）</h3><p><strong>描述</strong>：现有一张试卷作答记录表 exam_record，其中包含多年来的用户作答试卷记录，结构如下表：</p>
<table>
<thead>
<tr>
<th>Filed</th>
<th>Type</th>
<th align="center">Null</th>
<th>Key</th>
<th>Extra</th>
<th>Default</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>int(11)</td>
<td align="center">NO</td>
<td>PRI</td>
<td>auto_increment</td>
<td>(NULL)</td>
<td>自增 ID</td>
</tr>
<tr>
<td>uid</td>
<td>int(11)</td>
<td align="center">NO</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>用户 ID</td>
</tr>
<tr>
<td>exam_id</td>
<td>int(11)</td>
<td align="center">NO</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>试卷 ID</td>
</tr>
<tr>
<td>start_time</td>
<td>datetime</td>
<td align="center">NO</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>开始时间</td>
</tr>
<tr>
<td>submit_time</td>
<td>datetime</td>
<td align="center">YES</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>提交时间</td>
</tr>
<tr>
<td>score</td>
<td>tinyint(4)</td>
<td align="center">YES</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>分数</td>
</tr>
</tbody></table>
<p><strong>要求</strong>：请删除<code>exam_record</code>表中所有记录，&#x3D;&#x3D;并重置自增主键&#x3D;&#x3D;</p>
<p><strong>思路</strong>：这题考察对三种删除语句的区别，注意高亮部分，要求重置主键；</p>
<ul>
<li><code>DROP</code>: 清空表，删除表结构，不可逆</li>
<li><code>TRUNCATE</code>: 格式化表，不删除表结构，不可逆</li>
<li><code>DELETE</code>：删除数据，可逆</li>
</ul>
<p>这里选用<code>TRUNCATE</code>的原因是：TRUNCATE 只能作用于表；<code>TRUNCATE</code>会清空表中的所有行，但表结构及其约束、索引等保持不变；<code>TRUNCATE</code>会重置表的自增值；使用<code>TRUNCATE</code>后会使表和索引所占用的空间会恢复到初始大小。</p>
<p>这题也可以采用<code>DELETE</code>来做，但是在删除后，还需要手动<code>ALTER</code>表结构来设置主键初始值；</p>
<p>同理也可以采用<code>DROP</code>来做，直接删除整张表，包括表结构，然后再新建表即可。</p>
<p><strong>答案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span>  exam_record;</span><br></pre></td></tr></table></figure>

<h2 id="表与索引操作"><a href="#表与索引操作" class="headerlink" title="表与索引操作"></a>表与索引操作</h2><h3 id="创建一张新表"><a href="#创建一张新表" class="headerlink" title="创建一张新表"></a>创建一张新表</h3><p><strong>描述</strong>：现有一张用户信息表，其中包含多年来在平台注册过的用户信息，随着牛客平台的不断壮大，用户量飞速增长，为了高效地为高活跃用户提供服务，现需要将部分用户拆分出一张新表。</p>
<p>原来的用户信息表：</p>
<table>
<thead>
<tr>
<th>Filed</th>
<th>Type</th>
<th>Null</th>
<th>Key</th>
<th>Default</th>
<th>Extra</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>int(11)</td>
<td>NO</td>
<td>PRI</td>
<td>(NULL)</td>
<td>auto_increment</td>
<td>自增 ID</td>
</tr>
<tr>
<td>uid</td>
<td>int(11)</td>
<td>NO</td>
<td>UNI</td>
<td>(NULL)</td>
<td></td>
<td>用户 ID</td>
</tr>
<tr>
<td>nick_name</td>
<td>varchar(64)</td>
<td>YES</td>
<td></td>
<td>(NULL)</td>
<td></td>
<td>昵称</td>
</tr>
<tr>
<td>achievement</td>
<td>int(11)</td>
<td>YES</td>
<td></td>
<td>0</td>
<td></td>
<td>成就值</td>
</tr>
<tr>
<td>level</td>
<td>int(11)</td>
<td>YES</td>
<td></td>
<td>(NULL)</td>
<td></td>
<td>用户等级</td>
</tr>
<tr>
<td>job</td>
<td>varchar(32)</td>
<td>YES</td>
<td></td>
<td>(NULL)</td>
<td></td>
<td>职业方向</td>
</tr>
<tr>
<td>register_time</td>
<td>datetime</td>
<td>YES</td>
<td></td>
<td>CURRENT_TIMESTAMP</td>
<td></td>
<td>注册时间</td>
</tr>
</tbody></table>
<p>作为数据分析师，请<strong>创建一张优质用户信息表 user_info_vip</strong>，表结构和用户信息表一致。</p>
<p>你应该返回的输出如下表格所示，请写出建表语句将表格中所有限制和说明记录到表里。</p>
<table>
<thead>
<tr>
<th>Filed</th>
<th>Type</th>
<th>Null</th>
<th>Key</th>
<th>Default</th>
<th>Extra</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>int(11)</td>
<td>NO</td>
<td>PRI</td>
<td>(NULL)</td>
<td>auto_increment</td>
<td>自增 ID</td>
</tr>
<tr>
<td>uid</td>
<td>int(11)</td>
<td>NO</td>
<td>UNI</td>
<td>(NULL)</td>
<td></td>
<td>用户 ID</td>
</tr>
<tr>
<td>nick_name</td>
<td>varchar(64)</td>
<td>YES</td>
<td></td>
<td>(NULL)</td>
<td></td>
<td>昵称</td>
</tr>
<tr>
<td>achievement</td>
<td>int(11)</td>
<td>YES</td>
<td></td>
<td>0</td>
<td></td>
<td>成就值</td>
</tr>
<tr>
<td>level</td>
<td>int(11)</td>
<td>YES</td>
<td></td>
<td>(NULL)</td>
<td></td>
<td>用户等级</td>
</tr>
<tr>
<td>job</td>
<td>varchar(32)</td>
<td>YES</td>
<td></td>
<td>(NULL)</td>
<td></td>
<td>职业方向</td>
</tr>
<tr>
<td>register_time</td>
<td>datetime</td>
<td>YES</td>
<td></td>
<td>CURRENT_TIMESTAMP</td>
<td></td>
<td>注册时间</td>
</tr>
</tbody></table>
<p><strong>思路</strong>：如果这题给出了旧表的名称，可直接<code>create table 新表 as select * from 旧表;</code> 但是这题并没有给出旧表名称，所以需要自己创建，注意默认值和键的创建即可，比较简单。（注意：如果是在牛客网上面执行，请注意 comment 中要和题目中的 comment 保持一致，包括大小写，否则不通过，还有字符也要设置）</p>
<p>答案：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> user_info_vip(</span><br><span class="line">    id <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT COMMENT<span class="string">&#x27;自增ID&#x27;</span>,</span><br><span class="line">    uid <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">UNIQUE</span> <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;用户ID&#x27;</span>,</span><br><span class="line">    nick_name <span class="type">VARCHAR</span>(<span class="number">64</span>) COMMENT<span class="string">&#x27;昵称&#x27;</span>,</span><br><span class="line">    achievement <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;成就值&#x27;</span>,</span><br><span class="line">    `level` <span class="type">INT</span>(<span class="number">11</span>) COMMENT <span class="string">&#x27;用户等级&#x27;</span>,</span><br><span class="line">    job <span class="type">VARCHAR</span>(<span class="number">32</span>) COMMENT <span class="string">&#x27;职业方向&#x27;</span>,</span><br><span class="line">    register_time DATETIME <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;注册时间&#x27;</span></span><br><span class="line">)<span class="keyword">CHARACTER SET</span> UTF8</span><br></pre></td></tr></table></figure>

<h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h3><p><strong>描述</strong>： 现有一张用户信息表<code>user_info</code>，其中包含多年来在平台注册过的用户信息。</p>
<p><strong>用户信息表 <code>user_info</code>：</strong></p>
<table>
<thead>
<tr>
<th>Filed</th>
<th>Type</th>
<th>Null</th>
<th>Key</th>
<th>Default</th>
<th>Extra</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>int(11)</td>
<td>NO</td>
<td>PRI</td>
<td>(NULL)</td>
<td>auto_increment</td>
<td>自增 ID</td>
</tr>
<tr>
<td>uid</td>
<td>int(11)</td>
<td>NO</td>
<td>UNI</td>
<td>(NULL)</td>
<td></td>
<td>用户 ID</td>
</tr>
<tr>
<td>nick_name</td>
<td>varchar(64)</td>
<td>YES</td>
<td></td>
<td>(NULL)</td>
<td></td>
<td>昵称</td>
</tr>
<tr>
<td>achievement</td>
<td>int(11)</td>
<td>YES</td>
<td></td>
<td>0</td>
<td></td>
<td>成就值</td>
</tr>
<tr>
<td>level</td>
<td>int(11)</td>
<td>YES</td>
<td></td>
<td>(NULL)</td>
<td></td>
<td>用户等级</td>
</tr>
<tr>
<td>job</td>
<td>varchar(32)</td>
<td>YES</td>
<td></td>
<td>(NULL)</td>
<td></td>
<td>职业方向</td>
</tr>
<tr>
<td>register_time</td>
<td>datetime</td>
<td>YES</td>
<td></td>
<td>CURRENT_TIMESTAMP</td>
<td></td>
<td>注册时间</td>
</tr>
</tbody></table>
<p><strong>要求：</strong>请在用户信息表，字段 <code>level</code> 的后面增加一列最多可保存 15 个汉字的字段 <code>school</code>；并将表中 <code>job</code> 列名改为 <code>profession</code>，同时 <code>varchar</code> 字段长度变为 10；<code>achievement</code> 的默认值设置为 0。</p>
<p><strong>思路</strong>：首先做这题之前，需要了解 ALTER 语句的基本用法：</p>
<ul>
<li>添加一列：<code>ALTER TABLE 表名 ADD COLUMN 列名 类型 【first | after 字段名】;</code>（first ： 在某列之前添加，after 反之）</li>
<li>修改列的类型或约束：<code>ALTER TABLE 表名 MODIFY COLUMN 列名 新类型 【新约束】;</code></li>
<li>修改列名：<code>ALTER TABLE 表名 change COLUMN 旧列名 新列名 类型;</code></li>
<li>删除列：<code>ALTER TABLE 表名 drop COLUMN 列名;</code></li>
<li>修改表名：<code>ALTER TABLE 表名 rename 【to】 新表名;</code></li>
<li>将某一列放到第一列：<code>ALTER TABLE 表名 MODIFY COLUMN 列名 类型 first;</code></li>
</ul>
<p><code>COLUMN</code> 关键字其实可以省略不写，这里基于规范还是罗列出来了。</p>
<p>在修改时，如果有多个修改项，可以写到一起，但要注意格式</p>
<p><strong>答案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> user_info</span><br><span class="line">    <span class="keyword">ADD</span> school <span class="type">VARCHAR</span>(<span class="number">15</span>) AFTER level,</span><br><span class="line">    CHANGE job profession <span class="type">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">    MODIFY achievement <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><p><strong>描述</strong>：现有一张试卷作答记录表 <code>exam_record</code>，其中包含多年来的用户作答试卷记录。一般每年都会为 <code>exam_record</code> 表建立一张备份表 <code>exam_record_&#123;YEAR&#125;，&#123;YEAR&#125;</code> 为对应年份。</p>
<p>现在随着数据越来越多，存储告急，请你把很久前的（2011 到 2014 年）备份表都删掉（如果存在的话）。</p>
<p><strong>思路</strong>：这题很简单，直接删就行，如果嫌麻烦，可以将要删除的表用逗号隔开，写到一行；这里肯定会有小伙伴问：如果要删除很多张表呢？放心，如果要删除很多张表，可以写脚本来进行删除。</p>
<p><strong>答案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> exam_record_2011;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> exam_record_2012;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> exam_record_2013;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> exam_record_2014;</span><br></pre></td></tr></table></figure>

<h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><p><strong>描述</strong>：现有一张试卷信息表 <code>examination_info</code>，其中包含各种类型试卷的信息。为了对表更方便快捷地查询，需要在 <code>examination_info</code> 表创建以下索引，</p>
<p>规则如下：在 <code>duration</code> 列创建普通索引 <code>idx_duration</code>、在 <code>exam_id</code> 列创建唯一性索引 <code>uniq_idx_exam_id</code>、在 <code>tag</code> 列创建全文索引 <code>full_idx_tag</code>。</p>
<p>根据题意，将返回如下结果：</p>
<table>
<thead>
<tr>
<th>examination_info</th>
<th>0</th>
<th>PRIMARY</th>
<th>1</th>
<th>id</th>
<th>A</th>
<th>0</th>
<th></th>
<th></th>
<th></th>
<th>BTREE</th>
</tr>
</thead>
<tbody><tr>
<td>examination_info</td>
<td>0</td>
<td>uniq_idx_exam_id</td>
<td>1</td>
<td>exam_id</td>
<td>A</td>
<td>0</td>
<td></td>
<td></td>
<td>YES</td>
<td>BTREE</td>
</tr>
<tr>
<td>examination_info</td>
<td>1</td>
<td>idx_duration</td>
<td>1</td>
<td>duration</td>
<td>A</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td>BTREE</td>
</tr>
<tr>
<td>examination_info</td>
<td>1</td>
<td>full_idx_tag</td>
<td>1</td>
<td>tag</td>
<td></td>
<td>0</td>
<td></td>
<td></td>
<td>YES</td>
<td>FULLTEXT</td>
</tr>
</tbody></table>
<p>备注：后台会通过 <code>SHOW INDEX FROM examination_info</code> 语句来对比输出结果</p>
<p><strong>思路</strong>：做这题首先需要了解常见的索引类型：</p>
<ul>
<li>B-Tree 索引：B-Tree（或称为平衡树）索引是最常见和默认的索引类型。它适用于各种查询条件，可以快速定位到符合条件的数据。B-Tree 索引适用于普通的查找操作，支持等值查询、范围查询和排序。</li>
<li>唯一索引：唯一索引与普通的 B-Tree 索引类似，不同之处在于它要求被索引的列的值是唯一的。这意味着在插入或更新数据时，MySQL 会验证索引列的唯一性。</li>
<li>主键索引：主键索引是一种特殊的唯一索引，它用于唯一标识表中的每一行数据。每个表只能有一个主键索引，它可以帮助提高数据的访问速度和数据完整性。</li>
<li>全文索引：全文索引用于在文本数据中进行全文搜索。它支持在文本字段中进行关键字搜索，而不仅仅是简单的等值或范围查找。全文索引适用于需要进行全文搜索的应用场景。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 示例：</span></span><br><span class="line"><span class="comment">-- 添加B-Tree索引：</span></span><br><span class="line">	<span class="keyword">CREATE</span> INDEX idx_name(索引名) <span class="keyword">ON</span> 表名 (字段名);   <span class="comment">-- idx_name为索引名，以下都是</span></span><br><span class="line"><span class="comment">-- 创建唯一索引：</span></span><br><span class="line">	<span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX idx_name <span class="keyword">ON</span> 表名 (字段名);</span><br><span class="line"><span class="comment">-- 创建一个主键索引：</span></span><br><span class="line">	<span class="keyword">ALTER TABLE</span> 表名 <span class="keyword">ADD</span> <span class="keyword">PRIMARY KEY</span> (字段名);</span><br><span class="line"><span class="comment">-- 创建一个全文索引</span></span><br><span class="line">	<span class="keyword">ALTER TABLE</span> 表名 <span class="keyword">ADD</span> FULLTEXT INDEX idx_name (字段名);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 通过以上示例，可以看出create 和 alter 都可以添加索引</span></span><br></pre></td></tr></table></figure>

<p>有了以上的基础知识之后，该题答案也就浮出水面了。</p>
<p><strong>答案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> examination_info</span><br><span class="line">    <span class="keyword">ADD</span> INDEX idx_duration(duration),</span><br><span class="line">    <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> INDEX uniq_idx_exam_id(exam_id),</span><br><span class="line">    <span class="keyword">ADD</span> FULLTEXT INDEX full_idx_tag(tag);</span><br></pre></td></tr></table></figure>

<h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><p><strong>描述</strong>：请删除<code>examination_info</code>表上的唯一索引 uniq_idx_exam_id 和全文索引 full_idx_tag。</p>
<p><strong>思路</strong>：该题考察删除索引的基本语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用 DROP INDEX 删除索引</span></span><br><span class="line"><span class="keyword">DROP</span> INDEX idx_name <span class="keyword">ON</span> 表名;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 ALTER TABLE 删除索引</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> employees <span class="keyword">DROP</span> INDEX idx_email;</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是：在 MySQL 中，一次删除多个索引的操作是不支持的。每次删除索引时，只能指定一个索引名称进行删除。</p>
<p>而且 <strong>DROP</strong> 命令需要慎用！！！</p>
<p><strong>答案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX uniq_idx_exam_id <span class="keyword">ON</span> examination_info;</span><br><span class="line"><span class="keyword">DROP</span> INDEX full_idx_tag <span class="keyword">ON</span> examination_info;</span><br></pre></td></tr></table></figure>

<!-- @include: @article-footer.snippet.md -->

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2024/09/28/rocketmq-questions/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/09/28/rocketmq-questions/" itemprop="url">RocketMQ常见问题总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-09-28T21:47:35+08:00">
                2024-09-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" itemprop="url" rel="index">
                    <span itemprop="name">消息队列</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2024/09/28/rocketmq-questions/" class="leancloud_visitors" data-flag-title="RocketMQ常见问题总结">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  17.3k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  61 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="消息队列扫盲"><a href="#消息队列扫盲" class="headerlink" title="消息队列扫盲"></a>消息队列扫盲</h2><p>消息队列顾名思义就是存放消息的队列，队列我就不解释了，别告诉我你连队列都不知道是啥吧？</p>
<p>所以问题并不是消息队列是什么，而是 <strong>消息队列为什么会出现？消息队列能用来干什么？用它来干这些事会带来什么好处？消息队列会带来副作用吗？</strong></p>
<h3 id="消息队列为什么会出现？"><a href="#消息队列为什么会出现？" class="headerlink" title="消息队列为什么会出现？"></a>消息队列为什么会出现？</h3><p>消息队&#96;&#96;列算是作为后端程序员的一个必备技能吧，因为<strong>分布式应用必定涉及到各个系统之间的通信问题</strong>，这个时候消息队列也应运而生了。可以说分布式的产生是消息队列的基础，而分布式怕是一个很古老的概念了吧，所以消息队列也是一个很古老的中间件了。</p>
<h3 id="消息队列能用来干什么？"><a href="#消息队列能用来干什么？" class="headerlink" title="消息队列能用来干什么？"></a>消息队列能用来干什么？</h3><h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><p>你可能会反驳我，应用之间的通信又不是只能由消息队列解决，好好的通信为什么中间非要插一个消息队列呢？我不能直接进行通信吗？</p>
<p>很好 👍，你又提出了一个概念，<strong>同步通信</strong>。就比如现在业界使用比较多的 <code>Dubbo</code> 就是一个适用于各个系统之间同步通信的 <code>RPC</code> 框架。</p>
<p>我来举个 🌰 吧，比如我们有一个购票系统，需求是用户在购买完之后能接收到购买完成的短信。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/16ef37fee7e09230.jpg"></p>
<p>我们省略中间的网络通信时间消耗，假如购票系统处理需要 150ms ，短信系统处理需要 200ms ，那么整个处理流程的时间消耗就是 150ms + 200ms &#x3D; 350ms。</p>
<p>当然，乍看没什么问题。可是仔细一想你就感觉有点问题，我用户购票在购票系统的时候其实就已经完成了购买，而我现在通过同步调用非要让整个请求拉长时间，而短信系统这玩意又不是很有必要，它仅仅是一个辅助功能增强用户体验感而已。我现在整个调用流程就有点 <strong>头重脚轻</strong> 的感觉了，购票是一个不太耗时的流程，而我现在因为同步调用，非要等待发送短信这个比较耗时的操作才返回结果。那我如果再加一个发送邮件呢？</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/16ef380429cf373e.jpg"></p>
<p>这样整个系统的调用链又变长了，整个时间就变成了 550ms。</p>
<p>当我们在学生时代需要在食堂排队的时候，我们和食堂大妈就是一个同步的模型。</p>
<p>我们需要告诉食堂大妈：“姐姐，给我加个鸡腿，再加个酸辣土豆丝，帮我浇点汁上去，多打点饭哦 😋😋😋” 咦~~~ 为了多吃点，真恶心。</p>
<p>然后大妈帮我们打饭配菜，我们看着大妈那颤抖的手和掉落的土豆丝不禁咽了咽口水。</p>
<p>最终我们从大妈手中接过饭菜然后去寻找座位了…</p>
<p>回想一下，我们在给大妈发送需要的信息之后我们是 <strong>同步等待大妈给我配好饭菜</strong> 的，上面我们只是加了鸡腿和土豆丝，万一我再加一个番茄牛腩，韭菜鸡蛋，这样是不是大妈打饭配菜的流程就会变长，我们等待的时间也会相应的变长。</p>
<p>那后来，我们工作赚钱了有钱去饭店吃饭了，我们告诉服务员来一碗牛肉面加个荷包蛋 <strong>(传达一个消息)</strong> ，然后我们就可以在饭桌上安心的玩手机了 <strong>(干自己其他事情)</strong> ，等到我们的牛肉面上了我们就可以吃了。这其中我们也就传达了一个消息，然后我们又转过头干其他事情了。这其中虽然做面的时间没有变短，但是我们只需要传达一个消息就可以干其他事情了，这是一个 <strong>异步</strong> 的概念。</p>
<p>所以，为了解决这一个问题，聪明的程序员在中间也加了个类似于服务员的中间件——消息队列。这个时候我们就可以把模型给改造了。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/16ef38124f55eaea.jpg"></p>
<p>这样，我们在将消息存入消息队列之后我们就可以直接返回了(我们告诉服务员我们要吃什么然后玩手机)，所以整个耗时只是 150ms + 10ms &#x3D; 160ms。</p>
<blockquote>
<p>但是你需要注意的是，整个流程的时长是没变的，就像你仅仅告诉服务员要吃什么是不会影响到做面的速度的。</p>
</blockquote>
<h4 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h4><p>回到最初同步调用的过程，我们写个伪代码简单概括一下。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/16ef381a505d3e1f.jpg"></p>
<p>那么第二步，我们又添加了一个发送邮件，我们就得重新去修改代码，如果我们又加一个需求：用户购买完还需要给他加积分，这个时候我们是不是又得改代码？</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/16ef381c4e1b1ac7.jpg"></p>
<p>如果你觉得还行，那么我这个时候不要发邮件这个服务了呢，我是不是又得改代码，又得重启应用？</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/16ef381f273a66bd.jpg"></p>
<p>这样改来改去是不是很麻烦，那么 <strong>此时我们就用一个消息队列在中间进行解耦</strong> 。你需要注意的是，我们后面的发送短信、发送邮件、添加积分等一些操作都依赖于上面的 <code>result</code> ，这东西抽象出来就是购票的处理结果呀，比如订单号，用户账号等等，也就是说我们后面的一系列服务都是需要同样的消息来进行处理。既然这样，我们是不是可以通过 <strong>“广播消息”</strong> 来实现。</p>
<p>我上面所讲的“广播”并不是真正的广播，而是接下来的系统作为消费者去 <strong>订阅</strong> 特定的主题。比如我们这里的主题就可以叫做 <code>订票</code> ，我们购买系统作为一个生产者去生产这条消息放入消息队列，然后消费者订阅了这个主题，会从消息队列中拉取消息并消费。就比如我们刚刚画的那张图，你会发现，在生产者这边我们只需要关注 <strong>生产消息到指定主题中</strong> ，而 <strong>消费者只需要关注从指定主题中拉取消息</strong> 就行了。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/16ef382674b66892.jpg"></p>
<blockquote>
<p>如果没有消息队列，每当一个新的业务接入，我们都要在主系统调用新接口、或者当我们取消某些业务，我们也得在主系统删除某些接口调用。有了消息队列，我们只需要关心消息是否送达了队列，至于谁希望订阅，接下来收到消息如何处理，是下游的事情，无疑极大地减少了开发和联调的工作量。</p>
</blockquote>
<h4 id="削峰"><a href="#削峰" class="headerlink" title="削峰"></a>削峰</h4><p>我们再次回到一开始我们使用同步调用系统的情况，并且思考一下，如果此时有大量用户请求购票整个系统会变成什么样？</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/16ef382a9756bb1c.jpg"></p>
<p>如果，此时有一万的请求进入购票系统，我们知道运行我们主业务的服务器配置一般会比较好，所以这里我们假设购票系统能承受这一万的用户请求，那么也就意味着我们同时也会出现一万调用发短信服务的请求。而对于短信系统来说并不是我们的主要业务，所以我们配备的硬件资源并不会太高，那么你觉得现在这个短信系统能承受这一万的峰值么，且不说能不能承受，系统会不会 <strong>直接崩溃</strong> 了？</p>
<p>短信业务又不是我们的主业务，我们能不能 <strong>折中处理</strong> 呢？如果我们把购买完成的信息发送到消息队列中，而短信系统 <strong>尽自己所能地去消息队列中取消息和消费消息</strong> ，即使处理速度慢一点也无所谓，只要我们的系统没有崩溃就行了。</p>
<p>留得江山在，还怕没柴烧？你敢说每次发送验证码的时候是一发你就收到了的么？</p>
<h4 id="消息队列能带来什么好处？"><a href="#消息队列能带来什么好处？" class="headerlink" title="消息队列能带来什么好处？"></a>消息队列能带来什么好处？</h4><p>其实上面我已经说了。<strong>异步、解耦、削峰。</strong> 哪怕你上面的都没看懂也千万要记住这六个字，因为他不仅是消息队列的精华，更是编程和架构的精华。</p>
<h4 id="消息队列会带来副作用吗？"><a href="#消息队列会带来副作用吗？" class="headerlink" title="消息队列会带来副作用吗？"></a>消息队列会带来副作用吗？</h4><p>没有哪一门技术是“银弹”，消息队列也有它的副作用。</p>
<p>比如，本来好好的两个系统之间的调用，我中间加了个消息队列，如果消息队列挂了怎么办呢？是不是 <strong>降低了系统的可用性</strong> ？</p>
<p>那这样是不是要保证 HA(高可用)？是不是要搞集群？那么我 <strong>整个系统的复杂度是不是上升了</strong> ？</p>
<p>抛开上面的问题不讲，万一我发送方发送失败了，然后执行重试，这样就可能产生重复的消息。</p>
<p>或者我消费端处理失败了，请求重发，这样也会产生重复的消息。</p>
<p>对于一些微服务来说，消费重复消息会带来更大的麻烦，比如增加积分，这个时候我加了多次是不是对其他用户不公平？</p>
<p>那么，又 <strong>如何解决重复消费消息的问题</strong> 呢？</p>
<p>如果我们此时的消息需要保证严格的顺序性怎么办呢？比如生产者生产了一系列的有序消息(对一个 id 为 1 的记录进行删除增加修改)，但是我们知道在发布订阅模型中，对于主题是无顺序的，那么这个时候就会导致对于消费者消费消息的时候没有按照生产者的发送顺序消费，比如这个时候我们消费的顺序为修改删除增加，如果该记录涉及到金额的话是不是会出大事情？</p>
<p>那么，又 <strong>如何解决消息的顺序消费问题</strong> 呢？</p>
<p>就拿我们上面所讲的分布式系统来说，用户购票完成之后是不是需要增加账户积分？在同一个系统中我们一般会使用事务来进行解决，如果用 <code>Spring</code> 的话我们在上面伪代码中加入 <code>@Transactional</code> 注解就好了。但是在不同系统中如何保证事务呢？总不能这个系统我扣钱成功了你那积分系统积分没加吧？或者说我这扣钱明明失败了，你那积分系统给我加了积分。</p>
<p>那么，又如何 <strong>解决分布式事务问题</strong> 呢？</p>
<p>我们刚刚说了，消息队列可以进行削峰操作，那如果我的消费者如果消费很慢或者生产者生产消息很快，这样是不是会将消息堆积在消息队列中？</p>
<p>那么，又如何 <strong>解决消息堆积的问题</strong> 呢？</p>
<p>可用性降低，复杂度上升，又带来一系列的重复消费，顺序消费，分布式事务，消息堆积的问题，这消息队列还怎么用啊 😵？</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/16ef382d709abc9d.png"></p>
<p>别急，办法总是有的。</p>
<h2 id="RocketMQ-是什么？"><a href="#RocketMQ-是什么？" class="headerlink" title="RocketMQ 是什么？"></a>RocketMQ 是什么？</h2><p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/16ef383014430799.jpg"></p>
<p>哇，你个混蛋！上面给我抛出那么多问题，你现在又讲 <code>RocketMQ</code> ，还让不让人活了？！🤬</p>
<p>别急别急，话说你现在清楚 <code>MQ</code> 的构造吗，我还没讲呢，我们先搞明白 <code>MQ</code> 的内部构造，再来看看如何解决上面的一系列问题吧，不过你最好带着问题去阅读和了解喔。</p>
<p><code>RocketMQ</code> 是一个 <strong>队列模型</strong> 的消息中间件，具有<strong>高性能、高可靠、高实时、分布式</strong> 的特点。它是一个采用 <code>Java</code> 语言开发的分布式的消息系统，由阿里巴巴团队开发，在 2016 年底贡献给 <code>Apache</code>，成为了 <code>Apache</code> 的一个顶级项目。 在阿里内部，<code>RocketMQ</code> 很好地服务了集团大大小小上千个应用，在每年的双十一当天，更有不可思议的万亿级消息通过 <code>RocketMQ</code> 流转。</p>
<p>废话不多说，想要了解 <code>RocketMQ</code> 历史的同学可以自己去搜寻资料。听完上面的介绍，你只要知道 <code>RocketMQ</code> 很快、很牛、而且经历过双十一的实践就行了！</p>
<h2 id="队列模型和主题模型是什么？"><a href="#队列模型和主题模型是什么？" class="headerlink" title="队列模型和主题模型是什么？"></a>队列模型和主题模型是什么？</h2><p>在谈 <code>RocketMQ</code> 的技术架构之前，我们先来了解一下两个名词概念——<strong>队列模型</strong> 和 <strong>主题模型</strong> 。</p>
<p>首先我问一个问题，消息队列为什么要叫消息队列？</p>
<p>你可能觉得很弱智，这玩意不就是存放消息的队列嘛？不叫消息队列叫什么？</p>
<p>的确，早期的消息中间件是通过 <strong>队列</strong> 这一模型来实现的，可能是历史原因，我们都习惯把消息中间件成为消息队列。</p>
<p>但是，如今例如 <code>RocketMQ</code>、<code>Kafka</code> 这些优秀的消息中间件不仅仅是通过一个 <strong>队列</strong> 来实现消息存储的。</p>
<h3 id="队列模型"><a href="#队列模型" class="headerlink" title="队列模型"></a>队列模型</h3><p>就像我们理解队列一样，消息中间件的队列模型就真的只是一个队列。。。我画一张图给大家理解。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/16ef3834ae653469.jpg"></p>
<p>在一开始我跟你提到了一个 <strong>“广播”</strong> 的概念，也就是说如果我们此时我们需要将一个消息发送给多个消费者(比如此时我需要将信息发送给短信系统和邮件系统)，这个时候单个队列即不能满足需求了。</p>
<p>当然你可以让 <code>Producer</code> 生产消息放入多个队列中，然后每个队列去对应每一个消费者。问题是可以解决，创建多个队列并且复制多份消息是会很影响资源和性能的。而且，这样子就会导致生产者需要知道具体消费者个数然后去复制对应数量的消息队列，这就违背我们消息中间件的 <strong>解耦</strong> 这一原则。</p>
<h3 id="主题模型"><a href="#主题模型" class="headerlink" title="主题模型"></a>主题模型</h3><p>那么有没有好的方法去解决这一个问题呢？有，那就是 <strong>主题模型</strong> 或者可以称为 <strong>发布订阅模型</strong> 。</p>
<blockquote>
<p>感兴趣的同学可以去了解一下设计模式里面的观察者模式并且手动实现一下，我相信你会有所收获的。</p>
</blockquote>
<p>在主题模型中，消息的生产者称为 <strong>发布者(Publisher)</strong> ，消息的消费者称为 <strong>订阅者(Subscriber)</strong> ，存放消息的容器称为 <strong>主题(Topic)</strong> 。</p>
<p>其中，发布者将消息发送到指定主题中，订阅者需要 <strong>提前订阅主题</strong> 才能接受特定主题的消息。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/16ef3837887d9a54sds.jpg"></p>
<h3 id="RocketMQ-中的消息模型"><a href="#RocketMQ-中的消息模型" class="headerlink" title="RocketMQ 中的消息模型"></a>RocketMQ 中的消息模型</h3><p><code>RocketMQ</code> 中的消息模型就是按照 <strong>主题模型</strong> 所实现的。你可能会好奇这个 <strong>主题</strong> 到底是怎么实现的呢？你上面也没有讲到呀！</p>
<p>其实对于主题模型的实现来说每个消息中间件的底层设计都是不一样的，就比如 <code>Kafka</code> 中的 <strong>分区</strong> ，<code>RocketMQ</code> 中的 <strong>队列</strong> ，<code>RabbitMQ</code> 中的 <code>Exchange</code> 。我们可以理解为 <strong>主题模型&#x2F;发布订阅模型</strong> 就是一个标准，那些中间件只不过照着这个标准去实现而已。</p>
<p>所以，<code>RocketMQ</code> 中的 <strong>主题模型</strong> 到底是如何实现的呢？首先我画一张图，大家尝试着去理解一下。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/16ef383d3e8c9788.jpg"></p>
<p>我们可以看到在整个图中有 <code>Producer Group</code>、<code>Topic</code>、<code>Consumer Group</code> 三个角色，我来分别介绍一下他们。</p>
<ul>
<li><code>Producer Group</code> 生产者组：代表某一类的生产者，比如我们有多个秒杀系统作为生产者，这多个合在一起就是一个 <code>Producer Group</code> 生产者组，它们一般生产相同的消息。</li>
<li><code>Consumer Group</code> 消费者组：代表某一类的消费者，比如我们有多个短信系统作为消费者，这多个合在一起就是一个 <code>Consumer Group</code> 消费者组，它们一般消费相同的消息。</li>
<li><code>Topic</code> 主题：代表一类消息，比如订单消息，物流消息等等。</li>
</ul>
<p>你可以看到图中生产者组中的生产者会向主题发送消息，而 <strong>主题中存在多个队列</strong>，生产者每次生产消息之后是指定主题中的某个队列发送消息的。</p>
<p>每个主题中都有多个队列(分布在不同的 <code>Broker</code>中，如果是集群的话，<code>Broker</code>又分布在不同的服务器中)，集群消费模式下，一个消费者集群多台机器共同消费一个 <code>topic</code> 的多个队列，<strong>一个队列只会被一个消费者消费</strong>。如果某个消费者挂掉，分组内其它消费者会接替挂掉的消费者继续消费。就像上图中 <code>Consumer1</code> 和 <code>Consumer2</code> 分别对应着两个队列，而 <code>Consumer3</code> 是没有队列对应的，所以一般来讲要控制 <strong>消费者组中的消费者个数和主题中队列个数相同</strong> 。</p>
<p>当然也可以消费者个数小于队列个数，只不过不太建议。如下图。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/16ef3850c808d707.jpg"></p>
<p><strong>每个消费组在每个队列上维护一个消费位置</strong> ，为什么呢？</p>
<p>因为我们刚刚画的仅仅是一个消费者组，我们知道在发布订阅模式中一般会涉及到多个消费者组，而每个消费者组在每个队列中的消费位置都是不同的。如果此时有多个消费者组，那么消息被一个消费者组消费完之后是不会删除的(因为其它消费者组也需要呀)，它仅仅是为每个消费者组维护一个 <strong>消费位移(offset)</strong> ，每次消费者组消费完会返回一个成功的响应，然后队列再把维护的消费位移加一，这样就不会出现刚刚消费过的消息再一次被消费了。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/16ef3857fefaa079.jpg"></p>
<p>可能你还有一个问题，<strong>为什么一个主题中需要维护多个队列</strong> ？</p>
<p>答案是 <strong>提高并发能力</strong> 。的确，每个主题中只存在一个队列也是可行的。你想一下，如果每个主题中只存在一个队列，这个队列中也维护着每个消费者组的消费位置，这样也可以做到 <strong>发布订阅模式</strong> 。如下图。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/16ef38600cdb6d4b.jpg"></p>
<p>但是，这样我生产者是不是只能向一个队列发送消息？又因为需要维护消费位置所以一个队列只能对应一个消费者组中的消费者，这样是不是其他的 <code>Consumer</code> 就没有用武之地了？从这两个角度来讲，并发度一下子就小了很多。</p>
<p>所以总结来说，<code>RocketMQ</code> 通过<strong>使用在一个 <code>Topic</code> 中配置多个队列并且每个队列维护每个消费者组的消费位置</strong> 实现了 <strong>主题模式&#x2F;发布订阅模式</strong> 。</p>
<h2 id="RocketMQ-的架构图"><a href="#RocketMQ-的架构图" class="headerlink" title="RocketMQ 的架构图"></a>RocketMQ 的架构图</h2><p>讲完了消息模型，我们理解起 <code>RocketMQ</code> 的技术架构起来就容易多了。</p>
<p><code>RocketMQ</code> 技术架构中有四大角色 <code>NameServer</code>、<code>Broker</code>、<code>Producer</code>、<code>Consumer</code> 。我来向大家分别解释一下这四个角色是干啥的。</p>
<ul>
<li><p><code>Broker</code>：主要负责消息的存储、投递和查询以及服务高可用保证。说白了就是消息队列服务器嘛，生产者生产消息到 <code>Broker</code> ，消费者从 <code>Broker</code> 拉取消息并消费。</p>
<p>这里，我还得普及一下关于 <code>Broker</code>、<code>Topic</code> 和 队列的关系。上面我讲解了 <code>Topic</code> 和队列的关系——一个 <code>Topic</code> 中存在多个队列，那么这个 <code>Topic</code> 和队列存放在哪呢？</p>
<p><strong>一个 <code>Topic</code> 分布在多个 <code>Broker</code>上，一个 <code>Broker</code> 可以配置多个 <code>Topic</code> ，它们是多对多的关系</strong>。</p>
<p>如果某个 <code>Topic</code> 消息量很大，应该给它多配置几个队列(上文中提到了提高并发能力)，并且 <strong>尽量多分布在不同 <code>Broker</code> 上，以减轻某个 <code>Broker</code> 的压力</strong> 。</p>
<p><code>Topic</code> 消息量都比较均匀的情况下，如果某个 <code>broker</code> 上的队列越多，则该 <code>broker</code> 压力越大。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/16ef38687488a5a4.jpg"></p>
<blockquote>
<p>所以说我们需要配置多个 Broker。</p>
</blockquote>
</li>
<li><p><code>NameServer</code>：不知道你们有没有接触过 <code>ZooKeeper</code> 和 <code>Spring Cloud</code> 中的 <code>Eureka</code> ，它其实也是一个 <strong>注册中心</strong> ，主要提供两个功能：<strong>Broker 管理</strong> 和 <strong>路由信息管理</strong> 。说白了就是 <code>Broker</code> 会将自己的信息注册到 <code>NameServer</code> 中，此时 <code>NameServer</code> 就存放了很多 <code>Broker</code> 的信息(Broker 的路由表)，消费者和生产者就从 <code>NameServer</code> 中获取路由表然后照着路由表的信息和对应的 <code>Broker</code> 进行通信(生产者和消费者定期会向 <code>NameServer</code> 去查询相关的 <code>Broker</code> 的信息)。</p>
</li>
<li><p><code>Producer</code>：消息发布的角色，支持分布式集群方式部署。说白了就是生产者。</p>
</li>
<li><p><code>Consumer</code>：消息消费的角色，支持分布式集群方式部署。支持以 push 推，pull 拉两种模式对消息进行消费。同时也支持集群方式和广播方式的消费，它提供实时消息订阅机制。说白了就是消费者。</p>
</li>
</ul>
<p>听完了上面的解释你可能会觉得，这玩意好简单。不就是这样的么？</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/16ef386c6d1e8bdb.jpg"></p>
<p>嗯？你可能会发现一个问题，这老家伙 <code>NameServer</code> 干啥用的，这不多余吗？直接 <code>Producer</code>、<code>Consumer</code> 和 <code>Broker</code> 直接进行生产消息，消费消息不就好了么？</p>
<p>但是，我们上文提到过 <code>Broker</code> 是需要保证高可用的，如果整个系统仅仅靠着一个 <code>Broker</code> 来维持的话，那么这个 <code>Broker</code> 的压力会不会很大？所以我们需要使用多个 <code>Broker</code> 来保证 <strong>负载均衡</strong> 。</p>
<p>如果说，我们的消费者和生产者直接和多个 <code>Broker</code> 相连，那么当 <code>Broker</code> 修改的时候必定会牵连着每个生产者和消费者，这样就会产生耦合问题，而 <code>NameServer</code> 注册中心就是用来解决这个问题的。</p>
<blockquote>
<p>如果还不是很理解的话，可以去看我介绍 <code>Spring Cloud</code> 的那篇文章，其中介绍了 <code>Eureka</code> 注册中心。</p>
</blockquote>
<p>当然，<code>RocketMQ</code> 中的技术架构肯定不止前面那么简单，因为上面图中的四个角色都是需要做集群的。我给出一张官网的架构图，大家尝试理解一下。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/16ef386fa3be1e53.jpg"></p>
<p>其实和我们最开始画的那张乞丐版的架构图也没什么区别，主要是一些细节上的差别。听我细细道来 🤨。</p>
<p>第一、我们的 <code>Broker</code> <strong>做了集群并且还进行了主从部署</strong> ，由于消息分布在各个 <code>Broker</code> 上，一旦某个 <code>Broker</code> 宕机，则该<code>Broker</code> 上的消息读写都会受到影响。所以 <code>Rocketmq</code> 提供了 <code>master/slave</code> 的结构，<code>salve</code> 定时从 <code>master</code> 同步数据(同步刷盘或者异步刷盘)，如果 <code>master</code> 宕机，<strong>则 <code>slave</code> 提供消费服务，但是不能写入消息</strong> (后面我还会提到哦)。</p>
<p>第二、为了保证 <code>HA</code> ，我们的 <code>NameServer</code> 也做了集群部署，但是请注意它是 <strong>去中心化</strong> 的。也就意味着它没有主节点，你可以很明显地看出 <code>NameServer</code> 的所有节点是没有进行 <code>Info Replicate</code> 的，在 <code>RocketMQ</code> 中是通过 <strong>单个 Broker 和所有 NameServer 保持长连接</strong> ，并且在每隔 30 秒 <code>Broker</code> 会向所有 <code>Nameserver</code> 发送心跳，心跳包含了自身的 <code>Topic</code> 配置信息，这个步骤就对应这上面的 <code>Routing Info</code> 。</p>
<p>第三、在生产者需要向 <code>Broker</code> 发送消息的时候，<strong>需要先从 <code>NameServer</code> 获取关于 <code>Broker</code> 的路由信息</strong>，然后通过 <strong>轮询</strong> 的方法去向每个队列中生产数据以达到 <strong>负载均衡</strong> 的效果。</p>
<p>第四、消费者通过 <code>NameServer</code> 获取所有 <code>Broker</code> 的路由信息后，向 <code>Broker</code> 发送 <code>Pull</code> 请求来获取消息数据。<code>Consumer</code> 可以以两种模式启动—— <strong>广播（Broadcast）和集群（Cluster）</strong>。广播模式下，一条消息会发送给 <strong>同一个消费组中的所有消费者</strong> ，集群模式下消息只会发送给一个消费者。</p>
<h2 id="RocketMQ-功能特性"><a href="#RocketMQ-功能特性" class="headerlink" title="RocketMQ 功能特性"></a>RocketMQ 功能特性</h2><h3 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h3><h4 id="普通消息"><a href="#普通消息" class="headerlink" title="普通消息"></a>普通消息</h4><p>普通消息一般应用于微服务解耦、事件驱动、数据集成等场景，这些场景大多数要求数据传输通道具有可靠传输的能力，且对消息的处理时机、处理顺序没有特别要求。以在线的电商交易场景为例，上游订单系统将用户下单支付这一业务事件封装成独立的普通消息并发送至 RocketMQ 服务端，下游按需从服务端订阅消息并按照本地消费逻辑处理下游任务。每个消息之间都是相互独立的，且不需要产生关联。另外还有日志系统，以离线的日志收集场景为例，通过埋点组件收集前端应用的相关操作日志，并转发到 RocketMQ 。</p>
<p><img src="https://rocketmq.apache.org/zh/assets/images/lifecyclefornormal-e8a2a7e42a0722f681eb129b51e1bd66.png"></p>
<p><strong>普通消息生命周期</strong></p>
<ul>
<li>初始化：消息被生产者构建并完成初始化，待发送到服务端的状态。</li>
<li>待消费：消息被发送到服务端，对消费者可见，等待消费者消费的状态。</li>
<li>消费中：消息被消费者获取，并按照消费者本地的业务逻辑进行处理的过程。 此时服务端会等待消费者完成消费并提交消费结果，如果一定时间后没有收到消费者的响应，RocketMQ 会对消息进行重试处理。</li>
<li>消费提交：消费者完成消费处理，并向服务端提交消费结果，服务端标记当前消息已经被处理（包括消费成功和失败）。RocketMQ 默认支持保留所有消息，此时消息数据并不会立即被删除，只是逻辑标记已消费。消息在保存时间到期或存储空间不足被删除前，消费者仍然可以回溯消息重新消费。</li>
<li>消息删除：RocketMQ 按照消息保存机制滚动清理最早的消息数据，将消息从物理文件中删除。</li>
</ul>
<h4 id="定时消息"><a href="#定时消息" class="headerlink" title="定时消息"></a>定时消息</h4><p>在分布式定时调度触发、任务超时处理等场景，需要实现精准、可靠的定时事件触发。使用 RocketMQ 的定时消息可以简化定时调度任务的开发逻辑，实现高性能、可扩展、高可靠的定时触发能力。定时消息仅支持在 MessageType 为 Delay 的主题内使用，即定时消息只能发送至类型为定时消息的主题中，发送的消息的类型必须和主题的类型一致。在 4.x 版本中，只支持延时消息，默认分为 18 个等级分别为：1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h，也可以在配置文件中增加自定义的延时等级和时长。在 5.x 版本中，开始支持定时消息，在构造消息时提供了 3 个 API 来指定延迟时间或定时时间。</p>
<p>基于定时消息的超时任务处理具备如下优势：</p>
<ul>
<li><strong>精度高、开发门槛低</strong>：基于消息通知方式不存在定时阶梯间隔。可以轻松实现任意精度事件触发，无需业务去重。</li>
<li><strong>高性能可扩展</strong>：传统的数据库扫描方式较为复杂，需要频繁调用接口扫描，容易产生性能瓶颈。RocketMQ 的定时消息具有高并发和水平扩展的能力。</li>
</ul>
<p><img src="https://rocketmq.apache.org/zh/assets/images/lifecyclefordelay-2ce8278df69cd026dd11ffd27ab09a17.png"></p>
<p><strong>定时消息生命周期</strong></p>
<ul>
<li>初始化：消息被生产者构建并完成初始化，待发送到服务端的状态。</li>
<li>定时中：消息被发送到服务端，和普通消息不同的是，服务端不会直接构建消息索引，而是会将定时消息<strong>单独存储在定时存储系统中</strong>，等待定时时刻到达。</li>
<li>待消费：定时时刻到达后，服务端将消息重新写入普通存储引擎，对下游消费者可见，等待消费者消费的状态。</li>
<li>消费中：消息被消费者获取，并按照消费者本地的业务逻辑进行处理的过程。 此时服务端会等待消费者完成消费并提交消费结果，如果一定时间后没有收到消费者的响应，RocketMQ 会对消息进行重试处理。</li>
<li>消费提交：消费者完成消费处理，并向服务端提交消费结果，服务端标记当前消息已经被处理（包括消费成功和失败）。RocketMQ 默认支持保留所有消息，此时消息数据并不会立即被删除，只是逻辑标记已消费。消息在保存时间到期或存储空间不足被删除前，消费者仍然可以回溯消息重新消费。</li>
<li>消息删除：Apache RocketMQ 按照消息保存机制滚动清理最早的消息数据，将消息从物理文件中删除。</li>
</ul>
<p>定时消息的实现逻辑需要先经过定时存储等待触发，定时时间到达后才会被投递给消费者。因此，如果将大量定时消息的定时时间设置为同一时刻，则到达该时刻后会有大量消息同时需要被处理，会造成系统压力过大，导致消息分发延迟，影响定时精度。</p>
<h4 id="顺序消息"><a href="#顺序消息" class="headerlink" title="顺序消息"></a>顺序消息</h4><p>顺序消息仅支持使用 MessageType 为 FIFO 的主题，即顺序消息只能发送至类型为顺序消息的主题中，发送的消息的类型必须和主题的类型一致。和普通消息发送相比，顺序消息发送必须要设置消息组。（推荐实现 MessageQueueSelector 的方式，见下文）。要保证消息的顺序性需要单一生产者串行发送。</p>
<p>单线程使用 MessageListenerConcurrently 可以顺序消费，多线程环境下使用 MessageListenerOrderly 才能顺序消费。</p>
<h4 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h4><p>事务消息是 Apache RocketMQ 提供的一种高级消息类型，支持在分布式场景下保障消息生产和本地事务的最终一致性。简单来讲，就是将本地事务（数据库的 DML 操作）与发送消息合并在同一个事务中。例如，新增一个订单。在事务未提交之前，不发送订阅的消息。发送消息的动作随着事务的成功提交而发送，随着事务的回滚而取消。当然真正地处理过程不止这么简单，包含了半消息、事务监听和事务回查等概念，下面有更详细的说明。</p>
<h2 id="关于发送消息"><a href="#关于发送消息" class="headerlink" title="关于发送消息"></a>关于发送消息</h2><h3 id="不建议单一进程创建大量生产者"><a href="#不建议单一进程创建大量生产者" class="headerlink" title="不建议单一进程创建大量生产者"></a><strong>不建议单一进程创建大量生产者</strong></h3><p>Apache RocketMQ 的生产者和主题是多对多的关系，支持同一个生产者向多个主题发送消息。对于生产者的创建和初始化，建议遵循够用即可、最大化复用原则，如果有需要发送消息到多个主题的场景，无需为每个主题都创建一个生产者。</p>
<h3 id="不建议频繁创建和销毁生产者"><a href="#不建议频繁创建和销毁生产者" class="headerlink" title="不建议频繁创建和销毁生产者"></a><strong>不建议频繁创建和销毁生产者</strong></h3><p>Apache RocketMQ 的生产者是可以重复利用的底层资源，类似数据库的连接池。因此不需要在每次发送消息时动态创建生产者，且在发送结束后销毁生产者。这样频繁的创建销毁会在服务端产生大量短连接请求，严重影响系统性能。</p>
<p>正确示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Producer</span> <span class="variable">p</span> <span class="operator">=</span> ProducerBuilder.build();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    Message m= MessageBuilder.build();</span><br><span class="line">    p.send(m);</span><br><span class="line"> &#125;</span><br><span class="line">p.shutdown();</span><br></pre></td></tr></table></figure>

<h2 id="消费者分类"><a href="#消费者分类" class="headerlink" title="消费者分类"></a>消费者分类</h2><h3 id="PushConsumer"><a href="#PushConsumer" class="headerlink" title="PushConsumer"></a>PushConsumer</h3><p>高度封装的消费者类型，消费消息仅仅通过消费监听器监听并返回结果。消息的获取、消费状态提交以及消费重试都通过 RocketMQ 的客户端 SDK 完成。</p>
<p>PushConsumer 的消费监听器执行结果分为以下三种情况：</p>
<ul>
<li>返回消费成功：以 Java SDK 为例，返回<code>ConsumeResult.SUCCESS</code>，表示该消息处理成功，服务端按照消费结果更新消费进度。</li>
<li>返回消费失败：以 Java SDK 为例，返回<code>ConsumeResult.FAILURE</code>，表示该消息处理失败，需要根据消费重试逻辑判断是否进行重试消费。</li>
<li>出现非预期失败：例如抛异常等行为，该结果按照消费失败处理，需要根据消费重试逻辑判断是否进行重试消费。</li>
</ul>
<p>具体实现可以参见这篇文章<a href="http://devedmc.com/archives/1691854198138">RocketMQ 对 pull 和 push 的实现</a>。</p>
<p>使用 PushConsumer 消费者消费时，不允许使用以下方式处理消息，否则 RocketMQ 无法保证消息的可靠性。</p>
<ul>
<li>错误方式一：消息还未处理完成，就提前返回消费成功结果。此时如果消息消费失败，RocketMQ 服务端是无法感知的，因此不会进行消费重试。</li>
<li>错误方式二：在消费监听器内将消息再次分发到自定义的其他线程，消费监听器提前返回消费结果。此时如果消息消费失败，RocketMQ 服务端同样无法感知，因此也不会进行消费重试。</li>
<li>PushConsumer 严格限制了消息同步处理及每条消息的处理超时时间，适用于以下场景：<ul>
<li>消息处理时间可预估：如果不确定消息处理耗时，经常有预期之外的长时间耗时的消息，PushConsumer 的可靠性保证会频繁触发消息重试机制造成大量重复消息。</li>
<li>无异步化、高级定制场景：PushConsumer 限制了消费逻辑的线程模型，由客户端 SDK 内部按最大吞吐量触发消息处理。该模型开发逻辑简单，但是不允许使用异步化和自定义处理流程。</li>
</ul>
</li>
</ul>
<h3 id="SimpleConsumer"><a href="#SimpleConsumer" class="headerlink" title="SimpleConsumer"></a>SimpleConsumer</h3><p>SimpleConsumer 是一种接口原子型的消费者类型，消息的获取、消费状态提交以及消费重试都是通过消费者业务逻辑主动发起调用完成。</p>
<p>一个来自官网的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消费示例：使用 SimpleConsumer 消费普通消息，主动获取消息处理并提交。</span></span><br><span class="line"><span class="type">ClientServiceProvider</span> <span class="variable">provider</span> <span class="operator">=</span> ClientServiceProvider.loadService();</span><br><span class="line"><span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> <span class="string">&quot;YourTopic&quot;</span>;</span><br><span class="line"><span class="type">FilterExpression</span> <span class="variable">filterExpression</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterExpression</span>(<span class="string">&quot;YourFilterTag&quot;</span>, FilterExpressionType.TAG);</span><br><span class="line"><span class="type">SimpleConsumer</span> <span class="variable">simpleConsumer</span> <span class="operator">=</span> provider.newSimpleConsumerBuilder()</span><br><span class="line">        <span class="comment">// 设置消费者分组。</span></span><br><span class="line">        .setConsumerGroup(<span class="string">&quot;YourConsumerGroup&quot;</span>)</span><br><span class="line">        <span class="comment">// 设置接入点。</span></span><br><span class="line">        .setClientConfiguration(ClientConfiguration.newBuilder().setEndpoints(<span class="string">&quot;YourEndpoint&quot;</span>).build())</span><br><span class="line">        <span class="comment">// 设置预绑定的订阅关系。</span></span><br><span class="line">        .setSubscriptionExpressions(Collections.singletonMap(topic, filterExpression))</span><br><span class="line">        <span class="comment">// 设置从服务端接受消息的最大等待时间</span></span><br><span class="line">        .setAwaitDuration(Duration.ofSeconds(<span class="number">1</span>))</span><br><span class="line">        .build();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// SimpleConsumer 需要主动获取消息，并处理。</span></span><br><span class="line">    List&lt;MessageView&gt; messageViewList = simpleConsumer.receive(<span class="number">10</span>, Duration.ofSeconds(<span class="number">30</span>));</span><br><span class="line">    messageViewList.forEach(messageView -&gt; &#123;</span><br><span class="line">        System.out.println(messageView);</span><br><span class="line">        <span class="comment">// 消费处理完成后，需要主动调用 ACK 提交消费结果。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            simpleConsumer.ack(messageView);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClientException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;Failed to ack message, messageId=&#123;&#125;&quot;</span>, messageView.getMessageId(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClientException e) &#123;</span><br><span class="line">    <span class="comment">// 如果遇到系统流控等原因造成拉取失败，需要重新发起获取消息请求。</span></span><br><span class="line">    logger.error(<span class="string">&quot;Failed to receive message&quot;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SimpleConsumer 适用于以下场景：</p>
<ul>
<li>消息处理时长不可控：如果消息处理时长无法预估，经常有长时间耗时的消息处理情况。建议使用 SimpleConsumer 消费类型，可以在消费时自定义消息的预估处理时长，若实际业务中预估的消息处理时长不符合预期，也可以通过接口提前修改。</li>
<li>需要异步化、批量消费等高级定制场景：SimpleConsumer 在 SDK 内部没有复杂的线程封装，完全由业务逻辑自由定制，可以实现异步分发、批量消费等高级定制场景。</li>
<li>需要自定义消费速率：SimpleConsumer 是由业务逻辑主动调用接口获取消息，因此可以自由调整获取消息的频率，自定义控制消费速率。</li>
</ul>
<h3 id="PullConsumer"><a href="#PullConsumer" class="headerlink" title="PullConsumer"></a>PullConsumer</h3><p>施工中。。。</p>
<h2 id="消费者分组和生产者分组"><a href="#消费者分组和生产者分组" class="headerlink" title="消费者分组和生产者分组"></a>消费者分组和生产者分组</h2><h3 id="生产者分组"><a href="#生产者分组" class="headerlink" title="生产者分组"></a>生产者分组</h3><p>RocketMQ 服务端 5.x 版本开始，<strong>生产者是匿名的</strong>，无需管理生产者分组（ProducerGroup）；对于历史版本服务端 3.x 和 4.x 版本，已经使用的生产者分组可以废弃无需再设置，且不会对当前业务产生影响。</p>
<h3 id="消费者分组"><a href="#消费者分组" class="headerlink" title="消费者分组"></a>消费者分组</h3><p>消费者分组是多个消费行为一致的消费者的负载均衡分组。消费者分组不是具体实体而是一个逻辑资源。通过消费者分组实现消费性能的水平扩展以及高可用容灾。</p>
<p>消费者分组中的订阅关系、投递顺序性、消费重试策略是一致的。</p>
<ul>
<li>订阅关系：Apache RocketMQ 以消费者分组的粒度管理订阅关系，实现订阅关系的管理和追溯。</li>
<li>投递顺序性：Apache RocketMQ 的服务端将消息投递给消费者消费时，支持顺序投递和并发投递，投递方式在消费者分组中统一配置。</li>
<li>消费重试策略： 消费者消费消息失败时的重试策略，包括重试次数、死信队列设置等。</li>
</ul>
<p>RocketMQ 服务端 5.x 版本：上述消费者的消费行为从关联的消费者分组中统一获取，因此，同一分组内所有消费者的消费行为必然是一致的，客户端无需关注。</p>
<p>RocketMQ 服务端 3.x&#x2F;4.x 历史版本：上述消费逻辑由消费者客户端接口定义，因此，您需要自己在消费者客户端设置时保证同一分组下的消费者的消费行为一致。(来自官方网站)</p>
<h2 id="如何解决顺序消费和重复消费？"><a href="#如何解决顺序消费和重复消费？" class="headerlink" title="如何解决顺序消费和重复消费？"></a>如何解决顺序消费和重复消费？</h2><p>其实，这些东西都是我在介绍消息队列带来的一些副作用的时候提到的，也就是说，这些问题不仅仅挂钩于 <code>RocketMQ</code> ，而是应该每个消息中间件都需要去解决的。</p>
<p>在上面我介绍 <code>RocketMQ</code> 的技术架构的时候我已经向你展示了 <strong>它是如何保证高可用的</strong> ，这里不涉及运维方面的搭建，如果你感兴趣可以自己去官网上照着例子搭建属于你自己的 <code>RocketMQ</code> 集群。</p>
<blockquote>
<p>其实 <code>Kafka</code> 的架构基本和 <code>RocketMQ</code> 类似，只是它注册中心使用了 <code>Zookeeper</code>、它的 <strong>分区</strong> 就相当于 <code>RocketMQ</code> 中的 <strong>队列</strong> 。还有一些小细节不同会在后面提到。</p>
</blockquote>
<h3 id="顺序消费"><a href="#顺序消费" class="headerlink" title="顺序消费"></a>顺序消费</h3><p>在上面的技术架构介绍中，我们已经知道了 <strong><code>RocketMQ</code> 在主题上是无序的、它只有在队列层面才是保证有序</strong> 的。</p>
<p>这又扯到两个概念——<strong>普通顺序</strong> 和 <strong>严格顺序</strong> 。</p>
<p>所谓普通顺序是指 消费者通过 <strong>同一个消费队列收到的消息是有顺序的</strong> ，不同消息队列收到的消息则可能是无顺序的。普通顺序消息在 <code>Broker</code> <strong>重启情况下不会保证消息顺序性</strong> (短暂时间) 。</p>
<p>所谓严格顺序是指 消费者收到的 <strong>所有消息</strong> 均是有顺序的。严格顺序消息 <strong>即使在异常情况下也会保证消息的顺序性</strong> 。</p>
<p>但是，严格顺序看起来虽好，实现它可会付出巨大的代价。如果你使用严格顺序模式，<code>Broker</code> 集群中只要有一台机器不可用，则整个集群都不可用。你还用啥？现在主要场景也就在 <code>binlog</code> 同步。</p>
<p>一般而言，我们的 <code>MQ</code> 都是能容忍短暂的乱序，所以推荐使用普通顺序模式。</p>
<p>那么，我们现在使用了 <strong>普通顺序模式</strong> ，我们从上面学习知道了在 <code>Producer</code> 生产消息的时候会进行轮询(取决你的负载均衡策略)来向同一主题的不同消息队列发送消息。那么如果此时我有几个消息分别是同一个订单的创建、支付、发货，在轮询的策略下这 <strong>三个消息会被发送到不同队列</strong> ，因为在不同的队列此时就无法使用 <code>RocketMQ</code> 带来的队列有序特性来保证消息有序性了。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/16ef3874585e096e.jpg"></p>
<p>那么，怎么解决呢？</p>
<p>其实很简单，我们需要处理的仅仅是将同一语义下的消息放入同一个队列(比如这里是同一个订单)，那我们就可以使用 <strong>Hash 取模法</strong> 来保证同一个订单在同一个队列中就行了。</p>
<p>RocketMQ 实现了两种队列选择算法，也可以自己实现</p>
<ul>
<li><p>轮询算法</p>
<ul>
<li>轮询算法就是向消息指定的 topic 所在队列中依次发送消息，保证消息均匀分布</li>
<li>是 RocketMQ 默认队列选择算法</li>
</ul>
</li>
<li><p>最小投递延迟算法</p>
<ul>
<li><p>每次消息投递的时候统计消息投递的延迟，选择队列时优先选择消息延时小的队列，导致消息分布不均匀,按照如下设置即可。</p>
</li>
<li><pre><code class="java">producer.setSendLatencyFaultEnable(true);
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 继承 MessageQueueSelector 实现</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    SendResult sendResult = producer.send(msg, new MessageQueueSelector() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public MessageQueue select(List&lt;MessageQueue&gt; mqs, Message msg, Object arg) &#123;</span><br><span class="line">            //从mqs中选择一个队列,可以根据msg特点选择</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, new Object());</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="特殊情况处理"><a href="#特殊情况处理" class="headerlink" title="特殊情况处理"></a>特殊情况处理</h3><h4 id="发送异常"><a href="#发送异常" class="headerlink" title="发送异常"></a>发送异常</h4><p>选择队列后会与 Broker 建立连接，通过网络请求将消息发送到 Broker 上，如果 Broker 挂了或者网络波动发送消息超时此时 RocketMQ 会进行重试。</p>
<p>重新选择其他 Broker 中的消息队列进行发送，默认重试两次，可以手动设置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">producer.setRetryTimesWhenSendFailed(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<h4 id="消息过大"><a href="#消息过大" class="headerlink" title="消息过大"></a>消息过大</h4><p>消息超过 4k 时 RocketMQ 会将消息压缩后在发送到 Broker 上，减少网络资源的占用。</p>
<h3 id="重复消费"><a href="#重复消费" class="headerlink" title="重复消费"></a>重复消费</h3><p>emmm，就两个字—— <strong>幂等</strong> 。在编程中一个<em>幂等</em> 操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。比如说，这个时候我们有一个订单的处理积分的系统，每当来一个消息的时候它就负责为创建这个订单的用户的积分加上相应的数值。可是有一次，消息队列发送给订单系统 FrancisQ 的订单信息，其要求是给 FrancisQ 的积分加上 500。但是积分系统在收到 FrancisQ 的订单信息处理完成之后返回给消息队列处理成功的信息的时候出现了网络波动(当然还有很多种情况，比如 Broker 意外重启等等)，这条回应没有发送成功。</p>
<p>那么，消息队列没收到积分系统的回应会不会尝试重发这个消息？问题就来了，我再发这个消息，万一它又给 FrancisQ 的账户加上 500 积分怎么办呢？</p>
<p>所以我们需要给我们的消费者实现 <strong>幂等</strong> ，也就是对同一个消息的处理结果，执行多少次都不变。</p>
<p>那么如何给业务实现幂等呢？这个还是需要结合具体的业务的。你可以使用 <strong>写入 <code>Redis</code></strong> 来保证，因为 <code>Redis</code> 的 <code>key</code> 和 <code>value</code> 就是天然支持幂等的。当然还有使用 <strong>数据库插入法</strong> ，基于数据库的唯一键来保证重复数据不会被插入多条。</p>
<p>不过最主要的还是需要 <strong>根据特定场景使用特定的解决方案</strong> ，你要知道你的消息消费是否是完全不可重复消费还是可以忍受重复消费的，然后再选择强校验和弱校验的方式。毕竟在 CS 领域还是很少有技术银弹的说法。</p>
<p>而在整个互联网领域，幂等不仅仅适用于消息队列的重复消费问题，这些实现幂等的方法，也同样适用于，<strong>在其他场景中来解决重复请求或者重复调用的问题</strong> 。比如将 HTTP 服务设计成幂等的，<strong>解决前端或者 APP 重复提交表单数据的问题</strong> ，也可以将一个微服务设计成幂等的，解决 <code>RPC</code> 框架自动重试导致的 <strong>重复调用问题</strong> 。</p>
<h2 id="RocketMQ-如何实现分布式事务？"><a href="#RocketMQ-如何实现分布式事务？" class="headerlink" title="RocketMQ 如何实现分布式事务？"></a>RocketMQ 如何实现分布式事务？</h2><p>如何解释分布式事务呢？事务大家都知道吧？<strong>要么都执行要么都不执行</strong> 。在同一个系统中我们可以轻松地实现事务，但是在分布式架构中，我们有很多服务是部署在不同系统之间的，而不同服务之间又需要进行调用。比如此时我下订单然后增加积分，如果保证不了分布式事务的话，就会出现 A 系统下了订单，但是 B 系统增加积分失败或者 A 系统没有下订单，B 系统却增加了积分。前者对用户不友好，后者对运营商不利，这是我们都不愿意见到的。</p>
<p>那么，如何去解决这个问题呢？</p>
<p>如今比较常见的分布式事务实现有 2PC、TCC 和事务消息(half 半消息机制)。每一种实现都有其特定的使用场景，但是也有各自的问题，<strong>都不是完美的解决方案</strong>。</p>
<p>在 <code>RocketMQ</code> 中使用的是 <strong>事务消息加上事务反查机制</strong> 来解决分布式事务问题的。我画了张图，大家可以对照着图进行理解。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/16ef38798d7a987f.png"></p>
<p>在第一步发送的 half 消息 ，它的意思是 <strong>在事务提交之前，对于消费者来说，这个消息是不可见的</strong> 。</p>
<blockquote>
<p>那么，如何做到写入消息但是对用户不可见呢？RocketMQ 事务消息的做法是：如果消息是 half 消息，将备份原消息的主题与消息消费队列，然后 <strong>改变主题</strong> 为 RMQ_SYS_TRANS_HALF_TOPIC。由于消费组未订阅该主题，故消费端无法消费 half 类型的消息，<strong>然后 RocketMQ 会开启一个定时任务，从 Topic 为 RMQ_SYS_TRANS_HALF_TOPIC 中拉取消息进行消费</strong>，根据生产者组获取一个服务提供者发送回查事务状态请求，根据事务状态来决定是提交或回滚消息。</p>
</blockquote>
<p>你可以试想一下，如果没有从第 5 步开始的 <strong>事务反查机制</strong> ，如果出现网路波动第 4 步没有发送成功，这样就会产生 MQ 不知道是不是需要给消费者消费的问题，他就像一个无头苍蝇一样。在 <code>RocketMQ</code> 中就是使用的上述的事务反查来解决的，而在 <code>Kafka</code> 中通常是直接抛出一个异常让用户来自行解决。</p>
<p>你还需要注意的是，在 <code>MQ Server</code> 指向系统 B 的操作已经和系统 A 不相关了，也就是说在消息队列中的分布式事务是——<strong>本地事务和存储消息到消息队列才是同一个事务</strong>。这样也就产生了事务的<strong>最终一致性</strong>，因为整个过程是异步的，<strong>每个系统只要保证它自己那一部分的事务就行了</strong>。</p>
<p>实践中会遇到的问题：事务消息需要一个事务监听器来监听本地事务是否成功，并且事务监听器接口只允许被实现一次。那就意味着需要把各种事务消息的本地事务都写在一个接口方法里面，必将会产生大量的耦合和类型判断。采用函数 Function 接口来包装整个业务过程，作为一个参数传递到监听器的接口方法中。再调用 Function 的 apply() 方法来执行业务，事务也会在 apply() 方法中执行。让监听器与业务之间实现解耦，使之具备了真实生产环境中的可行性。</p>
<p>1.模拟一个添加用户浏览记录的需求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/add&quot;)</span></span><br><span class="line"><span class="meta">@ApiOperation(&quot;添加用户浏览记录&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;TransactionSendResult&gt; <span class="title function_">add</span><span class="params">(Long userId, Long forecastLogId)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 函数式编程:浏览记录入库</span></span><br><span class="line">        Function&lt;String, Boolean&gt; function = transactionId -&gt; viewHistoryHandler.addViewHistory(transactionId, userId, forecastLogId);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Long&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        hashMap.put(<span class="string">&quot;userId&quot;</span>, userId);</span><br><span class="line">        hashMap.put(<span class="string">&quot;forecastLogId&quot;</span>, forecastLogId);</span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonString</span> <span class="operator">=</span> JSON.toJSONString(hashMap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送事务消息;将本地的事务操作,用函数Function接口接收,作为一个参数传入到方法中</span></span><br><span class="line">        <span class="type">TransactionSendResult</span> <span class="variable">transactionSendResult</span> <span class="operator">=</span> mqProducerService.sendTransactionMessage(jsonString, MQDestination.TAG_ADD_VIEW_HISTORY, function);</span><br><span class="line">        <span class="keyword">return</span> Result.success(transactionSendResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.发送事务消息的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送事务消息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> msgBody</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tag</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> function</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> TransactionSendResult <span class="title function_">sendTransactionMessage</span><span class="params">(String msgBody, String tag, Function&lt;String, Boolean&gt; function)</span> &#123;</span><br><span class="line">    <span class="comment">// 构建消息体</span></span><br><span class="line">    Message&lt;String&gt; message = buildMessage(msgBody);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建消息投递信息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">destination</span> <span class="operator">=</span> buildDestination(tag);</span><br><span class="line"></span><br><span class="line">    <span class="type">TransactionSendResult</span> <span class="variable">result</span> <span class="operator">=</span> rocketMQTemplate.sendMessageInTransaction(destination, message, function);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.生产者消息监听器,只允许一个类去实现该监听器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RocketMQTransactionListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionMsgListener</span> <span class="keyword">implements</span> <span class="title class_">RocketMQLocalTransactionListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisService redisService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行本地事务（在发送消息成功时执行）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> commit or rollback or unknown</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> RocketMQLocalTransactionState <span class="title function_">executeLocalTransaction</span><span class="params">(Message message, Object o)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、获取事务ID</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">transactionId</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            transactionId = message.getHeaders().get(<span class="string">&quot;rocketmq_TRANSACTION_ID&quot;</span>).toString();</span><br><span class="line">            <span class="comment">// 2、判断传入函数对象是否为空，如果为空代表没有要执行的业务直接抛弃消息</span></span><br><span class="line">            <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//返回ROLLBACK状态的消息会被丢弃</span></span><br><span class="line">                log.info(<span class="string">&quot;事务消息回滚，没有需要处理的业务 transactionId=&#123;&#125;&quot;</span>, transactionId);</span><br><span class="line">                <span class="keyword">return</span> RocketMQLocalTransactionState.ROLLBACK;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将Object o转换成Function对象</span></span><br><span class="line">            Function&lt;String, Boolean&gt; function = (Function&lt;String, Boolean&gt;) o;</span><br><span class="line">            <span class="comment">// 执行业务 事务也会在function.apply中执行</span></span><br><span class="line">            <span class="type">Boolean</span> <span class="variable">apply</span> <span class="operator">=</span> function.apply(transactionId);</span><br><span class="line">            <span class="keyword">if</span> (apply) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;事务提交，消息正常处理 transactionId=&#123;&#125;&quot;</span>, transactionId);</span><br><span class="line">                <span class="comment">//返回COMMIT状态的消息会立即被消费者消费到</span></span><br><span class="line">                <span class="keyword">return</span> RocketMQLocalTransactionState.COMMIT;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;出现异常 返回ROLLBACK transactionId=&#123;&#125;&quot;</span>, transactionId);</span><br><span class="line">            <span class="keyword">return</span> RocketMQLocalTransactionState.ROLLBACK;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> RocketMQLocalTransactionState.ROLLBACK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 事务回查机制，检查本地事务的状态</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> RocketMQLocalTransactionState <span class="title function_">checkLocalTransaction</span><span class="params">(Message message)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">transactionId</span> <span class="operator">=</span> message.getHeaders().get(<span class="string">&quot;rocketmq_TRANSACTION_ID&quot;</span>).toString();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查redis</span></span><br><span class="line">        <span class="type">MqTransaction</span> <span class="variable">mqTransaction</span> <span class="operator">=</span> redisService.getCacheObject(<span class="string">&quot;mqTransaction:&quot;</span> + transactionId);</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(mqTransaction)) &#123;</span><br><span class="line">            <span class="keyword">return</span> RocketMQLocalTransactionState.ROLLBACK;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> RocketMQLocalTransactionState.COMMIT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.模拟的业务场景,这里的方法必须提取出来,放在别的类里面.如果调用方与被调用方在同一个类中,会发生事务失效的问题.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ViewHistoryHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IViewHistoryService viewHistoryService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IMqTransactionService mqTransactionService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisService redisService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 浏览记录入库</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> transactionId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> forecastLogId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">addViewHistory</span><span class="params">(String transactionId, Long userId, Long forecastLogId)</span> &#123;</span><br><span class="line">        <span class="comment">// 构建浏览记录</span></span><br><span class="line">        <span class="type">ViewHistory</span> <span class="variable">viewHistory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ViewHistory</span>();</span><br><span class="line">        viewHistory.setUserId(userId);</span><br><span class="line">        viewHistory.setForecastLogId(forecastLogId);</span><br><span class="line">        viewHistory.setCreateTime(LocalDateTime.now());</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">save</span> <span class="operator">=</span> viewHistoryService.save(viewHistory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 本地事务信息</span></span><br><span class="line">        <span class="type">MqTransaction</span> <span class="variable">mqTransaction</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MqTransaction</span>();</span><br><span class="line">        mqTransaction.setTransactionId(transactionId);</span><br><span class="line">        mqTransaction.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        mqTransaction.setStatus(MqTransaction.StatusEnum.VALID.getStatus());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.可以把事务信息存数据库</span></span><br><span class="line">        mqTransactionService.save(mqTransaction);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.也可以选择存redis,4个小时有效期,&#x27;4个小时&#x27;是RocketMQ内置的最大回查超时时长,过期未确认将强制回滚</span></span><br><span class="line">        redisService.setCacheObject(<span class="string">&quot;mqTransaction:&quot;</span> + transactionId, mqTransaction, <span class="number">4L</span>, TimeUnit.HOURS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 放开注释,模拟异常,事务回滚</span></span><br><span class="line">        <span class="comment">// int i = 10 / 0;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> save;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.消费消息,以及幂等处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RocketMQMessageListener(topic = MQDestination.TOPIC, selectorExpression = MQDestination.TAG_ADD_VIEW_HISTORY, consumerGroup = MQDestination.TAG_ADD_VIEW_HISTORY)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerAddViewHistory</span> <span class="keyword">implements</span> <span class="title class_">RocketMQListener</span>&lt;Message&gt; &#123;</span><br><span class="line">    <span class="comment">// 监听到消息就会执行此方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="comment">// 幂等校验</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">transactionId</span> <span class="operator">=</span> message.getTransactionId();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查redis</span></span><br><span class="line">        <span class="type">MqTransaction</span> <span class="variable">mqTransaction</span> <span class="operator">=</span> redisService.getCacheObject(<span class="string">&quot;mqTransaction:&quot;</span> + transactionId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不存在事务记录</span></span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(mqTransaction)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 已消费</span></span><br><span class="line">        <span class="keyword">if</span> (Objects.equals(mqTransaction.getStatus(), MqTransaction.StatusEnum.CONSUMED.getStatus())) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">        Map&lt;String, Long&gt; map = JSON.parseObject(msg, <span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;HashMap&lt;String, Long&gt;&gt;() &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> map.get(<span class="string">&quot;userId&quot;</span>);</span><br><span class="line">        <span class="type">Long</span> <span class="variable">forecastLogId</span> <span class="operator">=</span> map.get(<span class="string">&quot;forecastLogId&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下游的业务处理</span></span><br><span class="line">        <span class="comment">// TODO 记录用户喜好,更新用户画像</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 更新&#x27;证券预测文章&#x27;的浏览量,重新计算文章的曝光排序</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新状态为已消费</span></span><br><span class="line">        mqTransaction.setUpdateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        mqTransaction.setStatus(MqTransaction.StatusEnum.CONSUMED.getStatus());</span><br><span class="line">        redisService.setCacheObject(<span class="string">&quot;mqTransaction:&quot;</span> + transactionId, mqTransaction, <span class="number">4L</span>, TimeUnit.HOURS);</span><br><span class="line">        log.info(<span class="string">&quot;监听到消息：msg=&#123;&#125;&quot;</span>, JSON.toJSONString(map));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="如何解决消息堆积问题？"><a href="#如何解决消息堆积问题？" class="headerlink" title="如何解决消息堆积问题？"></a>如何解决消息堆积问题？</h2><p>在上面我们提到了消息队列一个很重要的功能——<strong>削峰</strong> 。那么如果这个峰值太大了导致消息堆积在队列中怎么办呢？</p>
<p>其实这个问题可以将它广义化，因为产生消息堆积的根源其实就只有两个——生产者生产太快或者消费者消费太慢。</p>
<p>我们可以从多个角度去思考解决这个问题，当流量到峰值的时候是因为生产者生产太快，我们可以使用一些 <strong>限流降级</strong> 的方法，当然你也可以增加多个消费者实例去水平扩展增加消费能力来匹配生产的激增。如果消费者消费过慢的话，我们可以先检查 <strong>是否是消费者出现了大量的消费错误</strong> ，或者打印一下日志查看是否是哪一个线程卡死，出现了锁资源不释放等等的问题。</p>
<blockquote>
<p>当然，最快速解决消息堆积问题的方法还是增加消费者实例，不过 <strong>同时你还需要增加每个主题的队列数量</strong> 。</p>
<p>别忘了在 <code>RocketMQ</code> 中，<strong>一个队列只会被一个消费者消费</strong> ，如果你仅仅是增加消费者实例就会出现我一开始给你画架构图的那种情况。</p>
</blockquote>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/16ef387d939ab66d.jpg"></p>
<h2 id="什么是回溯消费？"><a href="#什么是回溯消费？" class="headerlink" title="什么是回溯消费？"></a>什么是回溯消费？</h2><p>回溯消费是指 <code>Consumer</code> 已经消费成功的消息，由于业务上需求需要重新消费，在<code>RocketMQ</code> 中， <code>Broker</code> 在向<code>Consumer</code> 投递成功消息后，<strong>消息仍然需要保留</strong> 。并且重新消费一般是按照时间维度，例如由于 <code>Consumer</code> 系统故障，恢复后需要重新消费 1 小时前的数据，那么 <code>Broker</code> 要提供一种机制，可以按照时间维度来回退消费进度。<code>RocketMQ</code> 支持按照时间回溯消费，时间维度精确到毫秒。</p>
<p>这是官方文档的解释，我直接照搬过来就当科普了 😁😁😁。</p>
<h2 id="RocketMQ-如何保证高性能读写"><a href="#RocketMQ-如何保证高性能读写" class="headerlink" title="RocketMQ 如何保证高性能读写"></a>RocketMQ 如何保证高性能读写</h2><h3 id="传统-IO-方式"><a href="#传统-IO-方式" class="headerlink" title="传统 IO 方式"></a>传统 IO 方式</h3><p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/31699457085_.pic.jpg"></p>
<p>传统的 IO 读写其实就是 read + write 的操作，整个过程会分为如下几步</p>
<ul>
<li>用户调用 read()方法，开始读取数据，此时发生一次上下文从用户态到内核态的切换，也就是图示的切换 1</li>
<li>将磁盘数据通过 DMA 拷贝到内核缓存区</li>
<li>将内核缓存区的数据拷贝到用户缓冲区，这样用户，也就是我们写的代码就能拿到文件的数据</li>
<li>read()方法返回，此时就会从内核态切换到用户态，也就是图示的切换 2</li>
<li>当我们拿到数据之后，就可以调用 write()方法，此时上下文会从用户态切换到内核态，即图示切换 3</li>
<li>CPU 将用户缓冲区的数据拷贝到 Socket 缓冲区</li>
<li>将 Socket 缓冲区数据拷贝至网卡</li>
<li>write()方法返回，上下文重新从内核态切换到用户态，即图示切换 4</li>
</ul>
<p>整个过程发生了 4 次上下文切换和 4 次数据的拷贝，这在高并发场景下肯定会严重影响读写性能故引入了零拷贝技术</p>
<h3 id="零拷贝技术"><a href="#零拷贝技术" class="headerlink" title="零拷贝技术"></a>零拷贝技术</h3><h4 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h4><p>mmap（memory map）是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。</p>
<p>简单地说就是内核缓冲区和应用缓冲区共享，从而减少了从读缓冲区到用户缓冲区的一次 CPU 拷贝。基于此上述架构图可变为：</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/41699457086_.pic.jpg"></p>
<p>基于 mmap IO 读写其实就变成 mmap + write 的操作，也就是用 mmap 替代传统 IO 中的 read 操作。</p>
<p>当用户发起 mmap 调用的时候会发生上下文切换 1，进行内存映射，然后数据被拷贝到内核缓冲区，mmap 返回，发生上下文切换 2；随后用户调用 write，发生上下文切换 3，将内核缓冲区的数据拷贝到 Socket 缓冲区，write 返回，发生上下文切换 4。</p>
<p>发生 4 次上下文切换和 3 次 IO 拷贝操作，在 Java 中的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>).getChannel();</span><br><span class="line"><span class="type">MappedByteBuffer</span> <span class="variable">mappedByteBuffer</span> <span class="operator">=</span> fileChannel.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, fileChannel.size());</span><br></pre></td></tr></table></figure>

<h4 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile"></a>sendfile</h4><p>sendfile()跟 mmap()一样，也会减少一次 CPU 拷贝，但是它同时也会减少两次上下文切换。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/51699457087_.pic.jpg"></p>
<p>如图，用户在发起 sendfile()调用时会发生切换 1，之后数据通过 DMA 拷贝到内核缓冲区，之后再将内核缓冲区的数据 CPU 拷贝到 Socket 缓冲区，最后拷贝到网卡，sendfile()返回，发生切换 2。发生了 3 次拷贝和两次切换。Java 也提供了相应 api：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> FileChannel.open(Paths.get(<span class="string">&quot;./test.txt&quot;</span>), StandardOpenOption.WRITE, StandardOpenOption.CREATE);</span><br><span class="line"><span class="comment">//调用transferTo方法向目标数据传输</span></span><br><span class="line">channel.transferTo(position, len, target);</span><br></pre></td></tr></table></figure>

<p>在如上代码中，并没有文件的读写操作，而是直接将文件的数据传输到 target 目标缓冲区，也就是说，sendfile 是无法知道文件的具体的数据的；但是 mmap 不一样，他是可以修改内核缓冲区的数据的。假设如果需要对文件的内容进行修改之后再传输，只有 mmap 可以满足。</p>
<p>通过上面的一些介绍，结论是基于零拷贝技术，可以减少 CPU 的拷贝次数和上下文切换次数，从而可以实现文件高效的读写操作。</p>
<p>RocketMQ 内部主要是使用基于 mmap 实现的零拷贝(其实就是调用上述提到的 api)，用来读写文件，这也是 RocketMQ 为什么快的一个很重要原因。</p>
<h2 id="RocketMQ-的刷盘机制"><a href="#RocketMQ-的刷盘机制" class="headerlink" title="RocketMQ 的刷盘机制"></a>RocketMQ 的刷盘机制</h2><p>上面我讲了那么多的 <code>RocketMQ</code> 的架构和设计原理，你有没有好奇</p>
<p>在 <code>Topic</code> 中的 <strong>队列是以什么样的形式存在的？</strong></p>
<p><strong>队列中的消息又是如何进行存储持久化的呢？</strong></p>
<p>我在上文中提到的 <strong>同步刷盘</strong> 和 <strong>异步刷盘</strong> 又是什么呢？它们会给持久化带来什么样的影响呢？</p>
<p>下面我将给你们一一解释。</p>
<h3 id="同步刷盘和异步刷盘"><a href="#同步刷盘和异步刷盘" class="headerlink" title="同步刷盘和异步刷盘"></a>同步刷盘和异步刷盘</h3><p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/16ef387fba311cda-20230814005009889.jpg"></p>
<p>如上图所示，在同步刷盘中需要等待一个刷盘成功的 <code>ACK</code> ，同步刷盘对 <code>MQ</code> 消息可靠性来说是一种不错的保障，但是 <strong>性能上会有较大影响</strong> ，一般地适用于金融等特定业务场景。</p>
<p>而异步刷盘往往是开启一个线程去异步地执行刷盘操作。消息刷盘采用后台异步线程提交的方式进行， <strong>降低了读写延迟</strong> ，提高了 <code>MQ</code> 的性能和吞吐量，一般适用于如发验证码等对于消息保证要求不太高的业务场景。</p>
<p>一般地，<strong>异步刷盘只有在 <code>Broker</code> 意外宕机的时候会丢失部分数据</strong>，你可以设置 <code>Broker</code> 的参数 <code>FlushDiskType</code> 来调整你的刷盘策略(ASYNC_FLUSH 或者 SYNC_FLUSH)。</p>
<h3 id="同步复制和异步复制"><a href="#同步复制和异步复制" class="headerlink" title="同步复制和异步复制"></a>同步复制和异步复制</h3><p>上面的同步刷盘和异步刷盘是在单个结点层面的，而同步复制和异步复制主要是指的 <code>Borker</code> 主从模式下，主节点返回消息给客户端的时候是否需要同步从节点。</p>
<ul>
<li>同步复制：也叫 “同步双写”，也就是说，<strong>只有消息同步双写到主从节点上时才返回写入成功</strong> 。</li>
<li>异步复制：<strong>消息写入主节点之后就直接返回写入成功</strong> 。</li>
</ul>
<p>然而，很多事情是没有完美的方案的，就比如我们进行消息写入的节点越多就更能保证消息的可靠性，但是随之的性能也会下降，所以需要程序员根据特定业务场景去选择适应的主从复制方案。</p>
<p>那么，<strong>异步复制会不会也像异步刷盘那样影响消息的可靠性呢？</strong></p>
<p>答案是不会的，因为两者就是不同的概念，对于消息可靠性是通过不同的刷盘策略保证的，而像异步同步复制策略仅仅是影响到了 <strong>可用性</strong> 。为什么呢？其主要原因<strong>是 <code>RocketMQ</code> 是不支持自动主从切换的，当主节点挂掉之后，生产者就不能再给这个主节点生产消息了</strong>。</p>
<p>比如这个时候采用异步复制的方式，在主节点还未发送完需要同步的消息的时候主节点挂掉了，这个时候从节点就少了一部分消息。但是此时生产者无法再给主节点生产消息了，<strong>消费者可以自动切换到从节点进行消费</strong>(仅仅是消费)，所以在主节点挂掉的时间只会产生主从结点短暂的消息不一致的情况，降低了可用性，而当主节点重启之后，从节点那部分未来得及复制的消息还会继续复制。</p>
<p>在单主从架构中，如果一个主节点挂掉了，那么也就意味着整个系统不能再生产了。那么这个可用性的问题能否解决呢？<strong>一个主从不行那就多个主从的呗</strong>，别忘了在我们最初的架构图中，每个 <code>Topic</code> 是分布在不同 <code>Broker</code> 中的。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/16ef38687488a5asadasfg4.jpg"></p>
<p>但是这种复制方式同样也会带来一个问题，那就是无法保证 <strong>严格顺序</strong> 。在上文中我们提到了如何保证的消息顺序性是通过将一个语义的消息发送在同一个队列中，使用 <code>Topic</code> 下的队列来保证顺序性的。如果此时我们主节点 A 负责的是订单 A 的一系列语义消息，然后它挂了，这样其他节点是无法代替主节点 A 的，如果我们任意节点都可以存入任何消息，那就没有顺序性可言了。</p>
<p>而在 <code>RocketMQ</code> 中采用了 <code>Dledger</code> 解决这个问题。他要求在写入消息的时候，要求<strong>至少消息复制到半数以上的节点之后</strong>，才给客⼾端返回写⼊成功，并且它是⽀持通过选举来动态切换主节点的。这里我就不展开说明了，读者可以自己去了解。</p>
<blockquote>
<p>也不是说 <code>Dledger</code> 是个完美的方案，至少在 <code>Dledger</code> 选举过程中是无法提供服务的，而且他必须要使用三个节点或以上，如果多数节点同时挂掉他也是无法保证可用性的，而且要求消息复制半数以上节点的效率和直接异步复制还是有一定的差距的。</p>
</blockquote>
<h3 id="存储机制"><a href="#存储机制" class="headerlink" title="存储机制"></a>存储机制</h3><p>还记得上面我们一开始的三个问题吗？到这里第三个问题已经解决了。</p>
<p>但是，在 <code>Topic</code> 中的 <strong>队列是以什么样的形式存在的？队列中的消息又是如何进行存储持久化的呢？</strong> 还未解决，其实这里涉及到了 <code>RocketMQ</code> 是如何设计它的存储结构了。我首先想大家介绍 <code>RocketMQ</code> 消息存储架构中的三大角色——<code>CommitLog</code>、<code>ConsumeQueue</code> 和 <code>IndexFile</code> 。</p>
<ul>
<li><code>CommitLog</code>：<strong>消息主体以及元数据的存储主体</strong>，存储 <code>Producer</code> 端写入的消息主体内容,消息内容不是定长的。单个文件大小默认 1G ，文件名长度为 20 位，左边补零，剩余为起始偏移量，比如 00000000000000000000 代表了第一个文件，起始偏移量为 0，文件大小为 1G&#x3D;1073741824；当第一个文件写满了，第二个文件为 00000000001073741824，起始偏移量为 1073741824，以此类推。消息主要是<strong>顺序写入日志文件</strong>，当文件满了，写入下一个文件。</li>
<li><code>ConsumeQueue</code>：消息消费队列，<strong>引入的目的主要是提高消息消费的性能</strong>(我们再前面也讲了)，由于<code>RocketMQ</code> 是基于主题 <code>Topic</code> 的订阅模式，消息消费是针对主题进行的，如果要遍历 <code>commitlog</code> 文件中根据 <code>Topic</code> 检索消息是非常低效的。<code>Consumer</code> 即可根据 <code>ConsumeQueue</code> 来查找待消费的消息。其中，<code>ConsumeQueue</code>（逻辑消费队列）<strong>作为消费消息的索引</strong>，保存了指定 <code>Topic</code> 下的队列消息在 <code>CommitLog</code> 中的<strong>起始物理偏移量 <code>offset</code> <strong>，消息大小 <code>size</code> 和消息 <code>Tag</code> 的 <code>HashCode</code> 值。</strong><code>consumequeue</code> 文件可以看成是基于 <code>topic</code> 的 <code>commitlog</code> 索引文件</strong>，故 <code>consumequeue</code> 文件夹的组织方式如下：topic&#x2F;queue&#x2F;file 三层组织结构，具体存储路径为：$HOME&#x2F;store&#x2F;consumequeue&#x2F;{topic}&#x2F;{queueId}&#x2F;{fileName}。同样 <code>consumequeue</code> 文件采取定长设计，每一个条目共 20 个字节，分别为 8 字节的 <code>commitlog</code> 物理偏移量、4 字节的消息长度、8 字节 tag <code>hashcode</code>，单个文件由 30W 个条目组成，可以像数组一样随机访问每一个条目，每个 <code>ConsumeQueue</code>文件大小约 5.72M；</li>
<li><code>IndexFile</code>：<code>IndexFile</code>（索引文件）提供了一种可以通过 key 或时间区间来查询消息的方法。这里只做科普不做详细介绍。</li>
</ul>
<p>总结来说，整个消息存储的结构，最主要的就是 <code>CommitLoq</code> 和 <code>ConsumeQueue</code> 。而 <code>ConsumeQueue</code> 你可以大概理解为 <code>Topic</code> 中的队列。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/16ef3884c02acc72.png"></p>
<p><code>RocketMQ</code> 采用的是 <strong>混合型的存储结构</strong> ，即为 <code>Broker</code> 单个实例下所有的队列共用一个日志数据文件来存储消息。有意思的是在同样高并发的 <code>Kafka</code> 中会为每个 <code>Topic</code> 分配一个存储文件。这就有点类似于我们有一大堆书需要装上书架，<code>RocketMQ</code> 是不分书的种类直接成批的塞上去的，而 <code>Kafka</code> 是将书本放入指定的分类区域的。</p>
<p>而 <code>RocketMQ</code> 为什么要这么做呢？原因是 <strong>提高数据的写入效率</strong> ，不分 <code>Topic</code> 意味着我们有更大的几率获取 <strong>成批</strong> 的消息进行数据写入，但也会带来一个麻烦就是读取消息的时候需要遍历整个大文件，这是非常耗时的。</p>
<p>所以，在 <code>RocketMQ</code> 中又使用了 <code>ConsumeQueue</code> 作为每个队列的索引文件来 <strong>提升读取消息的效率</strong>。我们可以直接根据队列的消息序号，计算出索引的全局位置（索引序号*索引固定⻓度 20），然后直接读取这条索引，再根据索引中记录的消息的全局位置，找到消息。</p>
<p>讲到这里，你可能对 <code>RocketMQ</code> 的存储架构还有些模糊，没事，我们结合着图来理解一下。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/16ef388763c25c62.jpg"></p>
<p>emmm，是不是有一点复杂 🤣，看英文图片和英文文档的时候就不要怂，硬着头皮往下看就行。</p>
<blockquote>
<p>如果上面没看懂的读者一定要认真看下面的流程分析！</p>
</blockquote>
<p>首先，在最上面的那一块就是我刚刚讲的你现在可以直接 **把 <code>ConsumerQueue</code> 理解为 <code>Queue</code>**。</p>
<p>在图中最左边说明了红色方块代表被写入的消息，虚线方块代表等待被写入的。左边的生产者发送消息会指定 <code>Topic</code>、<code>QueueId</code> 和具体消息内容，而在 <code>Broker</code> 中管你是哪门子消息，他直接 <strong>全部顺序存储到了 CommitLog</strong>。而根据生产者指定的 <code>Topic</code> 和 <code>QueueId</code> 将这条消息本身在 <code>CommitLog</code> 的偏移(offset)，消息本身大小，和 tag 的 hash 值存入对应的 <code>ConsumeQueue</code> 索引文件中。而在每个队列中都保存了 <code>ConsumeOffset</code> 即每个消费者组的消费位置(我在架构那里提到了，忘了的同学可以回去看一下)，而消费者拉取消息进行消费的时候只需要根据 <code>ConsumeOffset</code> 获取下一个未被消费的消息就行了。</p>
<p>上述就是我对于整个消息存储架构的大概理解(这里不涉及到一些细节讨论，比如稀疏索引等等问题)，希望对你有帮助。</p>
<p>因为有一个知识点因为写嗨了忘讲了，想想在哪里加也不好，所以我留给大家去思考 🤔🤔 一下吧。</p>
<p>为什么 <code>CommitLog</code> 文件要设计成固定大小的长度呢？提醒：<strong>内存映射机制</strong>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总算把这篇博客写完了。我讲的你们还记得吗 😅？</p>
<p>这篇文章中我主要想大家介绍了</p>
<ol>
<li>消息队列出现的原因</li>
<li>消息队列的作用(异步，解耦，削峰)</li>
<li>消息队列带来的一系列问题(消息堆积、重复消费、顺序消费、分布式事务等等)</li>
<li>消息队列的两种消息模型——队列和主题模式</li>
<li>分析了 <code>RocketMQ</code> 的技术架构(<code>NameServer</code>、<code>Broker</code>、<code>Producer</code>、<code>Consumer</code>)</li>
<li>结合 <code>RocketMQ</code> 回答了消息队列副作用的解决方案</li>
<li>介绍了 <code>RocketMQ</code> 的存储机制和刷盘策略。</li>
</ol>
<p>等等。。。</p>
<!-- @include: @article-footer.snippet.md -->

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2024/09/25/sso-intro/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/09/25/sso-intro/" itemprop="url">SSO 单点登录详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-09-25T21:36:02+08:00">
                2024-09-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/WEB/" itemprop="url" rel="index">
                    <span itemprop="name">WEB</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2024/09/25/sso-intro/" class="leancloud_visitors" data-flag-title="SSO 单点登录详解">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.2k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  4 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本文授权转载自：<a href="https://ken.io/note/sso-design-implement">https://ken.io/note/sso-design-implement</a> 作者：ken.io</p>
</blockquote>
<h2 id="SSO-介绍"><a href="#SSO-介绍" class="headerlink" title="SSO 介绍"></a>SSO 介绍</h2><h3 id="什么是-SSO？"><a href="#什么是-SSO？" class="headerlink" title="什么是 SSO？"></a>什么是 SSO？</h3><p>SSO 英文全称 Single Sign On，单点登录。SSO 是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。</p>
<p>例如你登录网易账号中心（<a href="https://reg.163.com/">https://reg.163.com/</a> ）之后访问以下站点都是登录状态。</p>
<ul>
<li>网易直播 <a href="https://v.163.com/">https://v.163.com</a></li>
<li>网易博客 <a href="https://blog.163.com/">https://blog.163.com</a></li>
<li>网易花田 <a href="https://love.163.com/">https://love.163.com</a></li>
<li>网易考拉 <a href="https://www.kaola.com/">https://www.kaola.com</a></li>
<li>网易 Lofter <a href="http://www.lofter.com/">http://www.lofter.com</a></li>
</ul>
<h3 id="SSO-有什么好处？"><a href="#SSO-有什么好处？" class="headerlink" title="SSO 有什么好处？"></a>SSO 有什么好处？</h3><ol>
<li><strong>用户角度</strong> :用户能够做到一次登录多次使用，无需记录多套用户名和密码，省心。</li>
<li><strong>系统管理员角度</strong> : 管理员只需维护好一个统一的账号中心就可以了，方便。</li>
<li><strong>新系统开发角度:</strong> 新系统开发时只需直接对接统一的账号中心即可，简化开发流程，省时。</li>
</ol>
<h2 id="SSO-设计与实现"><a href="#SSO-设计与实现" class="headerlink" title="SSO 设计与实现"></a>SSO 设计与实现</h2><p>本篇文章也主要是为了探讨如何设计&amp;实现一个 SSO 系统</p>
<p>以下为需要实现的核心功能：</p>
<ul>
<li>单点登录</li>
<li>单点登出</li>
<li>支持跨域单点登录</li>
<li>支持跨域单点登出</li>
</ul>
<h3 id="核心应用与依赖"><a href="#核心应用与依赖" class="headerlink" title="核心应用与依赖"></a>核心应用与依赖</h3><p><img src="https://oss.javaguide.cn/github/javaguide/system-design/security/sso/sso-system.png-kblb.png" alt="单点登录（SSO）设计"></p>
<table>
<thead>
<tr>
<th>应用&#x2F;模块&#x2F;对象</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>前台站点</td>
<td>需要登录的站点</td>
</tr>
<tr>
<td>SSO 站点-登录</td>
<td>提供登录的页面</td>
</tr>
<tr>
<td>SSO 站点-登出</td>
<td>提供注销登录的入口</td>
</tr>
<tr>
<td>SSO 服务-登录</td>
<td>提供登录服务</td>
</tr>
<tr>
<td>SSO 服务-登录状态</td>
<td>提供登录状态校验&#x2F;登录信息查询的服务</td>
</tr>
<tr>
<td>SSO 服务-登出</td>
<td>提供用户注销登录的服务</td>
</tr>
<tr>
<td>数据库</td>
<td>存储用户账户信息</td>
</tr>
<tr>
<td>缓存</td>
<td>存储用户的登录信息，通常使用 Redis</td>
</tr>
</tbody></table>
<h3 id="用户登录状态的存储与校验"><a href="#用户登录状态的存储与校验" class="headerlink" title="用户登录状态的存储与校验"></a>用户登录状态的存储与校验</h3><p>常见的 Web 框架对于 Session 的实现都是生成一个 SessionId 存储在浏览器 Cookie 中。然后将 Session 内容存储在服务器端内存中，这个 <a href="https://ken.io/">ken.io</a> 在之前<a href="https://ken.io/note/session-principle-skill">Session 工作原理</a>中也提到过。整体也是借鉴这个思路。</p>
<p>用户登录成功之后，生成 AuthToken 交给客户端保存。如果是浏览器，就保存在 Cookie 中。如果是手机 App 就保存在 App 本地缓存中。本篇主要探讨基于 Web 站点的 SSO。</p>
<p>用户在浏览需要登录的页面时，客户端将 AuthToken 提交给 SSO 服务校验登录状态&#x2F;获取用户登录信息</p>
<p>对于登录信息的存储，建议采用 Redis，使用 Redis 集群来存储登录信息，既可以保证高可用，又可以线性扩充。同时也可以让 SSO 服务满足负载均衡&#x2F;可伸缩的需求。</p>
<table>
<thead>
<tr>
<th>对象</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>AuthToken</td>
<td>直接使用 UUID&#x2F;GUID 即可，如果有验证 AuthToken 合法性需求，可以将 UserName+时间戳加密生成，服务端解密之后验证合法性</td>
</tr>
<tr>
<td>登录信息</td>
<td>通常是将 UserId，UserName 缓存起来</td>
</tr>
</tbody></table>
<h3 id="用户登录-登录校验"><a href="#用户登录-登录校验" class="headerlink" title="用户登录&#x2F;登录校验"></a>用户登录&#x2F;登录校验</h3><p><strong>登录时序图</strong></p>
<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/security/sso/sso-login-sequence.png-kbrb.png" alt="SSO系统设计-登录时序图"></p>
<p>按照上图，用户登录后 AuthToken 保存在 Cookie 中。 domain&#x3D;test.com<br>浏览器会将 domain 设置成 .test.com，</p>
<p>这样访问所有 *.test.com 的 web 站点，都会将 AuthToken 携带到服务器端。<br>然后通过 SSO 服务，完成对用户状态的校验&#x2F;用户登录信息的获取</p>
<p><strong>登录信息获取&#x2F;登录状态校验</strong></p>
<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/security/sso/sso-logincheck-sequence.png-kbrb.png" alt="SSO系统设计-登录信息获取/登录状态校验"></p>
<h3 id="用户登出"><a href="#用户登出" class="headerlink" title="用户登出"></a>用户登出</h3><p>用户登出时要做的事情很简单：</p>
<ol>
<li>服务端清除缓存（Redis）中的登录状态</li>
<li>客户端清除存储的 AuthToken</li>
</ol>
<p><strong>登出时序图</strong></p>
<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/security/sso/sso-logout-sequence.png-kbrb.png" alt="SSO系统设计-用户登出"></p>
<h3 id="跨域登录、登出"><a href="#跨域登录、登出" class="headerlink" title="跨域登录、登出"></a>跨域登录、登出</h3><p>前面提到过，核心思路是客户端存储 AuthToken，服务器端通过 Redis 存储登录信息。由于客户端是将 AuthToken 存储在 Cookie 中的。所以跨域要解决的问题，就是如何解决 Cookie 的跨域读写问题。</p>
<p>解决跨域的核心思路就是：</p>
<ul>
<li>登录完成之后通过回调的方式，将 AuthToken 传递给主域名之外的站点，该站点自行将 AuthToken 保存在当前域下的 Cookie 中。</li>
<li>登出完成之后通过回调的方式，调用非主域名站点的登出页面，完成设置 Cookie 中的 AuthToken 过期的操作。</li>
</ul>
<p><strong>跨域登录（主域名已登录）</strong></p>
<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/security/sso/sso-crossdomain-login-loggedin-sequence.png-kbrb.png" alt="SSO系统设计-跨域登录（主域名已登录）"></p>
<p><strong>跨域登录（主域名未登录）</strong></p>
<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/security/sso/sso-crossdomain-login-unlogin-sequence.png-kbrb.png" alt="SSO系统设计-跨域登录（主域名未登录）"></p>
<p><strong>跨域登出</strong></p>
<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/security/sso/sso-crossdomain-logout-sequence.png-kbrb.png" alt="SSO系统设计-跨域登出"></p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul>
<li>关于方案：这次设计方案更多是提供实现思路。如果涉及到 APP 用户登录等情况，在访问 SSO 服务时，增加对 APP 的签名验证就好了。当然，如果有无线网关，验证签名不是问题。</li>
<li>关于时序图：时序图中并没有包含所有场景，只列举了核心&#x2F;主要场景，另外对于一些不影响理解思路的消息能省就省了。</li>
</ul>
<!-- @include: @article-footer.snippet.md -->

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2024/09/23/sql-questions-04/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/09/23/sql-questions-04/" itemprop="url">SQL常见面试题总结（4）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-09-23T18:26:08+08:00">
                2024-09-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/" itemprop="url" rel="index">
                    <span itemprop="name">面试问题</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2024/09/23/sql-questions-04/" class="leancloud_visitors" data-flag-title="SQL常见面试题总结（4）">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  6.6k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  31 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>题目来源于：<a href="https://www.nowcoder.com/exam/oj?page=1&tab=SQL%E7%AF%87&topicId=240">牛客题霸 - SQL 进阶挑战</a></p>
</blockquote>
<p>较难或者困难的题目可以根据自身实际情况和面试需要来决定是否要跳过。</p>
<h2 id="专用窗口函数"><a href="#专用窗口函数" class="headerlink" title="专用窗口函数"></a>专用窗口函数</h2><p>MySQL 8.0 版本引入了窗口函数的支持，下面是 MySQL 中常见的窗口函数及其用法：</p>
<ol>
<li><code>ROW_NUMBER()</code>: 为查询结果集中的每一行分配一个唯一的整数值。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col1, col2, <span class="built_in">ROW_NUMBER</span>() <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> col1) <span class="keyword">AS</span> row_num</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">table</span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>RANK()</code>: 计算每一行在排序结果中的排名。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col1, col2, <span class="built_in">RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> col1 <span class="keyword">DESC</span>) <span class="keyword">AS</span> ranking</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">table</span>;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>DENSE_RANK()</code>: 计算每一行在排序结果中的排名，保留相同的排名。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col1, col2, <span class="built_in">DENSE_RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> col1 <span class="keyword">DESC</span>) <span class="keyword">AS</span> ranking</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">table</span>;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><code>NTILE(n)</code>: 将结果分成 n 个基本均匀的桶，并为每个桶分配一个标识号。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col1, col2, <span class="built_in">NTILE</span>(<span class="number">4</span>) <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> col1) <span class="keyword">AS</span> bucket</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">table</span>;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><code>SUM()</code>, <code>AVG()</code>,<code>COUNT()</code>, <code>MIN()</code>, <code>MAX()</code>: 这些聚合函数也可以与窗口函数结合使用，计算窗口内指定列的汇总、平均值、计数、最小值和最大值。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col1, col2, <span class="built_in">SUM</span>(col1) <span class="keyword">OVER</span> () <span class="keyword">AS</span> sum_col</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">table</span>;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><code>LEAD()</code> 和 <code>LAG()</code>: LEAD 函数用于获取当前行之后的某个偏移量的行的值，而 LAG 函数用于获取当前行之前的某个偏移量的行的值。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col1, col2, <span class="built_in">LEAD</span>(col1, <span class="number">1</span>) <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> col1) <span class="keyword">AS</span> next_col1,</span><br><span class="line">                 <span class="built_in">LAG</span>(col1, <span class="number">1</span>) <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> col1) <span class="keyword">AS</span> prev_col1</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">table</span>;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li><code>FIRST_VALUE()</code> 和 <code>LAST_VALUE()</code>: FIRST_VALUE 函数用于获取窗口内指定列的第一个值，LAST_VALUE 函数用于获取窗口内指定列的最后一个值。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col1, col2, <span class="built_in">FIRST_VALUE</span>(col2) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> col1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> col2) <span class="keyword">AS</span> first_val,</span><br><span class="line">                 <span class="built_in">LAST_VALUE</span>(col2) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> col1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> col2) <span class="keyword">AS</span> last_val</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">table</span>;</span><br></pre></td></tr></table></figure>

<p>窗口函数通常需要配合 OVER 子句一起使用，用于定义窗口的大小、排序规则和分组方式。</p>
<h3 id="每类试卷得分前三名"><a href="#每类试卷得分前三名" class="headerlink" title="每类试卷得分前三名"></a>每类试卷得分前三名</h3><p><strong>描述</strong>：</p>
<p>现有试卷信息表 <code>examination_info</code>（<code>exam_id</code> 试卷 ID, <code>tag</code> 试卷类别, <code>difficulty</code> 试卷难度, <code>duration</code> 考试时长, <code>release_time</code> 发布时间）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>exam_id</th>
<th>tag</th>
<th>difficulty</th>
<th>duration</th>
<th>release_time</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>9001</td>
<td>SQL</td>
<td>hard</td>
<td>60</td>
<td>2021-09-01 06:00:00</td>
</tr>
<tr>
<td>2</td>
<td>9002</td>
<td>SQL</td>
<td>hard</td>
<td>60</td>
<td>2021-09-01 06:00:00</td>
</tr>
<tr>
<td>3</td>
<td>9003</td>
<td>算法</td>
<td>medium</td>
<td>80</td>
<td>2021-09-01 10:00:00</td>
</tr>
</tbody></table>
<p>试卷作答记录表 <code>exam_record</code>（<code>uid</code> 用户 ID, <code>exam_id</code> 试卷 ID, <code>start_time</code> 开始作答时间, <code>submit_time</code> 交卷时间, score 得分）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>uid</th>
<th>exam_id</th>
<th>start_time</th>
<th>submit_time</th>
<th>score</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1001</td>
<td>9001</td>
<td>2021-09-01 09:01:01</td>
<td>2021-09-01 09:31:00</td>
<td>78</td>
</tr>
<tr>
<td>2</td>
<td>1002</td>
<td>9001</td>
<td>2021-09-01 09:01:01</td>
<td>2021-09-01 09:31:00</td>
<td>81</td>
</tr>
<tr>
<td>3</td>
<td>1002</td>
<td>9002</td>
<td>2021-09-01 12:01:01</td>
<td>2021-09-01 12:31:01</td>
<td>81</td>
</tr>
<tr>
<td>4</td>
<td>1003</td>
<td>9001</td>
<td>2021-09-01 19:01:01</td>
<td>2021-09-01 19:40:01</td>
<td>86</td>
</tr>
<tr>
<td>5</td>
<td>1003</td>
<td>9002</td>
<td>2021-09-01 12:01:01</td>
<td>2021-09-01 12:31:51</td>
<td>89</td>
</tr>
<tr>
<td>6</td>
<td>1004</td>
<td>9001</td>
<td>2021-09-01 19:01:01</td>
<td>2021-09-01 19:30:01</td>
<td>85</td>
</tr>
<tr>
<td>7</td>
<td>1005</td>
<td>9003</td>
<td>2021-09-01 12:01:01</td>
<td>2021-09-01 12:31:02</td>
<td>85</td>
</tr>
<tr>
<td>8</td>
<td>1006</td>
<td>9003</td>
<td>2021-09-07 10:01:01</td>
<td>2021-09-07 10:21:01</td>
<td>84</td>
</tr>
<tr>
<td>9</td>
<td>1003</td>
<td>9003</td>
<td>2021-09-08 12:01:01</td>
<td>2021-09-08 12:11:01</td>
<td>40</td>
</tr>
<tr>
<td>10</td>
<td>1003</td>
<td>9002</td>
<td>2021-09-01 14:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
</tbody></table>
<p>找到每类试卷得分的前 3 名，如果两人最大分数相同，选择最小分数大者，如果还相同，选择 uid 大者。由示例数据结果输出如下：</p>
<table>
<thead>
<tr>
<th>tid</th>
<th>uid</th>
<th>ranking</th>
</tr>
</thead>
<tbody><tr>
<td>SQL</td>
<td>1003</td>
<td>1</td>
</tr>
<tr>
<td>SQL</td>
<td>1004</td>
<td>2</td>
</tr>
<tr>
<td>SQL</td>
<td>1002</td>
<td>3</td>
</tr>
<tr>
<td>算法</td>
<td>1005</td>
<td>1</td>
</tr>
<tr>
<td>算法</td>
<td>1006</td>
<td>2</td>
</tr>
<tr>
<td>算法</td>
<td>1003</td>
<td>3</td>
</tr>
</tbody></table>
<p><strong>解释</strong>：有作答得分记录的试卷 tag 有 SQL 和算法，SQL 试卷用户 1001、1002、1003、1004 有作答得分，最高得分分别为 81、81、89、85，最低得分分别为 78、81、86、40，因此先按最高得分排名再按最低得分排名取前三为 1003、1004、1002。</p>
<p><strong>答案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> tag,</span><br><span class="line">       UID,</span><br><span class="line">       ranking</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  (<span class="keyword">SELECT</span> b.tag <span class="keyword">AS</span> tag,</span><br><span class="line">          a.uid <span class="keyword">AS</span> UID,</span><br><span class="line">          <span class="built_in">ROW_NUMBER</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> b.tag</span><br><span class="line">                             <span class="keyword">ORDER</span> <span class="keyword">BY</span> b.tag,</span><br><span class="line">                                      <span class="built_in">max</span>(a.score) <span class="keyword">DESC</span>,</span><br><span class="line">                                      <span class="built_in">min</span>(a.score) <span class="keyword">DESC</span>,</span><br><span class="line">                                      a.uid <span class="keyword">DESC</span>) <span class="keyword">AS</span> ranking</span><br><span class="line">   <span class="keyword">FROM</span> exam_record a</span><br><span class="line">   <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> examination_info b <span class="keyword">ON</span> a.exam_id <span class="operator">=</span> b.exam_id</span><br><span class="line">   <span class="keyword">GROUP</span> <span class="keyword">BY</span> b.tag,</span><br><span class="line">            a.uid) t</span><br><span class="line"><span class="keyword">WHERE</span> ranking <span class="operator">&lt;=</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h3 id="第二快-慢用时之差大于试卷时长一半的试卷（较难）"><a href="#第二快-慢用时之差大于试卷时长一半的试卷（较难）" class="headerlink" title="第二快&#x2F;慢用时之差大于试卷时长一半的试卷（较难）"></a>第二快&#x2F;慢用时之差大于试卷时长一半的试卷（较难）</h3><p><strong>描述</strong>：</p>
<p>现有试卷信息表 <code>examination_info</code>（<code>exam_id</code> 试卷 ID, <code>tag</code> 试卷类别, <code>difficulty</code> 试卷难度, <code>duration</code> 考试时长, <code>release_time</code> 发布时间）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>exam_id</th>
<th>tag</th>
<th>difficulty</th>
<th>duration</th>
<th>release_time</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>9001</td>
<td>SQL</td>
<td>hard</td>
<td>60</td>
<td>2021-09-01 06:00:00</td>
</tr>
<tr>
<td>2</td>
<td>9002</td>
<td>C++</td>
<td>hard</td>
<td>60</td>
<td>2021-09-01 06:00:00</td>
</tr>
<tr>
<td>3</td>
<td>9003</td>
<td>算法</td>
<td>medium</td>
<td>80</td>
<td>2021-09-01 10:00:00</td>
</tr>
</tbody></table>
<p>试卷作答记录表 <code>exam_record</code>（<code>uid</code> 用户 ID, <code>exam_id</code> 试卷 ID, <code>start_time</code> 开始作答时间, <code>submit_time</code> 交卷时间, <code>score</code> 得分）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>uid</th>
<th>exam_id</th>
<th>start_time</th>
<th>submit_time</th>
<th>score</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1001</td>
<td>9001</td>
<td>2021-09-01 09:01:01</td>
<td>2021-09-01 09:51:01</td>
<td>78</td>
</tr>
<tr>
<td>2</td>
<td>1001</td>
<td>9002</td>
<td>2021-09-01 09:01:01</td>
<td>2021-09-01 09:31:00</td>
<td>81</td>
</tr>
<tr>
<td>3</td>
<td>1002</td>
<td>9002</td>
<td>2021-09-01 12:01:01</td>
<td>2021-09-01 12:31:01</td>
<td>81</td>
</tr>
<tr>
<td>4</td>
<td>1003</td>
<td>9001</td>
<td>2021-09-01 19:01:01</td>
<td>2021-09-01 19:59:01</td>
<td>86</td>
</tr>
<tr>
<td>5</td>
<td>1003</td>
<td>9002</td>
<td>2021-09-01 12:01:01</td>
<td>2021-09-01 12:31:51</td>
<td>89</td>
</tr>
<tr>
<td>6</td>
<td>1004</td>
<td>9002</td>
<td>2021-09-01 19:01:01</td>
<td>2021-09-01 19:30:01</td>
<td>85</td>
</tr>
<tr>
<td>7</td>
<td>1005</td>
<td>9001</td>
<td>2021-09-01 12:01:01</td>
<td>2021-09-01 12:31:02</td>
<td>85</td>
</tr>
<tr>
<td>8</td>
<td>1006</td>
<td>9001</td>
<td>2021-09-07 10:02:01</td>
<td>2021-09-07 10:21:01</td>
<td>84</td>
</tr>
<tr>
<td>9</td>
<td>1003</td>
<td>9001</td>
<td>2021-09-08 12:01:01</td>
<td>2021-09-08 12:11:01</td>
<td>40</td>
</tr>
<tr>
<td>10</td>
<td>1003</td>
<td>9002</td>
<td>2021-09-01 14:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>11</td>
<td>1005</td>
<td>9001</td>
<td>2021-09-01 14:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>12</td>
<td>1003</td>
<td>9003</td>
<td>2021-09-08 15:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
</tbody></table>
<p>找到第二快和第二慢用时之差大于试卷时长的一半的试卷信息，按试卷 ID 降序排序。由示例数据结果输出如下：</p>
<table>
<thead>
<tr>
<th>exam_id</th>
<th>duration</th>
<th>release_time</th>
</tr>
</thead>
<tbody><tr>
<td>9001</td>
<td>60</td>
<td>2021-09-01 06:00:00</td>
</tr>
</tbody></table>
<p><strong>解释</strong>：试卷 9001 被作答用时有 50 分钟、58 分钟、30 分 1 秒、19 分钟、10 分钟，第二快和第二慢用时之差为 50 分钟-19 分钟&#x3D;31 分钟，试卷时长为 60 分钟，因此满足大于试卷时长一半的条件，输出试卷 ID、时长、发布时间。</p>
<p><strong>思路：</strong></p>
<p>第一步，找到每张试卷完成时间的顺序排名和倒序排名 也就是表 a；</p>
<p>第二步，与通过试卷信息表 b 建立内连接，并根据试卷 id 分组，利用<code>having</code>筛选排名为第二个数据，将秒转化为分钟并进行比较，最后再根据试卷 id 倒序排序就行</p>
<p><strong>答案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.exam_id,</span><br><span class="line">       b.duration,</span><br><span class="line">       b.release_time</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  (<span class="keyword">SELECT</span> exam_id,</span><br><span class="line">          <span class="built_in">row_number</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> exam_id</span><br><span class="line">                             <span class="keyword">ORDER</span> <span class="keyword">BY</span> timestampdiff(<span class="keyword">SECOND</span>, start_time, submit_time) <span class="keyword">DESC</span>) rn1,</span><br><span class="line">          <span class="built_in">row_number</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> exam_id</span><br><span class="line">                            <span class="keyword">ORDER</span> <span class="keyword">BY</span> timestampdiff(<span class="keyword">SECOND</span>, start_time, submit_time) <span class="keyword">ASC</span>) rn2,</span><br><span class="line">                                              timestampdiff(<span class="keyword">SECOND</span>, start_time, submit_time) timex</span><br><span class="line">   <span class="keyword">FROM</span> exam_record</span><br><span class="line">   <span class="keyword">WHERE</span> score <span class="keyword">IS</span> <span class="keyword">NOT NULL</span> ) a</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> examination_info b <span class="keyword">ON</span> a.exam_id <span class="operator">=</span> b.exam_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> a.exam_id</span><br><span class="line"><span class="keyword">HAVING</span> (<span class="built_in">max</span>(IF (rn1 <span class="operator">=</span> <span class="number">2</span>, a.timex, <span class="number">0</span>))<span class="operator">-</span> <span class="built_in">max</span>(IF (rn2 <span class="operator">=</span> <span class="number">2</span>, a.timex, <span class="number">0</span>)))<span class="operator">/</span> <span class="number">60</span> <span class="operator">&gt;</span> b.duration <span class="operator">/</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> a.exam_id <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>

<h3 id="连续两次作答试卷的最大时间窗（较难）"><a href="#连续两次作答试卷的最大时间窗（较难）" class="headerlink" title="连续两次作答试卷的最大时间窗（较难）"></a>连续两次作答试卷的最大时间窗（较难）</h3><p><strong>描述</strong></p>
<p>现有试卷作答记录表 <code>exam_record</code>（<code>uid</code> 用户 ID, <code>exam_id</code> 试卷 ID, <code>start_time</code> 开始作答时间, <code>submit_time</code> 交卷时间, <code>score</code> 得分）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>uid</th>
<th>exam_id</th>
<th>start_time</th>
<th>submit_time</th>
<th>score</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1006</td>
<td>9003</td>
<td>2021-09-07 10:01:01</td>
<td>2021-09-07 10:21:02</td>
<td>84</td>
</tr>
<tr>
<td>2</td>
<td>1006</td>
<td>9001</td>
<td>2021-09-01 12:11:01</td>
<td>2021-09-01 12:31:01</td>
<td>89</td>
</tr>
<tr>
<td>3</td>
<td>1006</td>
<td>9002</td>
<td>2021-09-06 10:01:01</td>
<td>2021-09-06 10:21:01</td>
<td>81</td>
</tr>
<tr>
<td>4</td>
<td>1005</td>
<td>9002</td>
<td>2021-09-05 10:01:01</td>
<td>2021-09-05 10:21:01</td>
<td>81</td>
</tr>
<tr>
<td>5</td>
<td>1005</td>
<td>9001</td>
<td>2021-09-05 10:31:01</td>
<td>2021-09-05 10:51:01</td>
<td>81</td>
</tr>
</tbody></table>
<p>请计算在 2021 年至少有两天作答过试卷的人中，计算该年连续两次作答试卷的最大时间窗 <code>days_window</code>，那么根据该年的历史规律他在 <code>days_window</code> 天里平均会做多少套试卷，按最大时间窗和平均做答试卷套数倒序排序。由示例数据结果输出如下：</p>
<table>
<thead>
<tr>
<th>uid</th>
<th>days_window</th>
<th>avg_exam_cnt</th>
</tr>
</thead>
<tbody><tr>
<td>1006</td>
<td>6</td>
<td>2.57</td>
</tr>
</tbody></table>
<p><strong>解释</strong>：用户 1006 分别在 20210901、20210906、20210907 作答过 3 次试卷，连续两次作答最大时间窗为 6 天（1 号到 6 号），他 1 号到 7 号这 7 天里共做了 3 张试卷，平均每天 3&#x2F;7&#x3D;0.428571 张，那么 6 天里平均会做 0.428571*6&#x3D;2.57 张试卷（保留两位小数）；用户 1005 在 20210905 做了两张试卷，但是只有一天的作答记录，过滤掉。</p>
<p><strong>思路：</strong></p>
<p>上面这个解释中提示要对作答记录去重，千万别被骗了，不要去重！去重就通不过测试用例。注意限制时间是 2021 年；</p>
<p>而且要注意时间差要+1 天；还要注意&#x3D;&#x3D;没交卷也算在内&#x3D;&#x3D;！！！！ （反正感觉这题描述不清，出的不是很好）</p>
<p><strong>答案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> UID,</span><br><span class="line">       <span class="built_in">max</span>(datediff(next_time, start_time)) <span class="operator">+</span> <span class="number">1</span> <span class="keyword">AS</span> days_window,</span><br><span class="line">       round(<span class="built_in">count</span>(start_time)<span class="operator">/</span>(datediff(<span class="built_in">max</span>(start_time), <span class="built_in">min</span>(start_time))<span class="operator">+</span> <span class="number">1</span>) <span class="operator">*</span> (<span class="built_in">max</span>(datediff(next_time, start_time))<span class="operator">+</span> <span class="number">1</span>), <span class="number">2</span>) <span class="keyword">AS</span> avg_exam_cnt</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  (<span class="keyword">SELECT</span> UID,</span><br><span class="line">          start_time,</span><br><span class="line">          <span class="built_in">lead</span>(start_time, <span class="number">1</span>) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> UID</span><br><span class="line">                                    <span class="keyword">ORDER</span> <span class="keyword">BY</span> start_time) <span class="keyword">AS</span> next_time</span><br><span class="line">   <span class="keyword">FROM</span> exam_record</span><br><span class="line">   <span class="keyword">WHERE</span> <span class="keyword">YEAR</span> (start_time) <span class="operator">=</span> <span class="string">&#x27;2021&#x27;</span> ) a</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> UID</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">count</span>(<span class="keyword">DISTINCT</span> <span class="type">date</span>(start_time)) <span class="operator">&gt;</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> days_window <span class="keyword">DESC</span>,</span><br><span class="line">         avg_exam_cnt <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>

<h3 id="近三个月未完成为-0-的用户完成情况"><a href="#近三个月未完成为-0-的用户完成情况" class="headerlink" title="近三个月未完成为 0 的用户完成情况"></a>近三个月未完成为 0 的用户完成情况</h3><p><strong>描述</strong>：</p>
<p>现有试卷作答记录表 <code>exam_record</code>（<code>uid</code>:用户 ID, <code>exam_id</code>:试卷 ID, <code>start_time</code>:开始作答时间, <code>submit_time</code>:交卷时间，为空的话则代表未完成, <code>score</code>:得分）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>uid</th>
<th>exam_id</th>
<th>start_time</th>
<th>submit_time</th>
<th>score</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1006</td>
<td>9003</td>
<td>2021-09-06 10:01:01</td>
<td>2021-09-06 10:21:02</td>
<td>84</td>
</tr>
<tr>
<td>2</td>
<td>1006</td>
<td>9001</td>
<td>2021-08-02 12:11:01</td>
<td>2021-08-02 12:31:01</td>
<td>89</td>
</tr>
<tr>
<td>3</td>
<td>1006</td>
<td>9002</td>
<td>2021-06-06 10:01:01</td>
<td>2021-06-06 10:21:01</td>
<td>81</td>
</tr>
<tr>
<td>4</td>
<td>1006</td>
<td>9002</td>
<td>2021-05-06 10:01:01</td>
<td>2021-05-06 10:21:01</td>
<td>81</td>
</tr>
<tr>
<td>5</td>
<td>1006</td>
<td>9001</td>
<td>2021-05-01 12:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>6</td>
<td>1001</td>
<td>9001</td>
<td>2021-09-05 10:31:01</td>
<td>2021-09-05 10:51:01</td>
<td>81</td>
</tr>
<tr>
<td>7</td>
<td>1001</td>
<td>9003</td>
<td>2021-08-01 09:01:01</td>
<td>2021-08-01 09:51:11</td>
<td>78</td>
</tr>
<tr>
<td>8</td>
<td>1001</td>
<td>9002</td>
<td>2021-07-01 09:01:01</td>
<td>2021-07-01 09:31:00</td>
<td>81</td>
</tr>
<tr>
<td>9</td>
<td>1001</td>
<td>9002</td>
<td>2021-07-01 12:01:01</td>
<td>2021-07-01 12:31:01</td>
<td>81</td>
</tr>
<tr>
<td>10</td>
<td>1001</td>
<td>9002</td>
<td>2021-07-01 12:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
</tbody></table>
<p>找到每个人近三个有试卷作答记录的月份中没有试卷是未完成状态的用户的试卷作答完成数，按试卷完成数和用户 ID 降序排名。由示例数据结果输出如下：</p>
<table>
<thead>
<tr>
<th>uid</th>
<th>exam_complete_cnt</th>
</tr>
</thead>
<tbody><tr>
<td>1006</td>
<td>3</td>
</tr>
</tbody></table>
<p><strong>解释</strong>：用户 1006 近三个有作答试卷的月份为 202109、202108、202106，作答试卷数为 3，全部完成；用户 1001 近三个有作答试卷的月份为 202109、202108、202107，作答试卷数为 5，完成试卷数为 4，因为有未完成试卷，故过滤掉。</p>
<p><strong>思路:</strong></p>
<ol>
<li><code>找到每个人近三个有试卷作答记录的月份中没有试卷是未完成状态的用户的试卷作答完成数</code>首先看这句话，肯定要先根据人进行分组</li>
<li>最近三个月，可以采用连续重复排名，倒序排列，排名&lt;&#x3D;3</li>
<li>统计作答数</li>
<li>拼装剩余条件</li>
<li>排序</li>
</ol>
<p><strong>答案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> UID,</span><br><span class="line">       <span class="built_in">count</span>(score) exam_complete_cnt</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  (<span class="keyword">SELECT</span> <span class="operator">*</span>, <span class="built_in">DENSE_RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> UID</span><br><span class="line">                             <span class="keyword">ORDER</span> <span class="keyword">BY</span> date_format(start_time, <span class="string">&#x27;%Y%m&#x27;</span>) <span class="keyword">DESC</span>) dr</span><br><span class="line">   <span class="keyword">FROM</span> exam_record) t1</span><br><span class="line"><span class="keyword">WHERE</span> dr <span class="operator">&lt;=</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> UID</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">count</span>(dr)<span class="operator">=</span> <span class="built_in">count</span>(score)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> exam_complete_cnt <span class="keyword">DESC</span>,</span><br><span class="line">         UID <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>

<h3 id="未完成率较高的-50-用户近三个月答卷情况（困难）"><a href="#未完成率较高的-50-用户近三个月答卷情况（困难）" class="headerlink" title="未完成率较高的 50%用户近三个月答卷情况（困难）"></a>未完成率较高的 50%用户近三个月答卷情况（困难）</h3><p><strong>描述</strong>：</p>
<p>现有用户信息表 <code>user_info</code>（<code>uid</code> 用户 ID，<code>nick_name</code> 昵称, <code>achievement</code> 成就值, <code>level</code> 等级, <code>job</code> 职业方向, <code>register_time</code> 注册时间）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>uid</th>
<th>nick_name</th>
<th>achievement</th>
<th>level</th>
<th>job</th>
<th>register_time</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1001</td>
<td>牛客 1 号</td>
<td>3200</td>
<td>7</td>
<td>算法</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>2</td>
<td>1002</td>
<td>牛客 2 号</td>
<td>2500</td>
<td>6</td>
<td>算法</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>3</td>
<td>1003</td>
<td>牛客 3 号 ♂</td>
<td>2200</td>
<td>5</td>
<td>算法</td>
<td>2020-01-01 10:00:00</td>
</tr>
</tbody></table>
<p>试卷信息表 <code>examination_info</code>（<code>exam_id</code> 试卷 ID, <code>tag</code> 试卷类别, <code>difficulty</code> 试卷难度, <code>duration</code> 考试时长, <code>release_time</code> 发布时间）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>exam_id</th>
<th>tag</th>
<th>difficulty</th>
<th>duration</th>
<th>release_time</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>9001</td>
<td>SQL</td>
<td>hard</td>
<td>60</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>2</td>
<td>9002</td>
<td>SQL</td>
<td>hard</td>
<td>80</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>3</td>
<td>9003</td>
<td>算法</td>
<td>hard</td>
<td>80</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>4</td>
<td>9004</td>
<td>PYTHON</td>
<td>medium</td>
<td>70</td>
<td>2020-01-01 10:00:00</td>
</tr>
</tbody></table>
<p>试卷作答记录表 <code>exam_record</code>（<code>uid</code> 用户 ID, <code>exam_id</code> 试卷 ID, <code>start_time</code> 开始作答时间, <code>submit_time</code> 交卷时间, <code>score</code> 得分）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>uid</th>
<th>exam_id</th>
<th>start_time</th>
<th>submit_time</th>
<th>score</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1001</td>
<td>9001</td>
<td>2020-01-01 09:01:01</td>
<td>2020-01-01 09:21:59</td>
<td>90</td>
</tr>
<tr>
<td>15</td>
<td>1002</td>
<td>9001</td>
<td>2020-01-01 18:01:01</td>
<td>2020-01-01 18:59:02</td>
<td>90</td>
</tr>
<tr>
<td>13</td>
<td>1001</td>
<td>9001</td>
<td>2020-01-02 10:01:01</td>
<td>2020-01-02 10:31:01</td>
<td>89</td>
</tr>
<tr>
<td>2</td>
<td>1002</td>
<td>9001</td>
<td>2020-01-20 10:01:01</td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>1002</td>
<td>9001</td>
<td>2020-02-01 12:11:01</td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>1001</td>
<td>9001</td>
<td>2020-03-01 12:01:01</td>
<td></td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>1002</td>
<td>9001</td>
<td>2020-03-01 12:01:01</td>
<td>2020-03-01 12:41:01</td>
<td>90</td>
</tr>
<tr>
<td>4</td>
<td>1003</td>
<td>9001</td>
<td>2020-03-01 19:01:01</td>
<td></td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>1002</td>
<td>9001</td>
<td>2020-05-02 19:01:01</td>
<td>2020-05-02 19:32:00</td>
<td>90</td>
</tr>
<tr>
<td>14</td>
<td>1001</td>
<td>9002</td>
<td>2020-01-01 12:11:01</td>
<td></td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>1001</td>
<td>9002</td>
<td>2020-01-02 19:01:01</td>
<td>2020-01-02 19:59:01</td>
<td>69</td>
</tr>
<tr>
<td>9</td>
<td>1001</td>
<td>9002</td>
<td>2020-02-02 12:01:01</td>
<td>2020-02-02 12:20:01</td>
<td>99</td>
</tr>
<tr>
<td>10</td>
<td>1002</td>
<td>9002</td>
<td>2020-02-02 12:01:01</td>
<td></td>
<td></td>
</tr>
<tr>
<td>11</td>
<td>1002</td>
<td>9002</td>
<td>2020-02-02 12:01:01</td>
<td>2020-02-02 12:43:01</td>
<td>81</td>
</tr>
<tr>
<td>12</td>
<td>1002</td>
<td>9002</td>
<td>2020-03-02 12:11:01</td>
<td></td>
<td></td>
</tr>
<tr>
<td>17</td>
<td>1001</td>
<td>9002</td>
<td>2020-05-05 18:01:01</td>
<td></td>
<td></td>
</tr>
<tr>
<td>16</td>
<td>1002</td>
<td>9003</td>
<td>2020-05-06 12:01:01</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>请统计 SQL 试卷上未完成率较高的 50%用户中，6 级和 7 级用户在有试卷作答记录的近三个月中，每个月的答卷数目和完成数目。按用户 ID、月份升序排序。</p>
<p>由示例数据结果输出如下：</p>
<table>
<thead>
<tr>
<th>uid</th>
<th>start_month</th>
<th>total_cnt</th>
<th>complete_cnt</th>
</tr>
</thead>
<tbody><tr>
<td>1002</td>
<td>202002</td>
<td>3</td>
<td>1</td>
</tr>
<tr>
<td>1002</td>
<td>202003</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>1002</td>
<td>202005</td>
<td>2</td>
<td>1</td>
</tr>
</tbody></table>
<p>解释：各个用户对 SQL 试卷的未完成数、作答总数、未完成率如下：</p>
<table>
<thead>
<tr>
<th>uid</th>
<th>incomplete_cnt</th>
<th>total_cnt</th>
<th>incomplete_rate</th>
</tr>
</thead>
<tbody><tr>
<td>1001</td>
<td>3</td>
<td>7</td>
<td>0.4286</td>
</tr>
<tr>
<td>1002</td>
<td>4</td>
<td>8</td>
<td>0.5000</td>
</tr>
<tr>
<td>1003</td>
<td>1</td>
<td>1</td>
<td>1.0000</td>
</tr>
</tbody></table>
<p>1001、1002、1003 分别排在 1.0、0.5、0.0 的位置，因此较高的 50%用户（排位&lt;&#x3D;0.5）为 1002、1003；</p>
<p>1003 不是 6 级或 7 级；</p>
<p>有试卷作答记录的近三个月为 202005、202003、202002；</p>
<p>这三个月里 1002 的作答题数分别为 3、2、2，完成数目分别为 1、1、1。</p>
<p><strong>思路：</strong></p>
<p>注意点：这题注意求的是所有的答题次数和完成次数，而 sql 类别的试卷是限制未完成率排名，6, 7 级用户限制的是做题记录。</p>
<p>先求出未完成率的排名</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> UID,</span><br><span class="line">       <span class="built_in">count</span>(submit_time <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line">             <span class="keyword">OR</span> <span class="keyword">NULL</span>)<span class="operator">/</span> <span class="built_in">count</span>(start_time) <span class="keyword">AS</span> num,</span><br><span class="line">       <span class="built_in">PERCENT_RANK</span>() <span class="keyword">OVER</span> (</span><br><span class="line">                            <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">count</span>(submit_time <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line">                                           <span class="keyword">OR</span> <span class="keyword">NULL</span>)<span class="operator">/</span> <span class="built_in">count</span>(start_time)) <span class="keyword">AS</span> ranking</span><br><span class="line"><span class="keyword">FROM</span> exam_record</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> examination_info <span class="keyword">USING</span> (exam_id)</span><br><span class="line"><span class="keyword">WHERE</span> tag <span class="operator">=</span> <span class="string">&#x27;SQL&#x27;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> UID</span><br></pre></td></tr></table></figure>

<p>再求出最近三个月的练习记录</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> UID,</span><br><span class="line">       date_format(start_time, <span class="string">&#x27;%Y%m&#x27;</span>) <span class="keyword">AS</span> month_d,</span><br><span class="line">       submit_time,</span><br><span class="line">       exam_id,</span><br><span class="line">       <span class="built_in">dense_rank</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> UID</span><br><span class="line">                          <span class="keyword">ORDER</span> <span class="keyword">BY</span> date_format(start_time, <span class="string">&#x27;%Y%m&#x27;</span>) <span class="keyword">DESC</span>) <span class="keyword">AS</span> ranking</span><br><span class="line"><span class="keyword">FROM</span> exam_record</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> user_info <span class="keyword">USING</span> (UID)</span><br><span class="line"><span class="keyword">WHERE</span> LEVEL <span class="keyword">IN</span> (<span class="number">6</span>,<span class="number">7</span>)</span><br></pre></td></tr></table></figure>

<p><strong>答案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> t1.uid,</span><br><span class="line">       t1.month_d,</span><br><span class="line">       <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">AS</span> total_cnt,</span><br><span class="line">       <span class="built_in">count</span>(t1.submit_time) <span class="keyword">AS</span> complete_cnt</span><br><span class="line"><span class="keyword">FROM</span><span class="comment">-- 先求出未完成率的排名</span></span><br><span class="line"></span><br><span class="line">  (<span class="keyword">SELECT</span> UID,</span><br><span class="line">          <span class="built_in">count</span>(submit_time <span class="keyword">IS</span> <span class="keyword">NULL</span> <span class="keyword">OR</span> <span class="keyword">NULL</span>)<span class="operator">/</span> <span class="built_in">count</span>(start_time) <span class="keyword">AS</span> num,</span><br><span class="line">          <span class="built_in">PERCENT_RANK</span>() <span class="keyword">OVER</span> (</span><br><span class="line">                               <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">count</span>(submit_time <span class="keyword">IS</span> <span class="keyword">NULL</span> <span class="keyword">OR</span> <span class="keyword">NULL</span>)<span class="operator">/</span> <span class="built_in">count</span>(start_time)) <span class="keyword">AS</span> ranking</span><br><span class="line">   <span class="keyword">FROM</span> exam_record</span><br><span class="line">   <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> examination_info <span class="keyword">USING</span> (exam_id)</span><br><span class="line">   <span class="keyword">WHERE</span> tag <span class="operator">=</span> <span class="string">&#x27;SQL&#x27;</span></span><br><span class="line">   <span class="keyword">GROUP</span> <span class="keyword">BY</span> UID) t</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span></span><br><span class="line">  (<span class="comment">-- 再求出近三个月的练习记录</span></span><br><span class="line"> <span class="keyword">SELECT</span> UID,</span><br><span class="line">        date_format(start_time, <span class="string">&#x27;%Y%m&#x27;</span>) <span class="keyword">AS</span> month_d,</span><br><span class="line">        submit_time,</span><br><span class="line">        exam_id,</span><br><span class="line">        <span class="built_in">dense_rank</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> UID</span><br><span class="line">                           <span class="keyword">ORDER</span> <span class="keyword">BY</span> date_format(start_time, <span class="string">&#x27;%Y%m&#x27;</span>) <span class="keyword">DESC</span>) <span class="keyword">AS</span> ranking</span><br><span class="line">   <span class="keyword">FROM</span> exam_record</span><br><span class="line">   <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> user_info <span class="keyword">USING</span> (UID)</span><br><span class="line">   <span class="keyword">WHERE</span> LEVEL <span class="keyword">IN</span> (<span class="number">6</span>,<span class="number">7</span>) ) t1 <span class="keyword">USING</span> (UID)</span><br><span class="line"><span class="keyword">WHERE</span> t1.ranking <span class="operator">&lt;=</span> <span class="number">3</span> <span class="keyword">AND</span> t.ranking <span class="operator">&gt;=</span> <span class="number">0.5</span> <span class="comment">-- 使用限制找到符合条件的记录</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> t1.uid,</span><br><span class="line">         t1.month_d</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> t1.uid,</span><br><span class="line">         t1.month_d</span><br></pre></td></tr></table></figure>

<h3 id="试卷完成数同比-2020-年的增长率及排名变化（困难）"><a href="#试卷完成数同比-2020-年的增长率及排名变化（困难）" class="headerlink" title="试卷完成数同比 2020 年的增长率及排名变化（困难）"></a>试卷完成数同比 2020 年的增长率及排名变化（困难）</h3><p><strong>描述</strong>：</p>
<p>现有试卷信息表 <code>examination_info</code>（<code>exam_id</code> 试卷 ID, <code>tag</code> 试卷类别, <code>difficulty</code> 试卷难度, <code>duration</code> 考试时长, <code>release_time</code> 发布时间）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>exam_id</th>
<th>tag</th>
<th>difficulty</th>
<th>duration</th>
<th>release_time</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>9001</td>
<td>SQL</td>
<td>hard</td>
<td>60</td>
<td>2021-01-01 10:00:00</td>
</tr>
<tr>
<td>2</td>
<td>9002</td>
<td>C++</td>
<td>hard</td>
<td>80</td>
<td>2021-01-01 10:00:00</td>
</tr>
<tr>
<td>3</td>
<td>9003</td>
<td>算法</td>
<td>hard</td>
<td>80</td>
<td>2021-01-01 10:00:00</td>
</tr>
<tr>
<td>4</td>
<td>9004</td>
<td>PYTHON</td>
<td>medium</td>
<td>70</td>
<td>2021-01-01 10:00:00</td>
</tr>
</tbody></table>
<p>试卷作答记录表 <code>exam_record</code>（<code>uid</code> 用户 ID, <code>exam_id</code> 试卷 ID, <code>start_time</code> 开始作答时间, <code>submit_time</code> 交卷时间, <code>score</code> 得分）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>uid</th>
<th>exam_id</th>
<th>start_time</th>
<th>submit_time</th>
<th>score</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1001</td>
<td>9001</td>
<td>2020-08-02 10:01:01</td>
<td>2020-08-02 10:31:01</td>
<td>89</td>
</tr>
<tr>
<td>2</td>
<td>1002</td>
<td>9001</td>
<td>2020-04-01 18:01:01</td>
<td>2020-04-01 18:59:02</td>
<td>90</td>
</tr>
<tr>
<td>3</td>
<td>1001</td>
<td>9001</td>
<td>2020-04-01 09:01:01</td>
<td>2020-04-01 09:21:59</td>
<td>80</td>
</tr>
<tr>
<td>5</td>
<td>1002</td>
<td>9001</td>
<td>2021-03-02 19:01:01</td>
<td>2021-03-02 19:32:00</td>
<td>20</td>
</tr>
<tr>
<td>8</td>
<td>1003</td>
<td>9001</td>
<td>2021-05-02 12:01:01</td>
<td>2021-05-02 12:31:01</td>
<td>98</td>
</tr>
<tr>
<td>13</td>
<td>1003</td>
<td>9001</td>
<td>2020-01-02 10:01:01</td>
<td>2020-01-02 10:31:01</td>
<td>89</td>
</tr>
<tr>
<td>9</td>
<td>1001</td>
<td>9002</td>
<td>2020-02-02 12:01:01</td>
<td>2020-02-02 12:20:01</td>
<td>99</td>
</tr>
<tr>
<td>10</td>
<td>1002</td>
<td>9002</td>
<td>2021-02-02 12:01:01</td>
<td>2020-02-02 12:43:01</td>
<td>81</td>
</tr>
<tr>
<td>11</td>
<td>1001</td>
<td>9002</td>
<td>2020-01-02 19:01:01</td>
<td>2020-01-02 19:59:01</td>
<td>69</td>
</tr>
<tr>
<td>16</td>
<td>1002</td>
<td>9002</td>
<td>2020-02-02 12:01:01</td>
<td></td>
<td></td>
</tr>
<tr>
<td>17</td>
<td>1002</td>
<td>9002</td>
<td>2020-03-02 12:11:01</td>
<td></td>
<td></td>
</tr>
<tr>
<td>18</td>
<td>1001</td>
<td>9002</td>
<td>2021-05-05 18:01:01</td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>1002</td>
<td>9003</td>
<td>2021-01-20 10:01:01</td>
<td>2021-01-20 10:10:01</td>
<td>81</td>
</tr>
<tr>
<td>6</td>
<td>1001</td>
<td>9003</td>
<td>2021-04-02 19:01:01</td>
<td>2021-04-02 19:40:01</td>
<td>89</td>
</tr>
<tr>
<td>15</td>
<td>1002</td>
<td>9003</td>
<td>2021-01-01 18:01:01</td>
<td>2021-01-01 18:59:02</td>
<td>90</td>
</tr>
<tr>
<td>7</td>
<td>1004</td>
<td>9004</td>
<td>2020-05-02 12:01:01</td>
<td>2020-05-02 12:20:01</td>
<td>99</td>
</tr>
<tr>
<td>12</td>
<td>1001</td>
<td>9004</td>
<td>2021-09-02 12:11:01</td>
<td></td>
<td></td>
</tr>
<tr>
<td>14</td>
<td>1002</td>
<td>9004</td>
<td>2020-01-01 12:11:01</td>
<td>2020-01-01 12:31:01</td>
<td>83</td>
</tr>
</tbody></table>
<p>请计算 2021 年上半年各类试卷的做完次数相比 2020 年上半年同期的增长率（百分比格式，保留 1 位小数），以及做完次数排名变化，按增长率和 21 年排名降序输出。</p>
<p>由示例数据结果输出如下：</p>
<table>
<thead>
<tr>
<th>tag</th>
<th>exam_cnt_20</th>
<th>exam_cnt_21</th>
<th>growth_rate</th>
<th>exam_cnt_rank_20</th>
<th>exam_cnt_rank_21</th>
<th>rank_delta</th>
</tr>
</thead>
<tbody><tr>
<td>SQL</td>
<td>3</td>
<td>2</td>
<td>-33.3%</td>
<td>1</td>
<td>2</td>
<td>1</td>
</tr>
</tbody></table>
<p>解释：2020 年上半年有 3 个 tag 有作答完成的记录，分别是 C++、SQL、PYTHON，它们被做完的次数分别是 3、3、2，做完次数排名为 1、1（并列）、3；</p>
<p>2021 年上半年有 2 个 tag 有作答完成的记录，分别是算法、SQL，它们被做完的次数分别是 3、2，做完次数排名为 1、2；具体如下：</p>
<table>
<thead>
<tr>
<th>tag</th>
<th>start_year</th>
<th>exam_cnt</th>
<th>exam_cnt_rank</th>
</tr>
</thead>
<tbody><tr>
<td>C++</td>
<td>2020</td>
<td>3</td>
<td>1</td>
</tr>
<tr>
<td>SQL</td>
<td>2020</td>
<td>3</td>
<td>1</td>
</tr>
<tr>
<td>PYTHON</td>
<td>2020</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>算法</td>
<td>2021</td>
<td>3</td>
<td>1</td>
</tr>
<tr>
<td>SQL</td>
<td>2021</td>
<td>2</td>
<td>2</td>
</tr>
</tbody></table>
<p>因此能输出同比结果的 tag 只有 SQL，从 2020 到 2021 年，做完次数 3&#x3D;&gt;2，减少 33.3%（保留 1 位小数）；排名 1&#x3D;&gt;2，后退 1 名。</p>
<p><strong>思路：</strong></p>
<p>本题难点在于长整型的数据类型要求不能有负号产生，用 cast 函数转换数据类型为 signed。</p>
<p>以及用到的<code>增长率计算公式：(exam_cnt_21-exam_cnt_20)/exam_cnt_20</code></p>
<p>做完次数排名变化（2021 年和 2020 年比排名升了或者降了多少）</p>
<p>计算公式：<code>exam_cnt_rank_21 - exam_cnt_rank_20</code></p>
<p>在 MySQL 中，<code>CAST()</code> 函数用于将一个表达式的数据类型转换为另一个数据类型。它的基本语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CAST</span>(expression <span class="keyword">AS</span> data_type)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将一个字符串转换成整数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CAST</span>(<span class="string">&#x27;123&#x27;</span> <span class="keyword">AS</span> <span class="type">INT</span>);</span><br></pre></td></tr></table></figure>

<p>示例就不一一举例了，这个函数很简单</p>
<p><strong>答案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  tag,</span><br><span class="line">  exam_cnt_20,</span><br><span class="line">  exam_cnt_21,</span><br><span class="line">  concat(</span><br><span class="line">    round(</span><br><span class="line">      <span class="number">100</span> <span class="operator">*</span> (exam_cnt_21 <span class="operator">-</span> exam_cnt_20) <span class="operator">/</span> exam_cnt_20,</span><br><span class="line">      <span class="number">1</span></span><br><span class="line">    ),</span><br><span class="line">    <span class="string">&#x27;%&#x27;</span></span><br><span class="line">  ) <span class="keyword">AS</span> growth_rate,</span><br><span class="line">  exam_cnt_rank_20,</span><br><span class="line">  exam_cnt_rank_21,</span><br><span class="line">  <span class="built_in">cast</span>(exam_cnt_rank_21 <span class="keyword">AS</span> signed) <span class="operator">-</span> <span class="built_in">cast</span>(exam_cnt_rank_20 <span class="keyword">AS</span> signed) <span class="keyword">AS</span> rank_delta</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  (</span><br><span class="line">    #<span class="number">2020</span>年、<span class="number">2021</span>年上半年各类试卷的做完次数和做完次数排名</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">      tag,</span><br><span class="line">      <span class="built_in">count</span>(</span><br><span class="line">        IF (</span><br><span class="line">          date_format(start_time, <span class="string">&#x27;%Y%m%d&#x27;</span>) <span class="keyword">BETWEEN</span> <span class="string">&#x27;20200101&#x27;</span></span><br><span class="line">          <span class="keyword">AND</span> <span class="string">&#x27;20200630&#x27;</span>,</span><br><span class="line">          start_time,</span><br><span class="line">          <span class="keyword">NULL</span></span><br><span class="line">        )</span><br><span class="line">      ) <span class="keyword">AS</span> exam_cnt_20,</span><br><span class="line">      <span class="built_in">count</span>(</span><br><span class="line">        IF (</span><br><span class="line">          <span class="built_in">substring</span>(start_time, <span class="number">1</span>, <span class="number">10</span>) <span class="keyword">BETWEEN</span> <span class="string">&#x27;2021-01-01&#x27;</span></span><br><span class="line">          <span class="keyword">AND</span> <span class="string">&#x27;2021-06-30&#x27;</span>,</span><br><span class="line">          start_time,</span><br><span class="line">          <span class="keyword">NULL</span></span><br><span class="line">        )</span><br><span class="line">      ) <span class="keyword">AS</span> exam_cnt_21,</span><br><span class="line">      <span class="built_in">rank</span>() <span class="keyword">over</span> (</span><br><span class="line">        <span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">          <span class="built_in">count</span>(</span><br><span class="line">            IF (</span><br><span class="line">              date_format(start_time, <span class="string">&#x27;%Y%m%d&#x27;</span>) <span class="keyword">BETWEEN</span> <span class="string">&#x27;20200101&#x27;</span></span><br><span class="line">              <span class="keyword">AND</span> <span class="string">&#x27;20200630&#x27;</span>,</span><br><span class="line">              start_time,</span><br><span class="line">              <span class="keyword">NULL</span></span><br><span class="line">            )</span><br><span class="line">          ) <span class="keyword">DESC</span></span><br><span class="line">      ) <span class="keyword">AS</span> exam_cnt_rank_20,</span><br><span class="line">      <span class="built_in">rank</span>() <span class="keyword">over</span> (</span><br><span class="line">        <span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">          <span class="built_in">count</span>(</span><br><span class="line">            IF (</span><br><span class="line">              <span class="built_in">substring</span>(start_time, <span class="number">1</span>, <span class="number">10</span>) <span class="keyword">BETWEEN</span> <span class="string">&#x27;2021-01-01&#x27;</span></span><br><span class="line">              <span class="keyword">AND</span> <span class="string">&#x27;2021-06-30&#x27;</span>,</span><br><span class="line">              start_time,</span><br><span class="line">              <span class="keyword">NULL</span></span><br><span class="line">            )</span><br><span class="line">          ) <span class="keyword">DESC</span></span><br><span class="line">      ) <span class="keyword">AS</span> exam_cnt_rank_21</span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">      examination_info</span><br><span class="line">      <span class="keyword">JOIN</span> exam_record <span class="keyword">USING</span> (exam_id)</span><br><span class="line">    <span class="keyword">WHERE</span></span><br><span class="line">      submit_time <span class="keyword">IS</span> <span class="keyword">NOT NULL</span></span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">      tag</span><br><span class="line">  ) main</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">  exam_cnt_21 <span class="operator">*</span> exam_cnt_20 <span class="operator">&lt;&gt;</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">  growth_rate <span class="keyword">DESC</span>,</span><br><span class="line">  exam_cnt_rank_21 <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>

<h2 id="聚合窗口函数"><a href="#聚合窗口函数" class="headerlink" title="聚合窗口函数"></a>聚合窗口函数</h2><h3 id="对试卷得分做-min-max-归一化"><a href="#对试卷得分做-min-max-归一化" class="headerlink" title="对试卷得分做 min-max 归一化"></a>对试卷得分做 min-max 归一化</h3><p><strong>描述</strong>：</p>
<p>现有试卷信息表 <code>examination_info</code>（<code>exam_id</code> 试卷 ID, <code>tag</code> 试卷类别, <code>difficulty</code> 试卷难度, <code>duration</code> 考试时长, <code>release_time</code> 发布时间）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>exam_id</th>
<th>tag</th>
<th>difficulty</th>
<th>duration</th>
<th>release_time</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>9001</td>
<td>SQL</td>
<td>hard</td>
<td>60</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>2</td>
<td>9002</td>
<td>C++</td>
<td>hard</td>
<td>80</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>3</td>
<td>9003</td>
<td>算法</td>
<td>hard</td>
<td>80</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>4</td>
<td>9004</td>
<td>PYTHON</td>
<td>medium</td>
<td>70</td>
<td>2020-01-01 10:00:00</td>
</tr>
</tbody></table>
<p>试卷作答记录表 <code>exam_record</code>（<code>uid</code> 用户 ID, <code>exam_id</code> 试卷 ID, <code>start_time</code> 开始作答时间, <code>submit_time</code> 交卷时间, <code>score</code> 得分）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>uid</th>
<th>exam_id</th>
<th>start_time</th>
<th>submit_time</th>
<th>score</th>
</tr>
</thead>
<tbody><tr>
<td>6</td>
<td>1003</td>
<td>9001</td>
<td>2020-01-02 12:01:01</td>
<td>2020-01-02 12:31:01</td>
<td>68</td>
</tr>
<tr>
<td>9</td>
<td>1001</td>
<td>9001</td>
<td>2020-01-02 10:01:01</td>
<td>2020-01-02 10:31:01</td>
<td>89</td>
</tr>
<tr>
<td>1</td>
<td>1001</td>
<td>9001</td>
<td>2020-01-01 09:01:01</td>
<td>2020-01-01 09:21:59</td>
<td>90</td>
</tr>
<tr>
<td>12</td>
<td>1002</td>
<td>9002</td>
<td>2021-05-05 18:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>3</td>
<td>1004</td>
<td>9002</td>
<td>2020-01-01 12:01:01</td>
<td>2020-01-01 12:11:01</td>
<td>60</td>
</tr>
<tr>
<td>2</td>
<td>1003</td>
<td>9002</td>
<td>2020-01-01 19:01:01</td>
<td>2020-01-01 19:30:01</td>
<td>75</td>
</tr>
<tr>
<td>7</td>
<td>1001</td>
<td>9002</td>
<td>2020-01-02 12:01:01</td>
<td>2020-01-02 12:43:01</td>
<td>81</td>
</tr>
<tr>
<td>10</td>
<td>1002</td>
<td>9002</td>
<td>2020-01-01 12:11:01</td>
<td>2020-01-01 12:31:01</td>
<td>83</td>
</tr>
<tr>
<td>4</td>
<td>1003</td>
<td>9002</td>
<td>2020-01-01 12:01:01</td>
<td>2020-01-01 12:41:01</td>
<td>90</td>
</tr>
<tr>
<td>5</td>
<td>1002</td>
<td>9002</td>
<td>2020-01-02 19:01:01</td>
<td>2020-01-02 19:32:00</td>
<td>90</td>
</tr>
<tr>
<td>11</td>
<td>1002</td>
<td>9004</td>
<td>2021-09-06 12:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>8</td>
<td>1001</td>
<td>9005</td>
<td>2020-01-02 12:11:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
</tbody></table>
<p>在物理学及统计学数据计算时，有个概念叫 min-max 标准化，也被称为离差标准化，是对原始数据的线性变换，使结果值映射到[0 - 1]之间。</p>
<p>转换函数为：</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/database/sql/29A377601170AB822322431FCDF7EDFE.png"></p>
<p>请你将用户作答高难度试卷的得分在每份试卷作答记录内执行 min-max 归一化后缩放到[0,100]区间，并输出用户 ID、试卷 ID、归一化后分数平均值；最后按照试卷 ID 升序、归一化分数降序输出。（注：得分区间默认为[0,100]，如果某个试卷作答记录中只有一个得分，那么无需使用公式，归一化并缩放后分数仍为原分数）。</p>
<p>由示例数据结果输出如下：</p>
<table>
<thead>
<tr>
<th>uid</th>
<th>exam_id</th>
<th>avg_new_score</th>
</tr>
</thead>
<tbody><tr>
<td>1001</td>
<td>9001</td>
<td>98</td>
</tr>
<tr>
<td>1003</td>
<td>9001</td>
<td>0</td>
</tr>
<tr>
<td>1002</td>
<td>9002</td>
<td>88</td>
</tr>
<tr>
<td>1003</td>
<td>9002</td>
<td>75</td>
</tr>
<tr>
<td>1001</td>
<td>9002</td>
<td>70</td>
</tr>
<tr>
<td>1004</td>
<td>9002</td>
<td>0</td>
</tr>
</tbody></table>
<p>解释：高难度试卷有 9001、9002、9003；</p>
<p>作答了 9001 的记录有 3 条，分数分别为 68、89、90，按给定公式归一化后分数为：0、95、100，而后两个得分都是用户 1001 作答的，因此用户 1001 对试卷 9001 的新得分为(95+100)&#x2F;2≈98（只保留整数部分），用户 1003 对于试卷 9001 的新得分为 0。最后结果按照试卷 ID 升序、归一化分数降序输出。</p>
<p><strong>思路：</strong></p>
<p>注意点：</p>
<ol>
<li>将高难度的试卷，按每类试卷的得分，利用 max&#x2F;min (col) over()窗口函数求得各组内最大最小值，然后进行归一化公式计算，缩放区间为[0,100]，即 min_max*100</li>
<li>若某类试卷只有一个得分，则无需使用归一化公式，因只有一个分 max_score&#x3D;min_score,score，公式后结果可能会变成 0。</li>
<li>最后结果按 uid、exam_id 分组求归一化后均值，score 为 NULL 的要过滤掉。</li>
</ol>
<p>最后就是仔细看上面公式 （说实话，这题看起来就很绕）</p>
<p><strong>答案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  uid,</span><br><span class="line">  exam_id,</span><br><span class="line">  round(<span class="built_in">sum</span>(min_max) <span class="operator">/</span> <span class="built_in">count</span>(score), <span class="number">0</span>) <span class="keyword">AS</span> avg_new_score</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  (</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">      <span class="operator">*</span>,</span><br><span class="line">      IF (</span><br><span class="line">        max_score <span class="operator">=</span> min_score,</span><br><span class="line">        score,</span><br><span class="line">        (score <span class="operator">-</span> min_score) <span class="operator">/</span> (max_score <span class="operator">-</span> min_score) <span class="operator">*</span> <span class="number">100</span></span><br><span class="line">      ) <span class="keyword">AS</span> min_max</span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">      (</span><br><span class="line">        <span class="keyword">SELECT</span></span><br><span class="line">          uid,</span><br><span class="line">          a.exam_id,</span><br><span class="line">          score,</span><br><span class="line">          <span class="built_in">max</span>(score) <span class="keyword">over</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> a.exam_id) <span class="keyword">AS</span> max_score,</span><br><span class="line">          <span class="built_in">min</span>(score) <span class="keyword">over</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> a.exam_id) <span class="keyword">AS</span> min_score</span><br><span class="line">        <span class="keyword">FROM</span></span><br><span class="line">          exam_record a</span><br><span class="line">          <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> examination_info b <span class="keyword">USING</span> (exam_id)</span><br><span class="line">        <span class="keyword">WHERE</span></span><br><span class="line">          difficulty <span class="operator">=</span> <span class="string">&#x27;hard&#x27;</span></span><br><span class="line">      ) t</span><br><span class="line">    <span class="keyword">WHERE</span></span><br><span class="line">      score <span class="keyword">IS</span> <span class="keyword">NOT NULL</span></span><br><span class="line">  ) t1</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">  uid,</span><br><span class="line">  exam_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">  exam_id <span class="keyword">ASC</span>,</span><br><span class="line">  avg_new_score <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<h3 id="每份试卷每月作答数和截止当月的作答总数"><a href="#每份试卷每月作答数和截止当月的作答总数" class="headerlink" title="每份试卷每月作答数和截止当月的作答总数"></a>每份试卷每月作答数和截止当月的作答总数</h3><p><strong>描述:</strong></p>
<p>现有试卷作答记录表 exam_record（uid 用户 ID, exam_id 试卷 ID, start_time 开始作答时间, submit_time 交卷时间, score 得分）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>uid</th>
<th>exam_id</th>
<th>start_time</th>
<th>submit_time</th>
<th>score</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1001</td>
<td>9001</td>
<td>2020-01-01 09:01:01</td>
<td>2020-01-01 09:21:59</td>
<td>90</td>
</tr>
<tr>
<td>2</td>
<td>1002</td>
<td>9001</td>
<td>2020-01-20 10:01:01</td>
<td>2020-01-20 10:10:01</td>
<td>89</td>
</tr>
<tr>
<td>3</td>
<td>1002</td>
<td>9001</td>
<td>2020-02-01 12:11:01</td>
<td>2020-02-01 12:31:01</td>
<td>83</td>
</tr>
<tr>
<td>4</td>
<td>1003</td>
<td>9001</td>
<td>2020-03-01 19:01:01</td>
<td>2020-03-01 19:30:01</td>
<td>75</td>
</tr>
<tr>
<td>5</td>
<td>1004</td>
<td>9001</td>
<td>2020-03-01 12:01:01</td>
<td>2020-03-01 12:11:01</td>
<td>60</td>
</tr>
<tr>
<td>6</td>
<td>1003</td>
<td>9001</td>
<td>2020-03-01 12:01:01</td>
<td>2020-03-01 12:41:01</td>
<td>90</td>
</tr>
<tr>
<td>7</td>
<td>1002</td>
<td>9001</td>
<td>2020-05-02 19:01:01</td>
<td>2020-05-02 19:32:00</td>
<td>90</td>
</tr>
<tr>
<td>8</td>
<td>1001</td>
<td>9002</td>
<td>2020-01-02 19:01:01</td>
<td>2020-01-02 19:59:01</td>
<td>69</td>
</tr>
<tr>
<td>9</td>
<td>1004</td>
<td>9002</td>
<td>2020-02-02 12:01:01</td>
<td>2020-02-02 12:20:01</td>
<td>99</td>
</tr>
<tr>
<td>10</td>
<td>1003</td>
<td>9002</td>
<td>2020-02-02 12:01:01</td>
<td>2020-02-02 12:31:01</td>
<td>68</td>
</tr>
<tr>
<td>11</td>
<td>1001</td>
<td>9002</td>
<td>2020-02-02 12:01:01</td>
<td>2020-02-02 12:43:01</td>
<td>81</td>
</tr>
<tr>
<td>12</td>
<td>1001</td>
<td>9002</td>
<td>2020-03-02 12:11:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
</tbody></table>
<p>请输出每份试卷每月作答数和截止当月的作答总数。<br>由示例数据结果输出如下：</p>
<table>
<thead>
<tr>
<th>exam_id</th>
<th>start_month</th>
<th>month_cnt</th>
<th>cum_exam_cnt</th>
</tr>
</thead>
<tbody><tr>
<td>9001</td>
<td>202001</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>9001</td>
<td>202002</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>9001</td>
<td>202003</td>
<td>3</td>
<td>6</td>
</tr>
<tr>
<td>9001</td>
<td>202005</td>
<td>1</td>
<td>7</td>
</tr>
<tr>
<td>9002</td>
<td>202001</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>9002</td>
<td>202002</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>9002</td>
<td>202003</td>
<td>1</td>
<td>5</td>
</tr>
</tbody></table>
<p>解释：试卷 9001 在 202001、202002、202003、202005 共 4 个月有被作答记录，每个月被作答数分别为 2、1、3、1，截止当月累积作答总数为 2、3、6、7。</p>
<p><strong>思路：</strong></p>
<p>这题就两个关键点：统计截止当月的作答总数、输出每份试卷每月作答数和截止当月的作答总数</p>
<p>这个是关键<code>**sum(count(*)) over(partition by exam_id order by date_format(start_time,&#39;%Y%m&#39;))**</code></p>
<p><strong>答案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> exam_id,</span><br><span class="line">       date_format(start_time, <span class="string">&#x27;%Y%m&#x27;</span>) <span class="keyword">AS</span> start_month,</span><br><span class="line">       <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">AS</span> month_cnt,</span><br><span class="line">       <span class="built_in">sum</span>(<span class="built_in">count</span>(<span class="operator">*</span>)) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> exam_id</span><br><span class="line">                           <span class="keyword">ORDER</span> <span class="keyword">BY</span> date_format(start_time, <span class="string">&#x27;%Y%m&#x27;</span>)) <span class="keyword">AS</span> cum_exam_cnt</span><br><span class="line"><span class="keyword">FROM</span> exam_record</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> exam_id,</span><br><span class="line">         start_month</span><br></pre></td></tr></table></figure>

<h3 id="每月及截止当月的答题情况（较难）"><a href="#每月及截止当月的答题情况（较难）" class="headerlink" title="每月及截止当月的答题情况（较难）"></a>每月及截止当月的答题情况（较难）</h3><p><strong>描述</strong>：现有试卷作答记录表 <code>exam_record</code>（<code>uid</code> 用户 ID, <code>exam_id</code> 试卷 ID, <code>start_time</code> 开始作答时间, <code>submit_time</code> 交卷时间, <code>score</code> 得分）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>uid</th>
<th>exam_id</th>
<th>start_time</th>
<th>submit_time</th>
<th>score</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1001</td>
<td>9001</td>
<td>2020-01-01 09:01:01</td>
<td>2020-01-01 09:21:59</td>
<td>90</td>
</tr>
<tr>
<td>2</td>
<td>1002</td>
<td>9001</td>
<td>2020-01-20 10:01:01</td>
<td>2020-01-20 10:10:01</td>
<td>89</td>
</tr>
<tr>
<td>3</td>
<td>1002</td>
<td>9001</td>
<td>2020-02-01 12:11:01</td>
<td>2020-02-01 12:31:01</td>
<td>83</td>
</tr>
<tr>
<td>4</td>
<td>1003</td>
<td>9001</td>
<td>2020-03-01 19:01:01</td>
<td>2020-03-01 19:30:01</td>
<td>75</td>
</tr>
<tr>
<td>5</td>
<td>1004</td>
<td>9001</td>
<td>2020-03-01 12:01:01</td>
<td>2020-03-01 12:11:01</td>
<td>60</td>
</tr>
<tr>
<td>6</td>
<td>1003</td>
<td>9001</td>
<td>2020-03-01 12:01:01</td>
<td>2020-03-01 12:41:01</td>
<td>90</td>
</tr>
<tr>
<td>7</td>
<td>1002</td>
<td>9001</td>
<td>2020-05-02 19:01:01</td>
<td>2020-05-02 19:32:00</td>
<td>90</td>
</tr>
<tr>
<td>8</td>
<td>1001</td>
<td>9002</td>
<td>2020-01-02 19:01:01</td>
<td>2020-01-02 19:59:01</td>
<td>69</td>
</tr>
<tr>
<td>9</td>
<td>1004</td>
<td>9002</td>
<td>2020-02-02 12:01:01</td>
<td>2020-02-02 12:20:01</td>
<td>99</td>
</tr>
<tr>
<td>10</td>
<td>1003</td>
<td>9002</td>
<td>2020-02-02 12:01:01</td>
<td>2020-02-02 12:31:01</td>
<td>68</td>
</tr>
<tr>
<td>11</td>
<td>1001</td>
<td>9002</td>
<td>2020-01-02 19:01:01</td>
<td>2020-02-02 12:43:01</td>
<td>81</td>
</tr>
<tr>
<td>12</td>
<td>1001</td>
<td>9002</td>
<td>2020-03-02 12:11:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
</tbody></table>
<p>请输出自从有用户作答记录以来，每月的试卷作答记录中月活用户数、新增用户数、截止当月的单月最大新增用户数、截止当月的累积用户数。结果按月份升序输出。</p>
<p>由示例数据结果输出如下：</p>
<table>
<thead>
<tr>
<th>start_month</th>
<th>mau</th>
<th>month_add_uv</th>
<th>max_month_add_uv</th>
<th>cum_sum_uv</th>
</tr>
</thead>
<tbody><tr>
<td>202001</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>202002</td>
<td>4</td>
<td>2</td>
<td>2</td>
<td>4</td>
</tr>
<tr>
<td>202003</td>
<td>3</td>
<td>0</td>
<td>2</td>
<td>4</td>
</tr>
<tr>
<td>202005</td>
<td>1</td>
<td>0</td>
<td>2</td>
<td>4</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>month</th>
<th>1001</th>
<th>1002</th>
<th>1003</th>
<th>1004</th>
</tr>
</thead>
<tbody><tr>
<td>202001</td>
<td>1</td>
<td>1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>202002</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>202003</td>
<td>1</td>
<td></td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>202005</td>
<td></td>
<td>1</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>由上述矩阵可以看出，2020 年 1 月有 2 个用户活跃（mau&#x3D;2），当月新增用户数为 2；</p>
<p>2020 年 2 月有 4 个用户活跃，当月新增用户数为 2，最大单月新增用户数为 2，当前累积用户数为 4。</p>
<p><strong>思路：</strong></p>
<p>难点：</p>
<p>1.如何求每月新增用户</p>
<p>2.截至当月的答题情况</p>
<p>大致流程：</p>
<p>（1）统计每个人的首次登陆月份 <code>min()</code></p>
<p>（2）统计每月的月活和新增用户数：先得到每个人的首次登陆月份，再对首次登陆月份分组求和是该月份的新增人数</p>
<p>（3）统计截止当月的单月最大新增用户数、截止当月的累积用户数 ，最终按照按月份升序输出</p>
<p><strong>答案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 截止当月的单月最大新增用户数、截止当月的累积用户数，按月份升序输出</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	start_month,</span><br><span class="line">	mau,</span><br><span class="line">	month_add_uv,</span><br><span class="line">	<span class="built_in">max</span>( month_add_uv ) <span class="keyword">over</span> ( <span class="keyword">ORDER</span> <span class="keyword">BY</span> start_month ),</span><br><span class="line">	<span class="built_in">sum</span>( month_add_uv ) <span class="keyword">over</span> ( <span class="keyword">ORDER</span> <span class="keyword">BY</span> start_month )</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	(</span><br><span class="line">	<span class="comment">-- 统计每月的月活和新增用户数</span></span><br><span class="line">	<span class="keyword">SELECT</span></span><br><span class="line">		date_format( a.start_time, <span class="string">&#x27;%Y%m&#x27;</span> ) <span class="keyword">AS</span> start_month,</span><br><span class="line">		<span class="built_in">count</span>( <span class="keyword">DISTINCT</span> a.uid ) <span class="keyword">AS</span> mau,</span><br><span class="line">		<span class="built_in">count</span>( <span class="keyword">DISTINCT</span> b.uid ) <span class="keyword">AS</span> month_add_uv</span><br><span class="line">	<span class="keyword">FROM</span></span><br><span class="line">		exam_record a</span><br><span class="line">		<span class="keyword">LEFT</span> <span class="keyword">JOIN</span> (</span><br><span class="line">         <span class="comment">-- 统计每个人的首次登陆月份</span></span><br><span class="line">		<span class="keyword">SELECT</span> uid, <span class="built_in">min</span>( date_format( start_time, <span class="string">&#x27;%Y%m&#x27;</span> )) <span class="keyword">AS</span> first_month <span class="keyword">FROM</span> exam_record <span class="keyword">GROUP</span> <span class="keyword">BY</span> uid ) b <span class="keyword">ON</span> date_format( a.start_time, <span class="string">&#x27;%Y%m&#x27;</span> ) <span class="operator">=</span> b.first_month</span><br><span class="line">	<span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">		start_month</span><br><span class="line">	) main</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">	start_month</span><br></pre></td></tr></table></figure>

<!-- @include: @article-footer.snippet.md -->

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2024/09/21/string-algorithm-problems/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/09/21/string-algorithm-problems/" itemprop="url">几道常见的字符串算法题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-09-21T19:34:58+08:00">
                2024-09-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2024/09/21/string-algorithm-problems/" class="leancloud_visitors" data-flag-title="几道常见的字符串算法题">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  13 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>作者：wwwxmu</p>
<p>原文地址:<a href="https://www.weiweiblog.cn/13string/">https://www.weiweiblog.cn/13string/</a></p>
</blockquote>
<h2 id="1-KMP-算法"><a href="#1-KMP-算法" class="headerlink" title="1. KMP 算法"></a>1. KMP 算法</h2><p>谈到字符串问题，不得不提的就是 KMP 算法，它是用来解决字符串查找的问题，可以在一个字符串（S）中查找一个子串（W）出现的位置。KMP 算法把字符匹配的时间复杂度缩小到 O(m+n) ,而空间复杂度也只有 O(m)。因为“暴力搜索”的方法会反复回溯主串，导致效率低下，而 KMP 算法可以利用已经部分匹配这个有效信息，保持主串上的指针不回溯，通过修改子串的指针，让模式串尽量地移动到有效的位置。</p>
<p>具体算法细节请参考：</p>
<ul>
<li><a href="https://blog.csdn.net/v_july_v/article/details/7041827">从头到尾彻底理解 KMP:</a></li>
<li><a href="https://www.zhihu.com/question/21923021">如何更好的理解和掌握 KMP 算法?</a></li>
<li><a href="https://blog.sengxian.com/algorithms/kmp">KMP 算法详细解析</a></li>
<li><a href="http://blog.jobbole.com/76611/">图解 KMP 算法</a></li>
<li><a href="https://www.bilibili.com/video/av3246487/?from=search&seid=17173603269940723925">汪都能听懂的 KMP 字符串匹配算法【双语字幕】</a></li>
<li><a href="https://www.bilibili.com/video/av11866460?from=search&seid=12730654434238709250">KMP 字符串匹配算法 1</a></li>
</ul>
<p><strong>除此之外，再来了解一下 BM 算法！</strong></p>
<blockquote>
<p>BM 算法也是一种精确字符串匹配算法，它采用从右向左比较的方法，同时应用到了两种启发式规则，即坏字符规则 和好后缀规则 ，来决定向右跳跃的距离。基本思路就是从右往左进行字符匹配，遇到不匹配的字符后从坏字符表和好后缀表找一个最大的右移值，将模式串右移继续匹配。<br>《字符串匹配的 KMP 算法》:<a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html">http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html</a></p>
</blockquote>
<h2 id="2-替换空格"><a href="#2-替换空格" class="headerlink" title="2. 替换空格"></a>2. 替换空格</h2><blockquote>
<p>剑指 offer：请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为 We Are Happy.则经过替换之后的字符串为 We%20Are%20Happy。</p>
</blockquote>
<p>这里我提供了两种方法：① 常规方法；② 利用 API 解决。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://www.weiweiblog.cn/replacespace/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 第一种方法：常规方法。利用String.charAt(i)以及String.valueOf(char).equals(&quot; &quot;</span></span><br><span class="line"><span class="comment">   * )遍历字符串并判断元素是否为空格。是则替换为&quot;%20&quot;,否则不替换</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">replaceSpace</span><span class="params">(StringBuffer str)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> str.length();</span><br><span class="line">    <span class="comment">// System.out.println(&quot;length=&quot; + length);</span></span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">      <span class="type">char</span> <span class="variable">b</span> <span class="operator">=</span> str.charAt(i);</span><br><span class="line">      <span class="keyword">if</span> (String.valueOf(b).equals(<span class="string">&quot; &quot;</span>)) &#123;</span><br><span class="line">        result.append(<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result.append(b);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.toString();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 第二种方法：利用API替换掉所用空格，一行代码解决问题</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">replaceSpace2</span><span class="params">(StringBuffer str)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> str.toString().replaceAll(<span class="string">&quot;\\s&quot;</span>, <span class="string">&quot;%20&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于替换固定字符（比如空格）的情况，第二种方法其实可以使用 <code>replace</code> 方法替换，性能更好!</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.toString().replace(<span class="string">&quot; &quot;</span>,<span class="string">&quot;%20&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="3-最长公共前缀"><a href="#3-最长公共前缀" class="headerlink" title="3. 最长公共前缀"></a>3. 最长公共前缀</h2><blockquote>
<p>Leetcode: 编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。</p>
</blockquote>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出: &quot;fl&quot;</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">输出: &quot;&quot;</span><br><span class="line">解释: 输入不存在公共前缀。</span><br></pre></td></tr></table></figure>

<p>思路很简单！先利用 Arrays.sort(strs)为数组排序，再将数组第一个元素和最后一个元素的字符从前往后对比即可！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">replaceSpace</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果检查值不合法及就返回空串</span></span><br><span class="line">  <span class="keyword">if</span> (!checkStrs(strs)) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 数组长度</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> strs.length;</span><br><span class="line">  <span class="comment">// 用于保存结果</span></span><br><span class="line">  <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">  <span class="comment">// 给字符串数组的元素按照升序排序(包含数字的话，数字会排在前面)</span></span><br><span class="line">  Arrays.sort(strs);</span><br><span class="line">  <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> strs[<span class="number">0</span>].length();</span><br><span class="line">  <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> strs[len - <span class="number">1</span>].length();</span><br><span class="line">  <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Math.min(m, n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">   <span class="keyword">if</span> (strs[<span class="number">0</span>].charAt(i) == strs[len - <span class="number">1</span>].charAt(i)) &#123;</span><br><span class="line">    res.append(strs[<span class="number">0</span>].charAt(i));</span><br><span class="line">   &#125; <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res.toString();</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkStrs</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (strs != <span class="literal">null</span>) &#123;</span><br><span class="line">   <span class="comment">// 遍历strs检查元素值</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (strs[i] != <span class="literal">null</span> &amp;&amp; strs[i].length() != <span class="number">0</span>) &#123;</span><br><span class="line">     flag = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     flag = <span class="literal">false</span>;</span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> flag;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 测试</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  String[] strs = &#123; <span class="string">&quot;customer&quot;</span>, <span class="string">&quot;car&quot;</span>, <span class="string">&quot;cat&quot;</span> &#125;;</span><br><span class="line">  <span class="comment">// String[] strs = &#123; &quot;customer&quot;, &quot;car&quot;, null &#125;;//空串</span></span><br><span class="line">  <span class="comment">// String[] strs = &#123;&#125;;//空串</span></span><br><span class="line">  <span class="comment">// String[] strs = null;//空串</span></span><br><span class="line">  System.out.println(Main.replaceSpace(strs));<span class="comment">// c</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4-回文串"><a href="#4-回文串" class="headerlink" title="4. 回文串"></a>4. 回文串</h2><h3 id="4-1-最长回文串"><a href="#4-1-最长回文串" class="headerlink" title="4.1. 最长回文串"></a>4.1. 最长回文串</h3><blockquote>
<p>LeetCode: 给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。在构造过程中，请注意区分大小写。比如<code>&quot;Aa&quot;</code>不能当做一个回文字符串。注<br>意:假设字符串的长度不会超过 1010。</p>
<p>回文串：“回文串”是一个正读和反读都一样的字符串，比如“level”或者“noon”等等就是回文串。——百度百科 地址：<a href="https://baike.baidu.com/item/%E5%9B%9E%E6%96%87%E4%B8%B2/1274921?fr=aladdin">https://baike.baidu.com/item/%E5%9B%9E%E6%96%87%E4%B8%B2/1274921?fr=aladdin</a></p>
</blockquote>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">&quot;abccccdd&quot;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">7</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">我们可以构造的最长的回文串是&quot;dccaccd&quot;, 它的长度是 7。</span><br></pre></td></tr></table></figure>

<p>我们上面已经知道了什么是回文串？现在我们考虑一下可以构成回文串的两种情况：</p>
<ul>
<li>字符出现次数为双数的组合</li>
<li><strong>字符出现次数为偶数的组合+单个字符中出现次数最多且为奇数次的字符</strong> （参见 <strong><a href="https://github.com/Snailclimb/JavaGuide/issues/665">issue665</a></strong> ）</li>
</ul>
<p>统计字符出现的次数即可，双数才能构成回文。因为允许中间一个数单独出现，比如“abcba”，所以如果最后有字母落单，总长度可以加 1。首先将字符串转变为字符数组。然后遍历该数组，判断对应字符是否在 hashset 中，如果不在就加进去，如果在就让 count++，然后移除该字符！这样就能找到出现次数为双数的字符个数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://leetcode-cn.com/problems/longest-palindrome/description/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>  <span class="type">int</span> <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 用于存放字符</span></span><br><span class="line">    HashSet&lt;Character&gt; hashset = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Character&gt;();</span><br><span class="line">    <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!hashset.contains(chars[i])) &#123;<span class="comment">// 如果hashset没有该字符就保存进去</span></span><br><span class="line">        hashset.add(chars[i]);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果有,就让count++（说明找到了一个成对的字符），然后把该字符移除</span></span><br><span class="line">        hashset.remove(chars[i]);</span><br><span class="line">        count++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hashset.isEmpty() ? count * <span class="number">2</span> : count * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-验证回文串"><a href="#4-2-验证回文串" class="headerlink" title="4.2. 验证回文串"></a>4.2. 验证回文串</h3><blockquote>
<p>LeetCode: 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明：本题中，我们将空字符串定义为有效的回文串。</p>
</blockquote>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;race a car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://leetcode-cn.com/problems/valid-palindrome/description/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>  <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = s.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">      <span class="comment">// 从头和尾开始向中间遍历</span></span><br><span class="line">      <span class="keyword">if</span> (!Character.isLetterOrDigit(s.charAt(l))) &#123;<span class="comment">// 字符不是字母和数字的情况</span></span><br><span class="line">        l++;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!Character.isLetterOrDigit(s.charAt(r))) &#123;<span class="comment">// 字符不是字母和数字的情况</span></span><br><span class="line">        r--;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 判断二者是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (Character.toLowerCase(s.charAt(l)) != Character.toLowerCase(s.charAt(r)))</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        l++;</span><br><span class="line">        r--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-最长回文子串"><a href="#4-3-最长回文子串" class="headerlink" title="4.3. 最长回文子串"></a>4.3. 最长回文子串</h3><blockquote>
<p>Leetcode: LeetCode: 最长回文子串 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p>
</blockquote>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot;也是一个有效答案。</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;cbbd&quot;</span><br><span class="line">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure>

<p>以某个元素为中心，分别计算偶数长度的回文最大长度和奇数长度的回文最大长度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://leetcode-cn.com/problems/longest-palindromic-substring/description/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> index, len;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() &lt; <span class="number">2</span>)</span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      PalindromeHelper(s, i, i);</span><br><span class="line">      PalindromeHelper(s, i, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substring(index, index + len);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">PalindromeHelper</span><span class="params">(String s, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt; s.length() &amp;&amp; s.charAt(l) == s.charAt(r)) &#123;</span><br><span class="line">      l--;</span><br><span class="line">      r++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; r - l - <span class="number">1</span>) &#123;</span><br><span class="line">      index = l + <span class="number">1</span>;</span><br><span class="line">      len = r - l - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-最长回文子序列"><a href="#4-4-最长回文子序列" class="headerlink" title="4.4. 最长回文子序列"></a>4.4. 最长回文子序列</h3><blockquote>
<p>LeetCode: 最长回文子序列<br>给定一个字符串 s，找到其中最长的回文子序列。可以假设 s 的最大长度为 1000。<br><strong>最长回文子序列和上一题最长回文子串的区别是，子串是字符串中连续的一个序列，而子序列是字符串中保持相对位置的字符序列，例如，”bbbb”可以是字符串”bbbab”的子序列但不是子串。</strong></p>
</blockquote>
<p>给定一个字符串 s，找到其中最长的回文子序列。可以假设 s 的最大长度为 1000。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">&quot;bbbab&quot;</span><br><span class="line">输出:</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p>一个可能的最长回文子序列为 “bbbb”。</p>
<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">&quot;cbbd&quot;</span><br><span class="line">输出:</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>一个可能的最长回文子序列为 “bb”。</p>
<p><strong>动态规划：</strong> <code>dp[i][j] = dp[i+1][j-1] + 2 if s.charAt(i) == s.charAt(j) otherwise, dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1])</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestPalindromeSubseq</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> [][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len][len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len - <span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j &lt; len; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) == s.charAt(j))</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = Math.max(dp[i+<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][len-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-括号匹配深度"><a href="#5-括号匹配深度" class="headerlink" title="5. 括号匹配深度"></a>5. 括号匹配深度</h2><blockquote>
<p>爱奇艺 2018 秋招 Java：<br>一个合法的括号匹配序列有以下定义:</p>
<ol>
<li>空串””是一个合法的括号匹配序列</li>
<li>如果”X”和”Y”都是合法的括号匹配序列,”XY”也是一个合法的括号匹配序列</li>
<li>如果”X”是一个合法的括号匹配序列,那么”(X)”也是一个合法的括号匹配序列</li>
<li>每个合法的括号序列都可以由以上规则生成。</li>
</ol>
<p>例如: “”,”()”,”()()”,”((()))”都是合法的括号序列<br>对于一个合法的括号序列我们又有以下定义它的深度:</p>
<ol>
<li>空串””的深度是 0</li>
<li>如果字符串”X”的深度是 x,字符串”Y”的深度是 y,那么字符串”XY”的深度为 max(x,y)</li>
<li>如果”X”的深度是 x,那么字符串”(X)”的深度是 x+1</li>
</ol>
<p>例如: “()()()”的深度是 1,”((()))”的深度是 3。牛牛现在给你一个合法的括号序列,需要你计算出其深度。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入描述:</span><br><span class="line">输入包括一个合法的括号序列s,s长度length(2 ≤ length ≤ 50),序列中只包含&#x27;(&#x27;和&#x27;)&#x27;。</span><br><span class="line"></span><br><span class="line">输出描述:</span><br><span class="line">输出一个正整数,即这个序列的深度。</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">(())</span><br><span class="line">输出:</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://www.nowcoder.com/test/8246651/summary</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Snailclimb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018年9月6日</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO 求给定合法括号序列的深度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">    <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>, max = <span class="number">0</span>, i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">        cnt++;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        cnt--;</span><br><span class="line">      max = Math.max(max, cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    sc.close();</span><br><span class="line">    System.out.println(max);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="6-把字符串转换成整数"><a href="#6-把字符串转换成整数" class="headerlink" title="6. 把字符串转换成整数"></a>6. 把字符串转换成整数</h2><blockquote>
<p>剑指 offer: 将一个字符串转换成一个整数(实现 Integer.valueOf(string)的功能，但是 string 不符合数字要求时返回 0)，要求不能使用字符串转换整数的库函数。 数值为 0 或者字符串不是一个合法的数值则返回 0。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://www.weiweiblog.cn/strtoint/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">StrToInt</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (str.length() == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span>[] chars = str.toCharArray();</span><br><span class="line">    <span class="comment">// 判断是否存在符号位</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (chars[<span class="number">0</span>] == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">      flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (chars[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">      flag = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> flag &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// 保存结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; chars.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (Character.isDigit(chars[i])) &#123;<span class="comment">// 调用Character.isDigit(char)方法判断是否是数字，是返回True，否则False</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> chars[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        res = res * <span class="number">10</span> + temp;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> flag != <span class="number">2</span> ? res : -res;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;-12312312&quot;</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;使用库函数转换：&quot;</span> + Integer.valueOf(s));</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Main.StrToInt(s);</span><br><span class="line">    System.out.println(<span class="string">&quot;使用自己写的方法转换：&quot;</span> + res);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<!-- @include: @article-footer.snippet.md -->

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2024/09/20/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/09/20/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/" itemprop="url">区间合并</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-09-20T20:06:08+08:00">
                2024-09-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2024/09/20/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/" class="leancloud_visitors" data-flag-title="区间合并">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  169 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="合并两个重叠区间"><a href="#合并两个重叠区间" class="headerlink" title="合并两个重叠区间"></a>合并两个重叠区间</h2><p><a href="https://leetcode.cn/problems/merge-intervals/description/">leetcode 56 合并区间</a><br>排序然后从左到右比较讨论即可</p>
<h2 id="合并两个排好序的数组"><a href="#合并两个排好序的数组" class="headerlink" title="合并两个排好序的数组"></a>合并两个排好序的数组</h2><p>即归并排序中的归并</p>
<p>进一步扩展为多路归并：<a href="https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247490029&idx=1&sn=bba9ddff88d247db310406ee418d5a15&chksm=fd9cb2f2caeb3be4b1f84962677337dcb5884374e5b6b80340834eaff79298d11151da2dd5f7&token=252055586&lang=zh_CN#rd">【多路归并】从朴素优先队列到多路归并</a>、 <a href="https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/">373. 查找和最小的 K 对数字</a>、<a href="https://leetcode.cn/problems/k-th-smallest-prime-fraction/">786. 第 K 个最小的素数分数</a></p>
<p>往往有很多变体，需要对原来有序的数组进行进一步的处理，比如<a href="https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/">373. 查找和最小的 K 对数字</a>, <a href="https://leetcode.cn/problems/k-th-smallest-prime-fraction/">786. 第 K 个最小的素数分数</a> .</p>
<h2 id="求交集"><a href="#求交集" class="headerlink" title="求交集"></a>求交集</h2><p><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/description/">leetcode 452. 用最少数量的箭引爆气球</a><br>同样，排好序，从左到右。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/27/">27</a><a class="extend next" rel="next" href="/page/3/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.gif"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">264</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">34</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">38</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/JayVae" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.zhihu.com/people/shi-hai-jie-35" target="_blank" title="Zhihu">
                      
                        <i class="fa fa-fw fa-globe"></i>Zhihu</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="wechat" target="_blank" title="Wechat">
                      
                        <i class="fa fa-fw fa-globe"></i>Wechat</a>
                  </span>
                
            </div>
          

		  <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=554191378&auto=1&height=66"></iframe>
		  
          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">史海杰</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">722k</span>
  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  







<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    

    







  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("SWULgkVHBjhFp99nBHCr8oHC-gzGzoHsz", "DQQN5XsGzlq3PIf1OSvGvoRR");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
