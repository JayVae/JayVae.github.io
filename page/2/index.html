<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="持续精进">
<meta property="og:type" content="website">
<meta property="og:title" content="Jay&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Jay&#39;s Blog">
<meta property="og:description" content="持续精进">
<meta property="og:locale">
<meta property="article:author" content="史海杰">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>Jay's Blog</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?1dc984dfc86062a60470cc7297fb0653";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




<meta name="generator" content="Hexo 7.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jay's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">知而不行为不知</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-guestbook">
          <a href="/guestbook" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            留言
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2024/09/21/string-algorithm-problems/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/09/21/string-algorithm-problems/" itemprop="url">几道常见的字符串算法题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-09-21T19:34:58+08:00">
                2024-09-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2024/09/21/string-algorithm-problems/" class="leancloud_visitors" data-flag-title="几道常见的字符串算法题">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  13 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>作者：wwwxmu</p>
<p>原文地址:<a href="https://www.weiweiblog.cn/13string/">https://www.weiweiblog.cn/13string/</a></p>
</blockquote>
<h2 id="1-KMP-算法"><a href="#1-KMP-算法" class="headerlink" title="1. KMP 算法"></a>1. KMP 算法</h2><p>谈到字符串问题，不得不提的就是 KMP 算法，它是用来解决字符串查找的问题，可以在一个字符串（S）中查找一个子串（W）出现的位置。KMP 算法把字符匹配的时间复杂度缩小到 O(m+n) ,而空间复杂度也只有 O(m)。因为“暴力搜索”的方法会反复回溯主串，导致效率低下，而 KMP 算法可以利用已经部分匹配这个有效信息，保持主串上的指针不回溯，通过修改子串的指针，让模式串尽量地移动到有效的位置。</p>
<p>具体算法细节请参考：</p>
<ul>
<li><a href="https://blog.csdn.net/v_july_v/article/details/7041827">从头到尾彻底理解 KMP:</a></li>
<li><a href="https://www.zhihu.com/question/21923021">如何更好的理解和掌握 KMP 算法?</a></li>
<li><a href="https://blog.sengxian.com/algorithms/kmp">KMP 算法详细解析</a></li>
<li><a href="http://blog.jobbole.com/76611/">图解 KMP 算法</a></li>
<li><a href="https://www.bilibili.com/video/av3246487/?from=search&seid=17173603269940723925">汪都能听懂的 KMP 字符串匹配算法【双语字幕】</a></li>
<li><a href="https://www.bilibili.com/video/av11866460?from=search&seid=12730654434238709250">KMP 字符串匹配算法 1</a></li>
</ul>
<p><strong>除此之外，再来了解一下 BM 算法！</strong></p>
<blockquote>
<p>BM 算法也是一种精确字符串匹配算法，它采用从右向左比较的方法，同时应用到了两种启发式规则，即坏字符规则 和好后缀规则 ，来决定向右跳跃的距离。基本思路就是从右往左进行字符匹配，遇到不匹配的字符后从坏字符表和好后缀表找一个最大的右移值，将模式串右移继续匹配。<br>《字符串匹配的 KMP 算法》:<a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html">http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html</a></p>
</blockquote>
<h2 id="2-替换空格"><a href="#2-替换空格" class="headerlink" title="2. 替换空格"></a>2. 替换空格</h2><blockquote>
<p>剑指 offer：请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为 We Are Happy.则经过替换之后的字符串为 We%20Are%20Happy。</p>
</blockquote>
<p>这里我提供了两种方法：① 常规方法；② 利用 API 解决。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://www.weiweiblog.cn/replacespace/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 第一种方法：常规方法。利用String.charAt(i)以及String.valueOf(char).equals(&quot; &quot;</span></span><br><span class="line"><span class="comment">   * )遍历字符串并判断元素是否为空格。是则替换为&quot;%20&quot;,否则不替换</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">replaceSpace</span><span class="params">(StringBuffer str)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> str.length();</span><br><span class="line">    <span class="comment">// System.out.println(&quot;length=&quot; + length);</span></span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">      <span class="type">char</span> <span class="variable">b</span> <span class="operator">=</span> str.charAt(i);</span><br><span class="line">      <span class="keyword">if</span> (String.valueOf(b).equals(<span class="string">&quot; &quot;</span>)) &#123;</span><br><span class="line">        result.append(<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result.append(b);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.toString();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 第二种方法：利用API替换掉所用空格，一行代码解决问题</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">replaceSpace2</span><span class="params">(StringBuffer str)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> str.toString().replaceAll(<span class="string">&quot;\\s&quot;</span>, <span class="string">&quot;%20&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于替换固定字符（比如空格）的情况，第二种方法其实可以使用 <code>replace</code> 方法替换，性能更好!</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.toString().replace(<span class="string">&quot; &quot;</span>,<span class="string">&quot;%20&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="3-最长公共前缀"><a href="#3-最长公共前缀" class="headerlink" title="3. 最长公共前缀"></a>3. 最长公共前缀</h2><blockquote>
<p>Leetcode: 编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。</p>
</blockquote>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出: &quot;fl&quot;</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">输出: &quot;&quot;</span><br><span class="line">解释: 输入不存在公共前缀。</span><br></pre></td></tr></table></figure>

<p>思路很简单！先利用 Arrays.sort(strs)为数组排序，再将数组第一个元素和最后一个元素的字符从前往后对比即可！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">replaceSpace</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果检查值不合法及就返回空串</span></span><br><span class="line">  <span class="keyword">if</span> (!checkStrs(strs)) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 数组长度</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> strs.length;</span><br><span class="line">  <span class="comment">// 用于保存结果</span></span><br><span class="line">  <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">  <span class="comment">// 给字符串数组的元素按照升序排序(包含数字的话，数字会排在前面)</span></span><br><span class="line">  Arrays.sort(strs);</span><br><span class="line">  <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> strs[<span class="number">0</span>].length();</span><br><span class="line">  <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> strs[len - <span class="number">1</span>].length();</span><br><span class="line">  <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Math.min(m, n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">   <span class="keyword">if</span> (strs[<span class="number">0</span>].charAt(i) == strs[len - <span class="number">1</span>].charAt(i)) &#123;</span><br><span class="line">    res.append(strs[<span class="number">0</span>].charAt(i));</span><br><span class="line">   &#125; <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res.toString();</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkStrs</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (strs != <span class="literal">null</span>) &#123;</span><br><span class="line">   <span class="comment">// 遍历strs检查元素值</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (strs[i] != <span class="literal">null</span> &amp;&amp; strs[i].length() != <span class="number">0</span>) &#123;</span><br><span class="line">     flag = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     flag = <span class="literal">false</span>;</span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> flag;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 测试</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  String[] strs = &#123; <span class="string">&quot;customer&quot;</span>, <span class="string">&quot;car&quot;</span>, <span class="string">&quot;cat&quot;</span> &#125;;</span><br><span class="line">  <span class="comment">// String[] strs = &#123; &quot;customer&quot;, &quot;car&quot;, null &#125;;//空串</span></span><br><span class="line">  <span class="comment">// String[] strs = &#123;&#125;;//空串</span></span><br><span class="line">  <span class="comment">// String[] strs = null;//空串</span></span><br><span class="line">  System.out.println(Main.replaceSpace(strs));<span class="comment">// c</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4-回文串"><a href="#4-回文串" class="headerlink" title="4. 回文串"></a>4. 回文串</h2><h3 id="4-1-最长回文串"><a href="#4-1-最长回文串" class="headerlink" title="4.1. 最长回文串"></a>4.1. 最长回文串</h3><blockquote>
<p>LeetCode: 给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。在构造过程中，请注意区分大小写。比如<code>&quot;Aa&quot;</code>不能当做一个回文字符串。注<br>意:假设字符串的长度不会超过 1010。</p>
<p>回文串：“回文串”是一个正读和反读都一样的字符串，比如“level”或者“noon”等等就是回文串。——百度百科 地址：<a href="https://baike.baidu.com/item/%E5%9B%9E%E6%96%87%E4%B8%B2/1274921?fr=aladdin">https://baike.baidu.com/item/%E5%9B%9E%E6%96%87%E4%B8%B2/1274921?fr=aladdin</a></p>
</blockquote>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">&quot;abccccdd&quot;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">7</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">我们可以构造的最长的回文串是&quot;dccaccd&quot;, 它的长度是 7。</span><br></pre></td></tr></table></figure>

<p>我们上面已经知道了什么是回文串？现在我们考虑一下可以构成回文串的两种情况：</p>
<ul>
<li>字符出现次数为双数的组合</li>
<li><strong>字符出现次数为偶数的组合+单个字符中出现次数最多且为奇数次的字符</strong> （参见 <strong><a href="https://github.com/Snailclimb/JavaGuide/issues/665">issue665</a></strong> ）</li>
</ul>
<p>统计字符出现的次数即可，双数才能构成回文。因为允许中间一个数单独出现，比如“abcba”，所以如果最后有字母落单，总长度可以加 1。首先将字符串转变为字符数组。然后遍历该数组，判断对应字符是否在 hashset 中，如果不在就加进去，如果在就让 count++，然后移除该字符！这样就能找到出现次数为双数的字符个数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://leetcode-cn.com/problems/longest-palindrome/description/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>  <span class="type">int</span> <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 用于存放字符</span></span><br><span class="line">    HashSet&lt;Character&gt; hashset = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Character&gt;();</span><br><span class="line">    <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!hashset.contains(chars[i])) &#123;<span class="comment">// 如果hashset没有该字符就保存进去</span></span><br><span class="line">        hashset.add(chars[i]);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果有,就让count++（说明找到了一个成对的字符），然后把该字符移除</span></span><br><span class="line">        hashset.remove(chars[i]);</span><br><span class="line">        count++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hashset.isEmpty() ? count * <span class="number">2</span> : count * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-验证回文串"><a href="#4-2-验证回文串" class="headerlink" title="4.2. 验证回文串"></a>4.2. 验证回文串</h3><blockquote>
<p>LeetCode: 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明：本题中，我们将空字符串定义为有效的回文串。</p>
</blockquote>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;race a car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://leetcode-cn.com/problems/valid-palindrome/description/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>  <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = s.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">      <span class="comment">// 从头和尾开始向中间遍历</span></span><br><span class="line">      <span class="keyword">if</span> (!Character.isLetterOrDigit(s.charAt(l))) &#123;<span class="comment">// 字符不是字母和数字的情况</span></span><br><span class="line">        l++;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!Character.isLetterOrDigit(s.charAt(r))) &#123;<span class="comment">// 字符不是字母和数字的情况</span></span><br><span class="line">        r--;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 判断二者是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (Character.toLowerCase(s.charAt(l)) != Character.toLowerCase(s.charAt(r)))</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        l++;</span><br><span class="line">        r--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-最长回文子串"><a href="#4-3-最长回文子串" class="headerlink" title="4.3. 最长回文子串"></a>4.3. 最长回文子串</h3><blockquote>
<p>Leetcode: LeetCode: 最长回文子串 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p>
</blockquote>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot;也是一个有效答案。</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;cbbd&quot;</span><br><span class="line">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure>

<p>以某个元素为中心，分别计算偶数长度的回文最大长度和奇数长度的回文最大长度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://leetcode-cn.com/problems/longest-palindromic-substring/description/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> index, len;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() &lt; <span class="number">2</span>)</span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      PalindromeHelper(s, i, i);</span><br><span class="line">      PalindromeHelper(s, i, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substring(index, index + len);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">PalindromeHelper</span><span class="params">(String s, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt; s.length() &amp;&amp; s.charAt(l) == s.charAt(r)) &#123;</span><br><span class="line">      l--;</span><br><span class="line">      r++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; r - l - <span class="number">1</span>) &#123;</span><br><span class="line">      index = l + <span class="number">1</span>;</span><br><span class="line">      len = r - l - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-最长回文子序列"><a href="#4-4-最长回文子序列" class="headerlink" title="4.4. 最长回文子序列"></a>4.4. 最长回文子序列</h3><blockquote>
<p>LeetCode: 最长回文子序列<br>给定一个字符串 s，找到其中最长的回文子序列。可以假设 s 的最大长度为 1000。<br><strong>最长回文子序列和上一题最长回文子串的区别是，子串是字符串中连续的一个序列，而子序列是字符串中保持相对位置的字符序列，例如，”bbbb”可以是字符串”bbbab”的子序列但不是子串。</strong></p>
</blockquote>
<p>给定一个字符串 s，找到其中最长的回文子序列。可以假设 s 的最大长度为 1000。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">&quot;bbbab&quot;</span><br><span class="line">输出:</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p>一个可能的最长回文子序列为 “bbbb”。</p>
<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">&quot;cbbd&quot;</span><br><span class="line">输出:</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>一个可能的最长回文子序列为 “bb”。</p>
<p><strong>动态规划：</strong> <code>dp[i][j] = dp[i+1][j-1] + 2 if s.charAt(i) == s.charAt(j) otherwise, dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1])</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestPalindromeSubseq</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> [][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len][len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len - <span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j &lt; len; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) == s.charAt(j))</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = Math.max(dp[i+<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][len-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-括号匹配深度"><a href="#5-括号匹配深度" class="headerlink" title="5. 括号匹配深度"></a>5. 括号匹配深度</h2><blockquote>
<p>爱奇艺 2018 秋招 Java：<br>一个合法的括号匹配序列有以下定义:</p>
<ol>
<li>空串””是一个合法的括号匹配序列</li>
<li>如果”X”和”Y”都是合法的括号匹配序列,”XY”也是一个合法的括号匹配序列</li>
<li>如果”X”是一个合法的括号匹配序列,那么”(X)”也是一个合法的括号匹配序列</li>
<li>每个合法的括号序列都可以由以上规则生成。</li>
</ol>
<p>例如: “”,”()”,”()()”,”((()))”都是合法的括号序列<br>对于一个合法的括号序列我们又有以下定义它的深度:</p>
<ol>
<li>空串””的深度是 0</li>
<li>如果字符串”X”的深度是 x,字符串”Y”的深度是 y,那么字符串”XY”的深度为 max(x,y)</li>
<li>如果”X”的深度是 x,那么字符串”(X)”的深度是 x+1</li>
</ol>
<p>例如: “()()()”的深度是 1,”((()))”的深度是 3。牛牛现在给你一个合法的括号序列,需要你计算出其深度。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入描述:</span><br><span class="line">输入包括一个合法的括号序列s,s长度length(2 ≤ length ≤ 50),序列中只包含&#x27;(&#x27;和&#x27;)&#x27;。</span><br><span class="line"></span><br><span class="line">输出描述:</span><br><span class="line">输出一个正整数,即这个序列的深度。</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">(())</span><br><span class="line">输出:</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://www.nowcoder.com/test/8246651/summary</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Snailclimb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018年9月6日</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO 求给定合法括号序列的深度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">    <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>, max = <span class="number">0</span>, i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">        cnt++;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        cnt--;</span><br><span class="line">      max = Math.max(max, cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    sc.close();</span><br><span class="line">    System.out.println(max);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="6-把字符串转换成整数"><a href="#6-把字符串转换成整数" class="headerlink" title="6. 把字符串转换成整数"></a>6. 把字符串转换成整数</h2><blockquote>
<p>剑指 offer: 将一个字符串转换成一个整数(实现 Integer.valueOf(string)的功能，但是 string 不符合数字要求时返回 0)，要求不能使用字符串转换整数的库函数。 数值为 0 或者字符串不是一个合法的数值则返回 0。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://www.weiweiblog.cn/strtoint/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">StrToInt</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (str.length() == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span>[] chars = str.toCharArray();</span><br><span class="line">    <span class="comment">// 判断是否存在符号位</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (chars[<span class="number">0</span>] == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">      flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (chars[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">      flag = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> flag &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// 保存结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; chars.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (Character.isDigit(chars[i])) &#123;<span class="comment">// 调用Character.isDigit(char)方法判断是否是数字，是返回True，否则False</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> chars[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        res = res * <span class="number">10</span> + temp;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> flag != <span class="number">2</span> ? res : -res;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;-12312312&quot;</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;使用库函数转换：&quot;</span> + Integer.valueOf(s));</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Main.StrToInt(s);</span><br><span class="line">    System.out.println(<span class="string">&quot;使用自己写的方法转换：&quot;</span> + res);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<!-- @include: @article-footer.snippet.md -->

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2024/09/17/message-queue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/09/17/message-queue/" itemprop="url">消息队列基础知识总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-09-17T23:04:05+08:00">
                2024-09-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" itemprop="url" rel="index">
                    <span itemprop="name">消息队列</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2024/09/17/message-queue/" class="leancloud_visitors" data-flag-title="消息队列基础知识总结">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  6.3k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  21 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>::: tip</p>
<p>这篇文章中的消息队列主要指的是分布式消息队列。</p>
<p>:::</p>
<p>“RabbitMQ？”“Kafka？”“RocketMQ？”…在日常学习与开发过程中，我们常常听到消息队列这个关键词。我也在我的多篇文章中提到了这个概念。可能你是熟练使用消息队列的老手，又或者你是不懂消息队列的新手，不论你了不了解消息队列，本文都将带你搞懂消息队列的一些基本理论。</p>
<p>如果你是老手，你可能从本文学到你之前不曾注意的一些关于消息队列的重要概念，如果你是新手，相信本文将是你打开消息队列大门的一板砖。</p>
<h2 id="什么是消息队列？"><a href="#什么是消息队列？" class="headerlink" title="什么是消息队列？"></a>什么是消息队列？</h2><p>我们可以把消息队列看作是一个存放消息的容器，当我们需要使用消息的时候，直接从容器中取出消息供自己使用即可。由于队列 Queue 是一种先进先出的数据结构，所以消费消息时也是按照顺序来消费的。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/message-queue-small.png"></p>
<p>参与消息传递的双方称为 <strong>生产者</strong> 和 <strong>消费者</strong> ，生产者负责发送消息，消费者负责处理消息。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/message-queue-pub-sub-model.png" alt="发布/订阅（Pub/Sub）模型"></p>
<p>操作系统中的进程通信的一种很重要的方式就是消息队列。我们这里提到的消息队列稍微有点区别，更多指的是各个服务以及系统内部各个组件&#x2F;模块之前的通信，属于一种 <strong>中间件</strong> 。</p>
<p>维基百科是这样介绍中间件的：</p>
<blockquote>
<p>中间件（英语：Middleware），又译中间件、中介层，是一类提供系统软件和应用软件之间连接、便于软件各部件之间的沟通的软件，应用软件可以借助中间件在不同的技术架构之间共享信息与资源。中间件位于客户机服务器的操作系统之上，管理着计算资源和网络通信。</p>
</blockquote>
<p>简单来说：<strong>中间件就是一类为应用软件服务的软件，应用软件是为用户服务的，用户不会接触或者使用到中间件。</strong></p>
<p>除了消息队列之外，常见的中间件还有 RPC 框架、分布式组件、HTTP 服务器、任务调度框架、配置中心、数据库层的分库分表工具和数据迁移工具等等。</p>
<p>关于中间件比较详细的介绍可以参考阿里巴巴淘系技术的一篇回答：<a href="https://www.zhihu.com/question/19730582/answer/1663627873">https://www.zhihu.com/question/19730582/answer/1663627873</a> 。</p>
<p>随着分布式和微服务系统的发展，消息队列在系统设计中有了更大的发挥空间，使用消息队列可以降低系统耦合性、实现任务异步、有效地进行流量削峰，是分布式和微服务系统中重要的组件之一。</p>
<h2 id="消息队列有什么用？"><a href="#消息队列有什么用？" class="headerlink" title="消息队列有什么用？"></a>消息队列有什么用？</h2><p>通常来说，使用消息队列主要能为我们的系统带来下面三点好处：</p>
<ol>
<li>异步处理</li>
<li>削峰&#x2F;限流</li>
<li>降低系统耦合性</li>
</ol>
<p>除了这三点之外，消息队列还有其他的一些应用场景，例如实现分布式事务、顺序保证和数据流处理。</p>
<p>如果在面试的时候你被面试官问到这个问题的话，一般情况是你在你的简历上涉及到消息队列这方面的内容，这个时候推荐你结合你自己的项目来回答。</p>
<h3 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h3><p><img src="https://oss.javaguide.cn/github/javaguide/Asynchronous-message-queue.png" alt="通过异步处理提高系统性能"></p>
<p>将用户请求中包含的耗时操作，通过消息队列实现异步处理，将对应的消息发送到消息队列之后就立即返回结果，减少响应时间，提高用户体验。随后，系统再对消息进行消费。</p>
<p>因为用户请求数据写入消息队列之后就立即返回给用户了，但是请求数据在后续的业务校验、写数据库等操作中可能失败。因此，<strong>使用消息队列进行异步处理之后，需要适当修改业务流程进行配合</strong>，比如用户在提交订单之后，订单数据写入消息队列，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功，以免交易纠纷。这就类似我们平时手机订火车票和电影票。</p>
<h3 id="削峰-限流"><a href="#削峰-限流" class="headerlink" title="削峰&#x2F;限流"></a>削峰&#x2F;限流</h3><p><strong>先将短时间高并发产生的事务消息存储在消息队列中，然后后端服务再慢慢根据自己的能力去消费这些消息，这样就避免直接把后端服务打垮掉。</strong></p>
<p>举例：在电子商务一些秒杀、促销活动中，合理使用消息队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击。如下图所示：</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/%E5%89%8A%E5%B3%B0-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.png" alt="削峰"></p>
<h3 id="降低系统耦合性"><a href="#降低系统耦合性" class="headerlink" title="降低系统耦合性"></a>降低系统耦合性</h3><p>使用消息队列还可以降低系统耦合性。如果模块之间不存在直接调用，那么新增模块或者修改模块就对其他模块影响较小，这样系统的可扩展性无疑更好一些。</p>
<p>生产者（客户端）发送消息到消息队列中去，消费者（服务端）处理消息，需要消费的系统直接去消息队列取消息进行消费即可而不需要和其他系统有耦合，这显然也提高了系统的扩展性。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/message-queue-pub-sub-model.png" alt="发布/订阅（Pub/Sub）模型"></p>
<p><strong>消息队列使用发布-订阅模式工作，消息发送者（生产者）发布消息，一个或多个消息接受者（消费者）订阅消息。</strong> 从上图可以看到<strong>消息发送者（生产者）和消息接受者（消费者）之间没有直接耦合</strong>，消息发送者将消息发送至分布式消息队列即结束对消息的处理，消息接受者从分布式消息队列获取该消息后进行后续处理，并不需要知道该消息从何而来。<strong>对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展性设计</strong>。</p>
<p>例如，我们商城系统分为用户、订单、财务、仓储、消息通知、物流、风控等多个服务。用户在完成下单后，需要调用财务（扣款）、仓储（库存管理）、物流（发货）、消息通知（通知用户发货）、风控（风险评估）等服务。使用消息队列后，下单操作和后续的扣款、发货、通知等操作就解耦了，下单完成发送一个消息到消息队列，需要用到的地方去订阅这个消息进行消息即可。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/message-queue-decouple-mall-example.png"></p>
<p>另外，为了避免消息队列服务器宕机造成消息丢失，会将成功发送到消息队列的消息存储在消息生产者服务器上，等消息真正被消费者服务器处理后才删除消息。在消息队列服务器宕机后，生产者服务器会选择分布式消息队列服务器集群中的其他服务器发布消息。</p>
<p><strong>备注：</strong> 不要认为消息队列只能利用发布-订阅模式工作，只不过在解耦这个特定业务环境下是使用发布-订阅模式的。除了发布-订阅模式，还有点对点订阅模式（一个消息只有一个消费者），我们比较常用的是发布-订阅模式。另外，这两种消息模型是 JMS 提供的，AMQP 协议还提供了另外 5 种消息模型。</p>
<h3 id="实现分布式事务"><a href="#实现分布式事务" class="headerlink" title="实现分布式事务"></a>实现分布式事务</h3><p>分布式事务的解决方案之一就是 MQ 事务。</p>
<p>RocketMQ、 Kafka、Pulsar、QMQ 都提供了事务相关的功能。事务允许事件流应用将消费，处理，生产消息整个过程定义为一个原子操作。</p>
<p>详细介绍可以查看 <a href="https://javaguide.cn/distributed-system/distributed-transaction.html">分布式事务详解(付费)</a> 这篇文章。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/csdn/07b338324a7d8894b8aef4b659b76d92.png" alt="分布式事务详解 - MQ事务"></p>
<h3 id="顺序保证"><a href="#顺序保证" class="headerlink" title="顺序保证"></a>顺序保证</h3><p>在很多应用场景中，处理数据的顺序至关重要。消息队列保证数据按照特定的顺序被处理，适用于那些对数据顺序有严格要求的场景。大部分消息队列，例如 RocketMQ、RabbitMQ、Pulsar、Kafka，都支持顺序消息。</p>
<h3 id="延时-定时处理"><a href="#延时-定时处理" class="headerlink" title="延时&#x2F;定时处理"></a>延时&#x2F;定时处理</h3><p>消息发送后不会立即被消费，而是指定一个时间，到时间后再消费。大部分消息队列，例如 RocketMQ、RabbitMQ、Pulsar、Kafka，都支持定时&#x2F;延时消息。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/tools/docker/rocketmq-schedule-message.png"></p>
<h3 id="即时通讯"><a href="#即时通讯" class="headerlink" title="即时通讯"></a>即时通讯</h3><p>MQTT（消息队列遥测传输协议）是一种轻量级的通讯协议，采用发布&#x2F;订阅模式，非常适合于物联网（IoT）等需要在低带宽、高延迟或不可靠网络环境下工作的应用。它支持即时消息传递，即使在网络条件较差的情况下也能保持通信的稳定性。</p>
<p>RabbitMQ 内置了 MQTT 插件用于实现 MQTT 功能（默认不启用，需要手动开启）。</p>
<h3 id="数据流处理"><a href="#数据流处理" class="headerlink" title="数据流处理"></a>数据流处理</h3><p>针对分布式系统产生的海量数据流，如业务日志、监控数据、用户行为等，消息队列可以实时或批量收集这些数据，并将其导入到大数据处理引擎中，实现高效的数据流管理和处理。</p>
<h2 id="使用消息队列会带来哪些问题？"><a href="#使用消息队列会带来哪些问题？" class="headerlink" title="使用消息队列会带来哪些问题？"></a>使用消息队列会带来哪些问题？</h2><ul>
<li><strong>系统可用性降低：</strong> 系统可用性在某种程度上降低，为什么这样说呢？在加入 MQ 之前，你不用考虑消息丢失或者说 MQ 挂掉等等的情况，但是，引入 MQ 之后你就需要去考虑了！</li>
<li><strong>系统复杂性提高：</strong> 加入 MQ 之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题！</li>
<li><strong>一致性问题：</strong> 我上面讲了消息队列可以实现异步，消息队列带来的异步确实可以提高系统响应速度。但是，万一消息的真正消费者并没有正确消费消息怎么办？这样就会导致数据不一致的情况了!</li>
</ul>
<h2 id="JMS-和-AMQP"><a href="#JMS-和-AMQP" class="headerlink" title="JMS 和 AMQP"></a>JMS 和 AMQP</h2><h3 id="JMS-是什么？"><a href="#JMS-是什么？" class="headerlink" title="JMS 是什么？"></a>JMS 是什么？</h3><p>JMS（JAVA Message Service,java 消息服务）是 Java 的消息服务，JMS 的客户端之间可以通过 JMS 服务进行异步的消息传输。<strong>JMS（JAVA Message Service，Java 消息服务）API 是一个消息服务的标准或者说是规范</strong>，允许应用程序组件基于 JavaEE 平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。</p>
<p>JMS 定义了五种不同的消息正文格式以及调用的消息类型，允许你发送并接收以一些不同形式的数据：</p>
<ul>
<li><code>StreamMessage：Java</code> 原始值的数据流</li>
<li><code>MapMessage</code>：一套名称-值对</li>
<li><code>TextMessage</code>：一个字符串对象</li>
<li><code>ObjectMessage</code>：一个序列化的 Java 对象</li>
<li><code>BytesMessage</code>：一个字节的数据流</li>
</ul>
<p><strong>ActiveMQ（已被淘汰） 就是基于 JMS 规范实现的。</strong></p>
<h3 id="JMS-两种消息模型"><a href="#JMS-两种消息模型" class="headerlink" title="JMS 两种消息模型"></a>JMS 两种消息模型</h3><h4 id="点到点（P2P）模型"><a href="#点到点（P2P）模型" class="headerlink" title="点到点（P2P）模型"></a>点到点（P2P）模型</h4><p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/message-queue-queue-model.png" alt="队列模型"></p>
<p>使用<strong>队列（Queue）</strong>作为消息通信载体；满足<strong>生产者与消费者模式</strong>，一条消息只能被一个消费者使用，未被消费的消息在队列中保留直到被消费或超时。比如：我们生产者发送 100 条消息的话，两个消费者来消费一般情况下两个消费者会按照消息发送的顺序各自消费一半（也就是你一个我一个的消费。）</p>
<h4 id="发布-订阅（Pub-Sub）模型"><a href="#发布-订阅（Pub-Sub）模型" class="headerlink" title="发布&#x2F;订阅（Pub&#x2F;Sub）模型"></a>发布&#x2F;订阅（Pub&#x2F;Sub）模型</h4><p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/message-queue-pub-sub-model.png" alt="发布/订阅（Pub/Sub）模型"></p>
<p>发布订阅模型（Pub&#x2F;Sub） 使用<strong>主题（Topic）</strong>作为消息通信载体，类似于<strong>广播模式</strong>；发布者发布一条消息，该消息通过主题传递给所有的订阅者。</p>
<h3 id="AMQP-是什么？"><a href="#AMQP-是什么？" class="headerlink" title="AMQP 是什么？"></a>AMQP 是什么？</h3><p>AMQP，即 Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准 <strong>高级消息队列协议</strong>（二进制应用层协议），是应用层协议的一个开放标准，为面向消息的中间件设计，兼容 JMS。基于此协议的客户端与消息中间件可传递消息，并不受客户端&#x2F;中间件同产品，不同的开发语言等条件的限制。</p>
<p><strong>RabbitMQ 就是基于 AMQP 协议实现的。</strong></p>
<h3 id="JMS-vs-AMQP"><a href="#JMS-vs-AMQP" class="headerlink" title="JMS vs AMQP"></a>JMS vs AMQP</h3><table>
<thead>
<tr>
<th align="center">对比方向</th>
<th align="left">JMS</th>
<th align="left">AMQP</th>
</tr>
</thead>
<tbody><tr>
<td align="center">定义</td>
<td align="left">Java API</td>
<td align="left">协议</td>
</tr>
<tr>
<td align="center">跨语言</td>
<td align="left">否</td>
<td align="left">是</td>
</tr>
<tr>
<td align="center">跨平台</td>
<td align="left">否</td>
<td align="left">是</td>
</tr>
<tr>
<td align="center">支持消息类型</td>
<td align="left">提供两种消息模型：①Peer-2-Peer;②Pub&#x2F;sub</td>
<td align="left">提供了五种消息模型：①direct exchange；②fanout exchange；③topic change；④headers exchange；⑤system exchange。本质来讲，后四种和 JMS 的 pub&#x2F;sub 模型没有太大差别，仅是在路由机制上做了更详细的划分；</td>
</tr>
<tr>
<td align="center">支持消息类型</td>
<td align="left">支持多种消息类型 ，我们在上面提到过</td>
<td align="left">byte[]（二进制）</td>
</tr>
</tbody></table>
<p><strong>总结：</strong></p>
<ul>
<li>AMQP 为消息定义了线路层（wire-level protocol）的协议，而 JMS 所定义的是 API 规范。在 Java 体系中，多个 client 均可以通过 JMS 进行交互，不需要应用修改代码，但是其对跨平台的支持较差。而 AMQP 天然具有跨平台、跨语言特性。</li>
<li>JMS 支持 <code>TextMessage</code>、<code>MapMessage</code> 等复杂的消息类型；而 AMQP 仅支持 <code>byte[]</code> 消息类型（复杂的类型可序列化后发送）。</li>
<li>由于 Exchange 提供的路由算法，AMQP 可以提供多样化的路由方式来传递消息到消息队列，而 JMS 仅支持 队列 和 主题&#x2F;订阅 方式两种。</li>
</ul>
<h2 id="RPC-和消息队列的区别"><a href="#RPC-和消息队列的区别" class="headerlink" title="RPC 和消息队列的区别"></a>RPC 和消息队列的区别</h2><p>RPC 和消息队列都是分布式微服务系统中重要的组件之一，下面我们来简单对比一下两者：</p>
<ul>
<li><strong>从用途来看</strong>：RPC 主要用来解决两个服务的远程通信问题，不需要了解底层网络的通信机制。通过 RPC 可以帮助我们调用远程计算机上某个服务的方法，这个过程就像调用本地方法一样简单。消息队列主要用来降低系统耦合性、实现任务异步、有效地进行流量削峰。</li>
<li><strong>从通信方式来看</strong>：RPC 是双向直接网络通讯，消息队列是单向引入中间载体的网络通讯。</li>
<li><strong>从架构上来看</strong>：消息队列需要把消息存储起来，RPC 则没有这个要求，因为前面也说了 RPC 是双向直接网络通讯。</li>
<li><strong>从请求处理的时效性来看</strong>：通过 RPC 发出的调用一般会立即被处理，存放在消息队列中的消息并不一定会立即被处理。</li>
</ul>
<p>RPC 和消息队列本质上是网络通讯的两种不同的实现机制，两者的用途不同，万不可将两者混为一谈。</p>
<h2 id="分布式消息队列技术选型"><a href="#分布式消息队列技术选型" class="headerlink" title="分布式消息队列技术选型"></a>分布式消息队列技术选型</h2><h3 id="常见的消息队列有哪些？"><a href="#常见的消息队列有哪些？" class="headerlink" title="常见的消息队列有哪些？"></a>常见的消息队列有哪些？</h3><h4 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h4><p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/kafka-logo.png"></p>
<p>Kafka 是 LinkedIn 开源的一个分布式流式处理平台，已经成为 Apache 顶级项目，早期被用来用于处理海量的日志，后面才慢慢发展成了一款功能全面的高性能消息队列。</p>
<p>流式处理平台具有三个关键功能：</p>
<ol>
<li><strong>消息队列</strong>：发布和订阅消息流，这个功能类似于消息队列，这也是 Kafka 也被归类为消息队列的原因。</li>
<li><strong>容错的持久方式存储记录消息流</strong>：Kafka 会把消息持久化到磁盘，有效避免了消息丢失的风险。</li>
<li><strong>流式处理平台：</strong> 在消息发布的时候进行处理，Kafka 提供了一个完整的流式处理类库。</li>
</ol>
<p>Kafka 是一个分布式系统，由通过高性能 TCP 网络协议进行通信的服务器和客户端组成，可以部署在在本地和云环境中的裸机硬件、虚拟机和容器上。</p>
<p>在 Kafka 2.8 之前，Kafka 最被大家诟病的就是其重度依赖于 Zookeeper 做元数据管理和集群的高可用。在 Kafka 2.8 之后，引入了基于 Raft 协议的 KRaft 模式，不再依赖 Zookeeper，大大简化了 Kafka 的架构，让你可以以一种轻量级的方式来使用 Kafka。</p>
<p>不过，要提示一下：<strong>如果要使用 KRaft 模式的话，建议选择较高版本的 Kafka，因为这个功能还在持续完善优化中。Kafka 3.3.1 版本是第一个将 KRaft（Kafka Raft）共识协议标记为生产就绪的版本。</strong></p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/kafka3.3.1-kraft-%20production-ready.png"></p>
<p>Kafka 官网：<a href="http://kafka.apache.org/">http://kafka.apache.org/</a></p>
<p>Kafka 更新记录（可以直观看到项目是否还在维护）：<a href="https://kafka.apache.org/downloads">https://kafka.apache.org/downloads</a></p>
<h4 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h4><p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/rocketmq-logo.png"></p>
<p>RocketMQ 是阿里开源的一款云原生“消息、事件、流”实时数据处理平台，借鉴了 Kafka，已经成为 Apache 顶级项目。</p>
<p>RocketMQ 的核心特性（摘自 RocketMQ 官网）：</p>
<ul>
<li>云原生：生与云，长与云，无限弹性扩缩，K8s 友好</li>
<li>高吞吐：万亿级吞吐保证，同时满足微服务与大数据场景。</li>
<li>流处理：提供轻量、高扩展、高性能和丰富功能的流计算引擎。</li>
<li>金融级：金融级的稳定性，广泛用于交易核心链路。</li>
<li>架构极简：零外部依赖，Shared-nothing 架构。</li>
<li>生态友好：无缝对接微服务、实时计算、数据湖等周边生态。</li>
</ul>
<p>根据官网介绍：</p>
<blockquote>
<p>Apache RocketMQ 自诞生以来，因其架构简单、业务功能丰富、具备极强可扩展性等特点被众多企业开发者以及云厂商广泛采用。历经十余年的大规模场景打磨，RocketMQ 已经成为业内共识的金融级可靠业务消息首选方案，被广泛应用于互联网、大数据、移动互联网、物联网等领域的业务场景。</p>
</blockquote>
<p>RocketMQ 官网：<a href="https://rocketmq.apache.org/">https://rocketmq.apache.org/</a> （文档很详细，推荐阅读）</p>
<p>RocketMQ 更新记录（可以直观看到项目是否还在维护）：<a href="https://github.com/apache/rocketmq/releases">https://github.com/apache/rocketmq/releases</a></p>
<h4 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h4><p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/rabbitmq-logo.png"></p>
<p>RabbitMQ 是采用 Erlang 语言实现 AMQP(Advanced Message Queuing Protocol，高级消息队列协议）的消息中间件，它最初起源于金融系统，用于在分布式系统中存储转发消息。</p>
<p>RabbitMQ 发展到今天，被越来越多的人认可，这和它在易用性、扩展性、可靠性和高可用性等方面的卓著表现是分不开的。RabbitMQ 的具体特点可以概括为以下几点：</p>
<ul>
<li><strong>可靠性：</strong> RabbitMQ 使用一些机制来保证消息的可靠性，如持久化、传输确认及发布确认等。</li>
<li><strong>灵活的路由：</strong> 在消息进入队列之前，通过交换器来路由消息。对于典型的路由功能，RabbitMQ 己经提供了一些内置的交换器来实现。针对更复杂的路由功能，可以将多个交换器绑定在一起，也可以通过插件机制来实现自己的交换器。这个后面会在我们讲 RabbitMQ 核心概念的时候详细介绍到。</li>
<li><strong>扩展性：</strong> 多个 RabbitMQ 节点可以组成一个集群，也可以根据实际业务情况动态地扩展集群中节点。</li>
<li><strong>高可用性：</strong> 队列可以在集群中的机器上设置镜像，使得在部分节点出现问题的情况下队列仍然可用。</li>
<li><strong>支持多种协议：</strong> RabbitMQ 除了原生支持 AMQP 协议，还支持 STOMP、MQTT 等多种消息中间件协议。</li>
<li><strong>多语言客户端：</strong> RabbitMQ 几乎支持所有常用语言，比如 Java、Python、Ruby、PHP、C#、JavaScript 等。</li>
<li><strong>易用的管理界面：</strong> RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息、集群中的节点等。在安装 RabbitMQ 的时候会介绍到，安装好 RabbitMQ 就自带管理界面。</li>
<li><strong>插件机制：</strong> RabbitMQ 提供了许多插件，以实现从多方面进行扩展，当然也可以编写自己的插件。感觉这个有点类似 Dubbo 的 SPI 机制</li>
</ul>
<p>RabbitMQ 官网：<a href="https://www.rabbitmq.com/">https://www.rabbitmq.com/</a> 。</p>
<p>RabbitMQ 更新记录（可以直观看到项目是否还在维护）：<a href="https://www.rabbitmq.com/news.html">https://www.rabbitmq.com/news.html</a></p>
<h4 id="Pulsar"><a href="#Pulsar" class="headerlink" title="Pulsar"></a>Pulsar</h4><p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/pulsar-logo.png"></p>
<p>Pulsar 是下一代云原生分布式消息流平台，最初由 Yahoo 开发 ，已经成为 Apache 顶级项目。</p>
<p>Pulsar 集消息、存储、轻量化函数式计算为一体，采用计算与存储分离架构设计，支持多租户、持久化存储、多机房跨区域数据复制，具有强一致性、高吞吐、低延时及高可扩展性等流数据存储特性，被看作是云原生时代实时消息流传输、存储和计算最佳解决方案。</p>
<p>Pulsar 的关键特性如下（摘自官网）：</p>
<ul>
<li>是下一代云原生分布式消息流平台。</li>
<li>Pulsar 的单个实例原生支持多个集群，可跨机房在集群间无缝地完成消息复制。</li>
<li>极低的发布延迟和端到端延迟。</li>
<li>可无缝扩展到超过一百万个 topic。</li>
<li>简单的客户端 API，支持 Java、Go、Python 和 C++。</li>
<li>主题的多种订阅模式（独占、共享和故障转移）。</li>
<li>通过 Apache BookKeeper 提供的持久化消息存储机制保证消息传递 。</li>
<li>由轻量级的 serverless 计算框架 Pulsar Functions 实现流原生的数据处理。</li>
<li>基于 Pulsar Functions 的 serverless connector 框架 Pulsar IO 使得数据更易移入、移出 Apache Pulsar。</li>
<li>分层式存储可在数据陈旧时，将数据从热存储卸载到冷&#x2F;长期存储（如 S3、GCS）中。</li>
</ul>
<p>Pulsar 官网：<a href="https://pulsar.apache.org/">https://pulsar.apache.org/</a></p>
<p>Pulsar 更新记录（可以直观看到项目是否还在维护）：<a href="https://github.com/apache/pulsar/releases">https://github.com/apache/pulsar/releases</a></p>
<h4 id="ActiveMQ"><a href="#ActiveMQ" class="headerlink" title="ActiveMQ"></a>ActiveMQ</h4><p>目前已经被淘汰，不推荐使用，不建议学习。</p>
<h3 id="如何选择？"><a href="#如何选择？" class="headerlink" title="如何选择？"></a>如何选择？</h3><blockquote>
<p>参考《Java 工程师面试突击第 1 季-中华石杉老师》</p>
</blockquote>
<table>
<thead>
<tr>
<th>对比方向</th>
<th>概要</th>
</tr>
</thead>
<tbody><tr>
<td>吞吐量</td>
<td>万级的 ActiveMQ 和 RabbitMQ 的吞吐量（ActiveMQ 的性能最差）要比十万级甚至是百万级的 RocketMQ 和 Kafka 低一个数量级。</td>
</tr>
<tr>
<td>可用性</td>
<td>都可以实现高可用。ActiveMQ 和 RabbitMQ 都是基于主从架构实现高可用性。RocketMQ 基于分布式架构。 Kafka 也是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td>
</tr>
<tr>
<td>时效性</td>
<td>RabbitMQ 基于 Erlang 开发，所以并发能力很强，性能极其好，延时很低，达到微秒级，其他几个都是 ms 级。</td>
</tr>
<tr>
<td>功能支持</td>
<td>Pulsar 的功能更全面，支持多租户、多种消费模式和持久性模式等功能，是下一代云原生分布式消息流平台。</td>
</tr>
<tr>
<td>消息丢失</td>
<td>ActiveMQ 和 RabbitMQ 丢失的可能性非常低， Kafka、RocketMQ 和 Pulsar 理论上可以做到 0 丢失。</td>
</tr>
</tbody></table>
<p><strong>总结：</strong></p>
<ul>
<li>ActiveMQ 的社区算是比较成熟，但是较目前来说，ActiveMQ 的性能比较差，而且版本迭代很慢，不推荐使用，已经被淘汰了。</li>
<li>RabbitMQ 在吞吐量方面虽然稍逊于 Kafka、RocketMQ 和 Pulsar，但是由于它基于 Erlang 开发，所以并发能力很强，性能极其好，延时很低，达到微秒级。但是也因为 RabbitMQ 基于 Erlang 开发，所以国内很少有公司有实力做 Erlang 源码级别的研究和定制。如果业务场景对并发量要求不是太高（十万级、百万级），那这几种消息队列中，RabbitMQ 或许是你的首选。</li>
<li>RocketMQ 和 Pulsar 支持强一致性，对消息一致性要求比较高的场景可以使用。</li>
<li>RocketMQ 阿里出品，Java 系开源项目，源代码我们可以直接阅读，然后可以定制自己公司的 MQ，并且 RocketMQ 有阿里巴巴的实际业务场景的实战考验。</li>
<li>Kafka 的特点其实很明显，就是仅仅提供较少的核心功能，但是提供超高的吞吐量，ms 级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展。同时 Kafka 最好是支撑较少的 topic 数量即可，保证其超高吞吐量。Kafka 唯一的一点劣势是有可能消息重复消费，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略这个特性天然适合大数据实时计算以及日志收集。如果是大数据领域的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《大型网站技术架构 》</li>
<li>KRaft: Apache Kafka Without ZooKeeper：<a href="https://developer.confluent.io/learn/kraft/">https://developer.confluent.io/learn/kraft/</a></li>
<li>消息队列的使用场景是什么样的？：<a href="https://mp.weixin.qq.com/s/4V1jI6RylJr7Jr9JsQe73A">https://mp.weixin.qq.com/s/4V1jI6RylJr7Jr9JsQe73A</a></li>
</ul>
<!-- @include: @article-footer.snippet.md -->

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2024/09/13/data-desensitization/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/09/13/data-desensitization/" itemprop="url">数据脱敏方案总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-09-13T21:08:38+08:00">
                2024-09-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/WEB/" itemprop="url" rel="index">
                    <span itemprop="name">WEB</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2024/09/13/data-desensitization/" class="leancloud_visitors" data-flag-title="数据脱敏方案总结">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3.7k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  14 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <!-- @include: @article-header.snippet.md -->

<blockquote>
<p>本文转载完善自<a href="https://mp.weixin.qq.com/s/1qFWczesU50ndPPLtABHFg">Hutool：一行代码搞定数据脱敏 - 京东云开发者</a>。</p>
</blockquote>
<h2 id="什么是数据脱敏"><a href="#什么是数据脱敏" class="headerlink" title="什么是数据脱敏"></a>什么是数据脱敏</h2><h3 id="数据脱敏的定义"><a href="#数据脱敏的定义" class="headerlink" title="数据脱敏的定义"></a>数据脱敏的定义</h3><p>数据脱敏百度百科中是这样定义的：</p>
<blockquote>
<p>数据脱敏，指对某些敏感信息通过脱敏规则进行数据的变形，实现敏感隐私数据的可靠保护。这样就可以在开发、测试和其它非生产环境以及外包环境中安全地使用脱敏后的真实数据集。在涉及客户安全数据或者一些商业性敏感数据的情况下，在不违反系统规则条件下，对真实数据进行改造并提供测试使用，如身份证号、手机号、卡号、客户号等个人信息都需要进行数据脱敏。是数据库安全技术之一。</p>
</blockquote>
<p>总的来说，数据脱敏是指对某些敏感信息通过脱敏规则进行数据的变形，实现敏感隐私数据的可靠保护。</p>
<p>在数据脱敏过程中，通常会采用不同的算法和技术，以根据不同的需求和场景对数据进行处理。例如，对于身份证号码，可以使用掩码算法（masking）将前几位数字保留，其他位用 “X” 或 “*“ 代替；对于姓名，可以使用伪造（pseudonymization）算法，将真实姓名替换成随机生成的假名。</p>
<h3 id="常用脱敏规则"><a href="#常用脱敏规则" class="headerlink" title="常用脱敏规则"></a>常用脱敏规则</h3><p>常用脱敏规则是为了保护敏感数据的安全性，在处理和存储敏感数据时对其进行变换或修改。</p>
<p>下面是几种常见的脱敏规则：</p>
<ul>
<li>替换(常用)：将敏感数据中的特定字符或字符序列替换为其他字符。例如，将信用卡号中的中间几位数字替换为星号（*）或其他字符。</li>
<li>删除：将敏感数据中的部分内容随机删除。比如，将电话号码的随机 3 位数字进行删除。</li>
<li>重排：将原始数据中的某些字符或字段的顺序打乱。例如，将身份证号码的随机位交错互换。</li>
<li>加噪：在数据中注入一些误差或者噪音，达到对数据脱敏的效果。例如，在敏感数据中添加一些随机生成的字符。</li>
<li>加密（常用）：使用加密算法将敏感数据转换为密文。例如，将银行卡号用 MD5 或 SHA-256 等哈希函数进行散列。常见加密算法总结可以参考这篇文章：<a href="https://javaguide.cn/system-design/security/encryption-algorithms.html">https://javaguide.cn/system-design/security/encryption-algorithms.html</a> 。</li>
<li>……</li>
</ul>
<h2 id="常用脱敏工具"><a href="#常用脱敏工具" class="headerlink" title="常用脱敏工具"></a>常用脱敏工具</h2><h3 id="Hutool"><a href="#Hutool" class="headerlink" title="Hutool"></a>Hutool</h3><p>Hutool 一个 Java 基础工具类，对文件、流、加密解密、转码、正则、线程、XML 等 JDK 方法进行封装，组成各种 Util 工具类，同时提供以下组件：</p>
<table>
<thead>
<tr>
<th align="center">模块</th>
<th align="center">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="center">hutool-aop</td>
<td align="center">JDK 动态代理封装，提供非 IOC 下的切面支持</td>
</tr>
<tr>
<td align="center">hutool-bloomFilter</td>
<td align="center">布隆过滤，提供一些 Hash 算法的布隆过滤</td>
</tr>
<tr>
<td align="center">hutool-cache</td>
<td align="center">简单缓存实现</td>
</tr>
<tr>
<td align="center">hutool-core</td>
<td align="center">核心，包括 Bean 操作、日期、各种 Util 等</td>
</tr>
<tr>
<td align="center">hutool-cron</td>
<td align="center">定时任务模块，提供类 Crontab 表达式的定时任务</td>
</tr>
<tr>
<td align="center">hutool-crypto</td>
<td align="center">加密解密模块，提供对称、非对称和摘要算法封装</td>
</tr>
<tr>
<td align="center">hutool-db</td>
<td align="center">JDBC 封装后的数据操作，基于 ActiveRecord 思想</td>
</tr>
<tr>
<td align="center">hutool-dfa</td>
<td align="center">基于 DFA 模型的多关键字查找</td>
</tr>
<tr>
<td align="center">hutool-extra</td>
<td align="center">扩展模块，对第三方封装（模板引擎、邮件、Servlet、二维码、Emoji、FTP、分词等）</td>
</tr>
<tr>
<td align="center">hutool-http</td>
<td align="center">基于 HttpUrlConnection 的 Http 客户端封装</td>
</tr>
<tr>
<td align="center">hutool-log</td>
<td align="center">自动识别日志实现的日志门面</td>
</tr>
<tr>
<td align="center">hutool-script</td>
<td align="center">脚本执行封装，例如 Javascript</td>
</tr>
<tr>
<td align="center">hutool-setting</td>
<td align="center">功能更强大的 Setting 配置文件和 Properties 封装</td>
</tr>
<tr>
<td align="center">hutool-system</td>
<td align="center">系统参数调用封装（JVM 信息等）</td>
</tr>
<tr>
<td align="center">hutool-json</td>
<td align="center">JSON 实现</td>
</tr>
<tr>
<td align="center">hutool-captcha</td>
<td align="center">图片验证码实现</td>
</tr>
<tr>
<td align="center">hutool-poi</td>
<td align="center">针对 POI 中 Excel 和 Word 的封装</td>
</tr>
<tr>
<td align="center">hutool-socket</td>
<td align="center">基于 Java 的 NIO 和 AIO 的 Socket 封装</td>
</tr>
<tr>
<td align="center">hutool-jwt</td>
<td align="center">JSON Web Token (JWT) 封装实现</td>
</tr>
</tbody></table>
<p>可以根据需求对每个模块单独引入，也可以通过引入<code>hutool-all</code>方式引入所有模块，本文所使用的数据脱敏工具就是在 <code>hutool.core</code> 模块。</p>
<p>现阶段最新版本的 Hutool 支持的脱敏数据类型如下，基本覆盖了常见的敏感信息。</p>
<ol>
<li>用户 id</li>
<li>中文姓名</li>
<li>身份证号</li>
<li>座机号</li>
<li>手机号</li>
<li>地址</li>
<li>电子邮件</li>
<li>密码</li>
<li>中国大陆车牌，包含普通车辆、新能源车辆</li>
<li>银行卡</li>
</ol>
<h4 id="一行代码实现脱敏"><a href="#一行代码实现脱敏" class="headerlink" title="一行代码实现脱敏"></a>一行代码实现脱敏</h4><p>Hutool 提供的脱敏方法如下图所示：</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/security/2023-08-01-10-2119fnVCIDozqHgRGx.png"></p>
<p>注意：Hutool 脱敏是通过 * 来代替敏感信息的，具体实现是在 StrUtil.hide 方法中，如果我们想要自定义隐藏符号，则可以把 Hutool 的源码拷出来，重新实现即可。</p>
<p>这里以手机号、银行卡号、身份证号、密码信息的脱敏为例，下面是对应的测试代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.hutool.core.util.DesensitizedUtil;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.Spring BootTest;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: Hutool实现数据脱敏</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Spring</span> BootTest</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HuToolDesensitizationTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPhoneDesensitization</span><span class="params">()</span>&#123;</span><br><span class="line">        String phone=<span class="string">&quot;13723231234&quot;</span>;</span><br><span class="line">        System.out.println(DesensitizedUtil.mobilePhone(phone)); <span class="comment">//输出：137****1234</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBankCardDesensitization</span><span class="params">()</span>&#123;</span><br><span class="line">        String bankCard=<span class="string">&quot;6217000130008255666&quot;</span>;</span><br><span class="line">        System.out.println(DesensitizedUtil.bankCard(bankCard)); <span class="comment">//输出：6217 **** **** *** 5666</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testIdCardNumDesensitization</span><span class="params">()</span>&#123;</span><br><span class="line">        String idCardNum=<span class="string">&quot;411021199901102321&quot;</span>;</span><br><span class="line">        <span class="comment">//只显示前4位和后2位</span></span><br><span class="line">        System.out.println(DesensitizedUtil.idCardNum(idCardNum,<span class="number">4</span>,<span class="number">2</span>)); <span class="comment">//输出：4110************21</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPasswordDesensitization</span><span class="params">()</span>&#123;</span><br><span class="line">        String password=<span class="string">&quot;www.jd.com_35711&quot;</span>;</span><br><span class="line">        System.out.println(DesensitizedUtil.password(password)); <span class="comment">//输出：****************</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是使用 Hutool 封装好的工具类实现数据脱敏。</p>
<h4 id="配合-JackSon-通过注解方式实现脱敏"><a href="#配合-JackSon-通过注解方式实现脱敏" class="headerlink" title="配合 JackSon 通过注解方式实现脱敏"></a>配合 JackSon 通过注解方式实现脱敏</h4><p>现在有了数据脱敏工具类，如果前端需要显示数据数据的地方比较多，我们不可能在每个地方都调用一个工具类，这样就显得代码太冗余了，那我们如何通过注解的方式优雅的完成数据脱敏呢？</p>
<p>如果项目是基于 Spring Boot 的 web 项目，则可以利用 Spring Boot 自带的 jackson 自定义序列化实现。它的实现原理其实就是在 json 进行序列化渲染给前端时，进行脱敏。</p>
<p><strong>第一步：脱敏策略的枚举。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:脱敏策略枚举</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">DesensitizationTypeEnum</span> &#123;</span><br><span class="line">    <span class="comment">//自定义</span></span><br><span class="line">    MY_RULE,</span><br><span class="line">    <span class="comment">//用户id</span></span><br><span class="line">    USER_ID,</span><br><span class="line">    <span class="comment">//中文名</span></span><br><span class="line">    CHINESE_NAME,</span><br><span class="line">    <span class="comment">//身份证号</span></span><br><span class="line">    ID_CARD,</span><br><span class="line">    <span class="comment">//座机号</span></span><br><span class="line">    FIXED_PHONE,</span><br><span class="line">    <span class="comment">//手机号</span></span><br><span class="line">    MOBILE_PHONE,</span><br><span class="line">    <span class="comment">//地址</span></span><br><span class="line">    ADDRESS,</span><br><span class="line">    <span class="comment">//电子邮件</span></span><br><span class="line">    EMAIL,</span><br><span class="line">    <span class="comment">//密码</span></span><br><span class="line">    PASSWORD,</span><br><span class="line">    <span class="comment">//中国大陆车牌，包含普通车辆、新能源车辆</span></span><br><span class="line">    CAR_LICENSE,</span><br><span class="line">    <span class="comment">//银行卡</span></span><br><span class="line">    BANK_CARD</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面表示支持的脱敏类型。</p>
<p><strong>第二步：定义一个用于脱敏的 Desensitization 注解。</strong></p>
<ul>
<li><code>@Retention (RetentionPolicy.RUNTIME)</code>：运行时生效。</li>
<li><code>@Target (ElementType.FIELD)</code>：可用在字段上。</li>
<li><code>@JacksonAnnotationsInside</code>：此注解可以点进去看一下是一个元注解，主要是用户打包其他注解一起使用。</li>
<li><code>@JsonSerialize</code>：上面说到过，该注解的作用就是可自定义序列化，可以用在注解上，方法上，字段上，类上，运行时生效等等，根据提供的序列化类里面的重写方法实现自定义序列化。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@JacksonAnnotationsInside</span></span><br><span class="line"><span class="meta">@JsonSerialize(using = DesensitizationSerialize.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Desensitization &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 脱敏数据类型，在MY_RULE的时候，startInclude和endExclude生效</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    DesensitizationTypeEnum <span class="title function_">type</span><span class="params">()</span> <span class="keyword">default</span> DesensitizationTypeEnum.MY_RULE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 脱敏开始位置（包含）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">startInclude</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 脱敏结束位置（不包含）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">endExclude</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：只有使用了自定义的脱敏枚举 <code>MY_RULE</code> 的时候，开始位置和结束位置才生效。</p>
<p><strong>第三步：创建自定的序列化类</strong></p>
<p>这一步是我们实现数据脱敏的关键。自定义序列化类继承 <code>JsonSerializer</code>，实现 <code>ContextualSerializer</code> 接口，并重写两个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 自定义序列化类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DesensitizationSerialize</span> <span class="keyword">extends</span> <span class="title class_">JsonSerializer</span>&lt;String&gt; <span class="keyword">implements</span> <span class="title class_">ContextualSerializer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> DesensitizationTypeEnum type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer startInclude;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer endExclude;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(String str, JsonGenerator jsonGenerator, SerializerProvider serializerProvider)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="comment">// 自定义类型脱敏</span></span><br><span class="line">            <span class="keyword">case</span> MY_RULE:</span><br><span class="line">                jsonGenerator.writeString(CharSequenceUtil.hide(str, startInclude, endExclude));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// userId脱敏</span></span><br><span class="line">            <span class="keyword">case</span> USER_ID:</span><br><span class="line">                jsonGenerator.writeString(String.valueOf(DesensitizedUtil.userId()));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 中文姓名脱敏</span></span><br><span class="line">            <span class="keyword">case</span> CHINESE_NAME:</span><br><span class="line">                jsonGenerator.writeString(DesensitizedUtil.chineseName(String.valueOf(str)));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 身份证脱敏</span></span><br><span class="line">            <span class="keyword">case</span> ID_CARD:</span><br><span class="line">                jsonGenerator.writeString(DesensitizedUtil.idCardNum(String.valueOf(str), <span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 固定电话脱敏</span></span><br><span class="line">            <span class="keyword">case</span> FIXED_PHONE:</span><br><span class="line">                jsonGenerator.writeString(DesensitizedUtil.fixedPhone(String.valueOf(str)));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 手机号脱敏</span></span><br><span class="line">            <span class="keyword">case</span> MOBILE_PHONE:</span><br><span class="line">                jsonGenerator.writeString(DesensitizedUtil.mobilePhone(String.valueOf(str)));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 地址脱敏</span></span><br><span class="line">            <span class="keyword">case</span> ADDRESS:</span><br><span class="line">                jsonGenerator.writeString(DesensitizedUtil.address(String.valueOf(str), <span class="number">8</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 邮箱脱敏</span></span><br><span class="line">            <span class="keyword">case</span> EMAIL:</span><br><span class="line">                jsonGenerator.writeString(DesensitizedUtil.email(String.valueOf(str)));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 密码脱敏</span></span><br><span class="line">            <span class="keyword">case</span> PASSWORD:</span><br><span class="line">                jsonGenerator.writeString(DesensitizedUtil.password(String.valueOf(str)));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 中国车牌脱敏</span></span><br><span class="line">            <span class="keyword">case</span> CAR_LICENSE:</span><br><span class="line">                jsonGenerator.writeString(DesensitizedUtil.carLicense(String.valueOf(str)));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 银行卡脱敏</span></span><br><span class="line">            <span class="keyword">case</span> BANK_CARD:</span><br><span class="line">                jsonGenerator.writeString(DesensitizedUtil.bankCard(String.valueOf(str)));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> JsonSerializer&lt;?&gt; createContextual(SerializerProvider serializerProvider, BeanProperty beanProperty) <span class="keyword">throws</span> JsonMappingException &#123;</span><br><span class="line">        <span class="keyword">if</span> (beanProperty != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断数据类型是否为String类型</span></span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(beanProperty.getType().getRawClass(), String.class)) &#123;</span><br><span class="line">                <span class="comment">// 获取定义的注解</span></span><br><span class="line">                <span class="type">Desensitization</span> <span class="variable">desensitization</span> <span class="operator">=</span> beanProperty.getAnnotation(Desensitization.class);</span><br><span class="line">                <span class="comment">// 为null</span></span><br><span class="line">                <span class="keyword">if</span> (desensitization == <span class="literal">null</span>) &#123;</span><br><span class="line">                    desensitization = beanProperty.getContextAnnotation(Desensitization.class);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 不为null</span></span><br><span class="line">                <span class="keyword">if</span> (desensitization != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 创建定义的序列化类的实例并且返回，入参为注解定义的type,开始位置，结束位置。</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DesensitizationSerialize</span>(desensitization.type(), desensitization.startInclude(),</span><br><span class="line">                            desensitization.endExclude());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> serializerProvider.findValueSerializer(beanProperty.getType(), beanProperty);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> serializerProvider.findNullValueSerializer(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过上述三步，已经完成了通过注解实现数据脱敏了，下面我们来测试一下。</p>
<p>首先定义一个要测试的 pojo，对应的字段加入要脱敏的策略。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPojo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Desensitization(type = DesensitizationTypeEnum.MOBILE_PHONE)</span></span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Desensitization(type = DesensitizationTypeEnum.PASSWORD)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Desensitization(type = DesensitizationTypeEnum.MY_RULE, startInclude = 0, endExclude = 2)</span></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来写一个测试的 controller</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> TestPojo <span class="title function_">testDesensitization</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">TestPojo</span> <span class="variable">testPojo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestPojo</span>();</span><br><span class="line">        testPojo.setUserName(<span class="string">&quot;我是用户名&quot;</span>);</span><br><span class="line">        testPojo.setAddress(<span class="string">&quot;地球中国-北京市通州区京东总部2号楼&quot;</span>);</span><br><span class="line">        testPojo.setPhone(<span class="string">&quot;13782946666&quot;</span>);</span><br><span class="line">        testPojo.setPassword(<span class="string">&quot;sunyangwei123123123.&quot;</span>);</span><br><span class="line">        System.out.println(testPojo);</span><br><span class="line">        <span class="keyword">return</span> testPojo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/security/2023-08-02-16-497DdCBy8vbf2D69g.png"></p>
<p>可以看到我们成功实现了数据脱敏。</p>
<h3 id="Apache-ShardingSphere"><a href="#Apache-ShardingSphere" class="headerlink" title="Apache ShardingSphere"></a>Apache ShardingSphere</h3><p>ShardingSphere 是一套开源的分布式数据库中间件解决方案组成的生态圈，它由 Sharding-JDBC、Sharding-Proxy 和 Sharding-Sidecar（计划中）这 3 款相互独立的产品组成。 他们均提供标准化的数据分片、分布式事务和数据库治理功能 。</p>
<p>Apache ShardingSphere 下面存在一个数据脱敏模块，此模块集成的常用的数据脱敏的功能。其基本原理是对用户输入的 SQL 进行解析拦截，并依靠用户的脱敏配置进行 SQL 的改写，从而实现对原文字段的加密及加密字段的解密。最终实现对用户无感的加解密存储、查询。</p>
<p>通过 Apache ShardingSphere 可以自动化&amp;透明化数据脱敏过程，用户无需关注脱敏中间实现细节。并且，提供了多种内置、第三方(AKS)的脱敏策略，用户仅需简单配置即可使用。</p>
<p>官方文档地址：<a href="https://shardingsphere.apache.org/document/4.1.1/cn/features/orchestration/encrypt/">https://shardingsphere.apache.org/document/4.1.1/cn/features/orchestration/encrypt/</a> 。</p>
<h3 id="FastJSON"><a href="#FastJSON" class="headerlink" title="FastJSON"></a>FastJSON</h3><p>平时开发 Web 项目的时候，除了默认的 Spring 自带的序列化工具，FastJson 也是一个很常用的 Spring Web Restful 接口序列化的工具。</p>
<p>FastJSON 实现数据脱敏的方式主要有两种：</p>
<ul>
<li>基于注解 <code>@JSONField</code> 实现：需要自定义一个用于脱敏的序列化的类，然后在需要脱敏的字段上通过 <code>@JSONField</code> 中的 <code>serializeUsing</code> 指定为我们自定义的序列化类型即可。</li>
<li>基于序列化过滤器：需要实现 <code>ValueFilter</code> 接口，重写 <code>process</code> 方法完成自定义脱敏，然后在 JSON 转换时使用自定义的转换策略。具体实现可参考这篇文章： <a href="https://juejin.cn/post/7067916686141161479">https://juejin.cn/post/7067916686141161479</a>。</li>
</ul>
<h3 id="Mybatis-Mate"><a href="#Mybatis-Mate" class="headerlink" title="Mybatis-Mate"></a>Mybatis-Mate</h3><p>先介绍一下 MyBatis、MyBatis-Plus 和 Mybatis-Mate 这三者的关系：</p>
<ul>
<li>MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。</li>
<li>MyBatis-Plus 是一个 MyBatis 的增强工具，能够极大地简化持久层的开发工作。</li>
<li>Mybatis-Mate 是为 MyBatis-Plus 提供的企业级模块，旨在更敏捷优雅处理数据。不过，使用之前需要配置授权码（付费）。</li>
</ul>
<p>Mybatis-Mate 支持敏感词脱敏，内置手机号、邮箱、银行卡号等 9 种常用脱敏规则。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FieldSensitive(&quot;testStrategy&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SensitiveStrategyConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注入脱敏策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ISensitiveStrategy <span class="title function_">sensitiveStrategy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 自定义 testStrategy 类型脱敏处理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SensitiveStrategy</span>().addStrategy(<span class="string">&quot;testStrategy&quot;</span>, t -&gt; t + <span class="string">&quot;***test***&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳过脱密处理，用于编辑场景</span></span><br><span class="line">RequestDataTransfer.skipSensitive();</span><br></pre></td></tr></table></figure>

<h3 id="MyBatis-Flex"><a href="#MyBatis-Flex" class="headerlink" title="MyBatis-Flex"></a>MyBatis-Flex</h3><p>类似于 MybatisPlus，MyBatis-Flex 也是一个 MyBatis 增强框架。MyBatis-Flex 同样提供了数据脱敏功能，并且是可以免费使用的。</p>
<p>MyBatis-Flex 提供了 <code>@ColumnMask()</code> 注解，以及内置的 9 种脱敏规则，开箱即用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 内置的数据脱敏方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Masks</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 手机号脱敏</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MOBILE</span> <span class="operator">=</span> <span class="string">&quot;mobile&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 固定电话脱敏</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FIXED_PHONE</span> <span class="operator">=</span> <span class="string">&quot;fixed_phone&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 身份证号脱敏</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ID_CARD_NUMBER</span> <span class="operator">=</span> <span class="string">&quot;id_card_number&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中文名脱敏</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CHINESE_NAME</span> <span class="operator">=</span> <span class="string">&quot;chinese_name&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 地址脱敏</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ADDRESS</span> <span class="operator">=</span> <span class="string">&quot;address&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 邮件脱敏</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EMAIL</span> <span class="operator">=</span> <span class="string">&quot;email&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 密码脱敏</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PASSWORD</span> <span class="operator">=</span> <span class="string">&quot;password&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 车牌号脱敏</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CAR_LICENSE</span> <span class="operator">=</span> <span class="string">&quot;car_license&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 银行卡号脱敏</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BANK_CARD_NUMBER</span> <span class="operator">=</span> <span class="string">&quot;bank_card_number&quot;</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Table(&quot;tb_account&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id(keyType = KeyType.Auto)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ColumnMask(Masks.CHINESE_NAME)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ColumnMask(Masks.EMAIL)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果这些内置的脱敏规则不满足你的要求的话，你还可以自定义脱敏规则。</p>
<p>1、通过 <code>MaskManager</code> 注册新的脱敏规则：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MaskManager.registerMaskProcessor(<span class="string">&quot;自定义规则名称&quot;</span></span><br><span class="line">        , data -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<p>2、使用自定义的脱敏规则</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Table(&quot;tb_account&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id(keyType = KeyType.Auto)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ColumnMask(&quot;自定义规则名称&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且，对于需要跳过脱密处理的场景，例如进入编辑页面编辑用户数据，MyBatis-Flex 也提供了对应的支持：</p>
<ol>
<li>**<code>MaskManager#execWithoutMask</code>**（推荐）：该方法使用了模版方法设计模式，保障跳过脱敏处理并执行相关逻辑后自动恢复脱敏处理。</li>
<li>**<code>MaskManager#skipMask</code>**：跳过脱敏处理。</li>
<li>**<code>MaskManager#restoreMask</code>**：恢复脱敏处理，确保后续的操作继续使用脱敏逻辑。</li>
</ol>
<p><code>MaskManager#execWithoutMask</code>方法实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">execWithoutMask</span><span class="params">(Supplier&lt;T&gt; supplier)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        skipMask();</span><br><span class="line">        <span class="keyword">return</span> supplier.get();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        restoreMask();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>MaskManager</code> 的<code>skipMask</code>和<code>restoreMask</code>方法一般配套使用，推荐<code>try&#123;...&#125;finally&#123;...&#125;</code>模式。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章主要介绍了：</p>
<ul>
<li>数据脱敏的定义：数据脱敏是指对某些敏感信息通过脱敏规则进行数据的变形，实现敏感隐私数据的可靠保护。</li>
<li>常用的脱敏规则：替换、删除、重排、加噪和加密。</li>
<li>常用的脱敏工具：Hutool、Apache ShardingSphere、FastJSON、Mybatis-Mate 和 MyBatis-Flex。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>Hutool 工具官网： <a href="https://hutool.cn/docs/#/">https://hutool.cn/docs/#/</a></li>
<li>聊聊如何自定义数据脱敏：<a href="https://juejin.cn/post/7046567603971719204">https://juejin.cn/post/7046567603971719204</a></li>
<li>FastJSON 实现数据脱敏：<a href="https://juejin.cn/post/7067916686141161479">https://juejin.cn/post/7067916686141161479</a></li>
</ul>
<!-- @include: @article-footer.snippet.md -->

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2024/09/06/linear-data-structure/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/09/06/linear-data-structure/" itemprop="url">线性数据结构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-09-06T20:03:59+08:00">
                2024-09-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2024/09/06/linear-data-structure/" class="leancloud_visitors" data-flag-title="线性数据结构">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3.8k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  14 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-数组"><a href="#1-数组" class="headerlink" title="1. 数组"></a>1. 数组</h2><p><strong>数组（Array）</strong> 是一种很常见的数据结构。它由相同类型的元素（element）组成，并且是使用一块连续的内存来存储。</p>
<p>我们直接可以利用元素的索引（index）可以计算出该元素对应的存储地址。</p>
<p>数组的特点是：<strong>提供随机访问</strong> 并且容量有限。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">假如数组的长度为 n。</span><br><span class="line">访问：O（<span class="number">1</span>）<span class="comment">//访问特定位置的元素</span></span><br><span class="line">插入：O（n ）<span class="comment">//最坏的情况发生在插入发生在数组的首部并需要移动所有元素时</span></span><br><span class="line">删除：O（n）<span class="comment">//最坏的情况发生在删除数组的开头发生并需要移动第一元素后面所有的元素时</span></span><br></pre></td></tr></table></figure>

<p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/data-structure/array.png" alt="数组"></p>
<h2 id="2-链表"><a href="#2-链表" class="headerlink" title="2. 链表"></a>2. 链表</h2><h3 id="2-1-链表简介"><a href="#2-1-链表简介" class="headerlink" title="2.1. 链表简介"></a>2.1. 链表简介</h3><p><strong>链表（LinkedList）</strong> 虽然是一种线性表，但是并不会按线性的顺序存储数据，使用的不是连续的内存空间来存储数据。</p>
<p>链表的插入和删除操作的复杂度为 O(1) ，只需要知道目标位置元素的上一个元素即可。但是，在查找一个节点或者访问特定位置的节点的时候复杂度为 O(n) 。</p>
<p>使用链表结构可以克服数组需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间,实现灵活的内存动态管理。但链表不会节省空间，相比于数组会占用更多的空间，因为链表中每个节点存放的还有指向其他节点的指针。除此之外，链表不具有数组随机读取的优点。</p>
<h3 id="2-2-链表分类"><a href="#2-2-链表分类" class="headerlink" title="2.2. 链表分类"></a>2.2. 链表分类</h3><p><strong>常见链表分类：</strong></p>
<ol>
<li>单链表</li>
<li>双向链表</li>
<li>循环链表</li>
<li>双向循环链表</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">假如链表中有n个元素。</span><br><span class="line">访问：O（n）<span class="comment">//访问特定位置的元素</span></span><br><span class="line">插入删除：O（<span class="number">1</span>）<span class="comment">//必须要要知道插入元素的位置</span></span><br></pre></td></tr></table></figure>

<h4 id="2-2-1-单链表"><a href="#2-2-1-单链表" class="headerlink" title="2.2.1. 单链表"></a>2.2.1. 单链表</h4><p><strong>单链表</strong> 单向链表只有一个方向，结点只有一个后继指针 next 指向后面的节点。因此，链表这种数据结构通常在物理内存上是不连续的。我们习惯性地把第一个结点叫作头结点，链表通常有一个不保存任何值的 head 节点(头结点)，通过头结点我们可以遍历整个链表。尾结点通常指向 null。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/data-structure/single-linkedlist.png" alt="单链表"></p>
<h4 id="2-2-2-循环链表"><a href="#2-2-2-循环链表" class="headerlink" title="2.2.2. 循环链表"></a>2.2.2. 循环链表</h4><p><strong>循环链表</strong> 其实是一种特殊的单链表，和单链表不同的是循环链表的尾结点不是指向 null，而是指向链表的头结点。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/data-structure/circular-linkedlist.png" alt="循环链表"></p>
<h4 id="2-2-3-双向链表"><a href="#2-2-3-双向链表" class="headerlink" title="2.2.3. 双向链表"></a>2.2.3. 双向链表</h4><p><strong>双向链表</strong> 包含两个指针，一个 prev 指向前一个节点，一个 next 指向后一个节点。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/data-structure/bidirectional-linkedlist.png" alt="双向链表"></p>
<h4 id="2-2-4-双向循环链表"><a href="#2-2-4-双向循环链表" class="headerlink" title="2.2.4. 双向循环链表"></a>2.2.4. 双向循环链表</h4><p><strong>双向循环链表</strong> 最后一个节点的 next 指向 head，而 head 的 prev 指向最后一个节点，构成一个环。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/data-structure/bidirectional-circular-linkedlist.png" alt="双向循环链表"></p>
<h3 id="2-3-应用场景"><a href="#2-3-应用场景" class="headerlink" title="2.3. 应用场景"></a>2.3. 应用场景</h3><ul>
<li>如果需要支持随机访问的话，链表没办法做到。</li>
<li>如果需要存储的数据元素的个数不确定，并且需要经常添加和删除数据的话，使用链表比较合适。</li>
<li>如果需要存储的数据元素的个数确定，并且不需要经常添加和删除数据的话，使用数组比较合适。</li>
</ul>
<h3 id="2-4-数组-vs-链表"><a href="#2-4-数组-vs-链表" class="headerlink" title="2.4. 数组 vs 链表"></a>2.4. 数组 vs 链表</h3><ul>
<li>数组支持随机访问，而链表不支持。</li>
<li>数组使用的是连续内存空间对 CPU 的缓存机制友好，链表则相反。</li>
<li>数组的大小固定，而链表则天然支持动态扩容。如果声明的数组过小，需要另外申请一个更大的内存空间存放数组元素，然后将原数组拷贝进去，这个操作是比较耗时的！</li>
</ul>
<h2 id="3-栈"><a href="#3-栈" class="headerlink" title="3. 栈"></a>3. 栈</h2><h3 id="3-1-栈简介"><a href="#3-1-栈简介" class="headerlink" title="3.1. 栈简介"></a>3.1. 栈简介</h3><p><strong>栈 (Stack)</strong> 只允许在有序的线性数据集合的一端（称为栈顶 top）进行加入数据（push）和移除数据（pop）。因而按照 <strong>后进先出（LIFO, Last In First Out）</strong> 的原理运作。<strong>在栈中，push 和 pop 的操作都发生在栈顶。</strong></p>
<p>栈常用一维数组或链表来实现，用数组实现的栈叫作 <strong>顺序栈</strong> ，用链表实现的栈叫作 <strong>链式栈</strong> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">假设堆栈中有n个元素。</span><br><span class="line">访问：O（n）<span class="comment">//最坏情况</span></span><br><span class="line">插入删除：O（<span class="number">1</span>）<span class="comment">//顶端插入和删除元素</span></span><br></pre></td></tr></table></figure>

<p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/data-structure/%E6%A0%88.png" alt="栈"></p>
<h3 id="3-2-栈的常见应用场景"><a href="#3-2-栈的常见应用场景" class="headerlink" title="3.2. 栈的常见应用场景"></a>3.2. 栈的常见应用场景</h3><p>当我们我们要处理的数据只涉及在一端插入和删除数据，并且满足 <strong>后进先出（LIFO, Last In First Out）</strong> 的特性时，我们就可以使用栈这个数据结构。</p>
<h4 id="3-2-1-实现浏览器的回退和前进功能"><a href="#3-2-1-实现浏览器的回退和前进功能" class="headerlink" title="3.2.1. 实现浏览器的回退和前进功能"></a>3.2.1. 实现浏览器的回退和前进功能</h4><p>我们只需要使用两个栈(Stack1 和 Stack2)和就能实现这个功能。比如你按顺序查看了 1,2,3,4 这四个页面，我们依次把 1,2,3,4 这四个页面压入 Stack1 中。当你想回头看 2 这个页面的时候，你点击回退按钮，我们依次把 4,3 这两个页面从 Stack1 弹出，然后压入 Stack2 中。假如你又想回到页面 3，你点击前进按钮，我们将 3 页面从 Stack2 弹出，然后压入到 Stack1 中。示例图如下:</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/data-structure/%E6%A0%88%E5%AE%9E%E7%8E%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E5%80%92%E9%80%80%E5%92%8C%E5%89%8D%E8%BF%9B.png" alt="栈实现浏览器倒退和前进"></p>
<h4 id="3-2-2-检查符号是否成对出现"><a href="#3-2-2-检查符号是否成对出现" class="headerlink" title="3.2.2. 检查符号是否成对出现"></a>3.2.2. 检查符号是否成对出现</h4><blockquote>
<p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串，判断该字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
</ol>
<p>比如 “()”、”()[]{}”、”{[]}” 都是有效字符串，而 “(]”、”([)]” 则不是。</p>
</blockquote>
<p>这个问题实际是 Leetcode 的一道题目，我们可以利用栈 <code>Stack</code> 来解决这个问题。</p>
<ol>
<li>首先我们将括号间的对应规则存放在 <code>Map</code> 中，这一点应该毋容置疑；</li>
<li>创建一个栈。遍历字符串，如果字符是左括号就直接加入<code>stack</code>中，否则将<code>stack</code> 的栈顶元素与这个括号做比较，如果不相等就直接返回 false。遍历结束，如果<code>stack</code>为空，返回 <code>true</code>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span>&#123;</span><br><span class="line">    <span class="comment">// 括号之间的对应规则</span></span><br><span class="line">    HashMap&lt;Character, Character&gt; mappings = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Character&gt;();</span><br><span class="line">    mappings.put(<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">    mappings.put(<span class="string">&#x27;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#x27;</span>);</span><br><span class="line">    mappings.put(<span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">    Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Character&gt;();</span><br><span class="line">    <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mappings.containsKey(chars[i])) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">topElement</span> <span class="operator">=</span> stack.empty() ? <span class="string">&#x27;#&#x27;</span> : stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (topElement != mappings.get(chars[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stack.push(chars[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-3-反转字符串"><a href="#3-2-3-反转字符串" class="headerlink" title="3.2.3. 反转字符串"></a>3.2.3. 反转字符串</h4><p>将字符串中的每个字符先入栈再出栈就可以了。</p>
<h4 id="3-2-4-维护函数调用"><a href="#3-2-4-维护函数调用" class="headerlink" title="3.2.4. 维护函数调用"></a>3.2.4. 维护函数调用</h4><p>最后一个被调用的函数必须先完成执行，符合栈的 <strong>后进先出（LIFO, Last In First Out）</strong> 特性。<br>例如递归函数调用可以通过栈来实现，每次递归调用都会将参数和返回地址压栈。</p>
<h4 id="3-2-5-深度优先遍历（DFS）"><a href="#3-2-5-深度优先遍历（DFS）" class="headerlink" title="3.2.5 深度优先遍历（DFS）"></a>3.2.5 深度优先遍历（DFS）</h4><p>在深度优先搜索过程中，栈被用来保存搜索路径，以便回溯到上一层。</p>
<h3 id="3-3-栈的实现"><a href="#3-3-栈的实现" class="headerlink" title="3.3. 栈的实现"></a>3.3. 栈的实现</h3><p>栈既可以通过数组实现，也可以通过链表来实现。不管基于数组还是链表，入栈、出栈的时间复杂度都为 O(1)。</p>
<p>下面我们使用数组来实现一个栈，并且这个栈具有<code>push()</code>、<code>pop()</code>（返回栈顶元素并出栈）、<code>peek()</code> （返回栈顶元素不出栈）、<code>isEmpty()</code>、<code>size()</code>这些基本的方法。</p>
<blockquote>
<p>提示：每次入栈之前先判断栈的容量是否够用，如果不够用就用<code>Arrays.copyOf()</code>进行扩容；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] storage;<span class="comment">//存放栈中元素的数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;<span class="comment">//栈的容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;<span class="comment">//栈中元素数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">GROW_FACTOR</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不带初始容量的构造方法。默认容量为8</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = <span class="number">8</span>;</span><br><span class="line">        <span class="built_in">this</span>.storage=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">8</span>];</span><br><span class="line">        <span class="built_in">this</span>.count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//带初始容量的构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Capacity too small.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.capacity = initialCapacity;</span><br><span class="line">        <span class="built_in">this</span>.storage = <span class="keyword">new</span> <span class="title class_">int</span>[initialCapacity];</span><br><span class="line">        <span class="built_in">this</span>.count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == capacity) &#123;</span><br><span class="line">            ensureCapacity();</span><br><span class="line">        &#125;</span><br><span class="line">        storage[count++] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//确保容量大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> capacity * GROW_FACTOR;</span><br><span class="line">        storage = Arrays.copyOf(storage, newCapacity);</span><br><span class="line">        capacity = newCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回栈顶元素并出栈</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Stack is empty.&quot;</span>);</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">return</span> storage[count];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回栈顶元素不出栈</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Stack is empty.&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> storage[count-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断栈是否为空</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回栈中元素的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>验证</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyStack</span> <span class="variable">myStack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyStack</span>(<span class="number">3</span>);</span><br><span class="line">myStack.push(<span class="number">1</span>);</span><br><span class="line">myStack.push(<span class="number">2</span>);</span><br><span class="line">myStack.push(<span class="number">3</span>);</span><br><span class="line">myStack.push(<span class="number">4</span>);</span><br><span class="line">myStack.push(<span class="number">5</span>);</span><br><span class="line">myStack.push(<span class="number">6</span>);</span><br><span class="line">myStack.push(<span class="number">7</span>);</span><br><span class="line">myStack.push(<span class="number">8</span>);</span><br><span class="line">System.out.println(myStack.peek());<span class="comment">//8</span></span><br><span class="line">System.out.println(myStack.size());<span class="comment">//8</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">    System.out.println(myStack.pop());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(myStack.isEmpty());<span class="comment">//true</span></span><br><span class="line">myStack.pop();<span class="comment">//报错：java.lang.IllegalArgumentException: Stack is empty.</span></span><br></pre></td></tr></table></figure>

<h2 id="4-队列"><a href="#4-队列" class="headerlink" title="4. 队列"></a>4. 队列</h2><h3 id="4-1-队列简介"><a href="#4-1-队列简介" class="headerlink" title="4.1. 队列简介"></a>4.1. 队列简介</h3><p><strong>队列（Queue）</strong> 是 <strong>先进先出 (FIFO，First In, First Out)</strong> 的线性表。在具体应用中通常用链表或者数组来实现，用数组实现的队列叫作 <strong>顺序队列</strong> ，用链表实现的队列叫作 <strong>链式队列</strong> 。<strong>队列只允许在后端（rear）进行插入操作也就是入队 enqueue，在前端（front）进行删除操作也就是出队 dequeue</strong></p>
<p>队列的操作方式和堆栈类似，唯一的区别在于队列只允许新数据在后端进行添加。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">假设队列中有n个元素。</span><br><span class="line">访问：O（n）<span class="comment">//最坏情况</span></span><br><span class="line">插入删除：O（<span class="number">1</span>）<span class="comment">//后端插入前端删除元素</span></span><br></pre></td></tr></table></figure>

<p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/data-structure/queue.png" alt="队列"></p>
<h3 id="4-2-队列分类"><a href="#4-2-队列分类" class="headerlink" title="4.2. 队列分类"></a>4.2. 队列分类</h3><h4 id="4-2-1-单队列"><a href="#4-2-1-单队列" class="headerlink" title="4.2.1. 单队列"></a>4.2.1. 单队列</h4><p>单队列就是常见的队列, 每次添加元素时，都是添加到队尾。单队列又分为 <strong>顺序队列（数组实现）</strong> 和 <strong>链式队列（链表实现）</strong>。</p>
<p><strong>顺序队列存在“假溢出”的问题也就是明明有位置却不能添加的情况。</strong></p>
<p>假设下图是一个顺序队列，我们将前两个元素 1,2 出队，并入队两个元素 7,8。当进行入队、出队操作的时候，front 和 rear 都会持续往后移动，当 rear 移动到最后的时候,我们无法再往队列中添加数据，即使数组中还有空余空间，这种现象就是 <strong>”假溢出“</strong> 。除了假溢出问题之外，如下图所示，当添加元素 8 的时候，rear 指针移动到数组之外（越界）。</p>
<blockquote>
<p>为了避免当只有一个元素的时候，队头和队尾重合使处理变得麻烦，所以引入两个指针，front 指针指向对头元素，rear 指针指向队列最后一个元素的下一个位置，这样当 front 等于 rear 时，此队列不是还剩一个元素，而是空队列。——From 《大话数据结构》</p>
</blockquote>
<p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/data-structure/seq-queue-false-overflow.png" alt="顺序队列假溢出"></p>
<h4 id="4-2-2-循环队列"><a href="#4-2-2-循环队列" class="headerlink" title="4.2.2. 循环队列"></a>4.2.2. 循环队列</h4><p>循环队列可以解决顺序队列的假溢出和越界问题。解决办法就是：从头开始，这样也就会形成头尾相接的循环，这也就是循环队列名字的由来。</p>
<p>还是用上面的图，我们将 rear 指针指向数组下标为 0 的位置就不会有越界问题了。当我们再向队列中添加元素的时候， rear 向后移动。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/data-structure/circular-queue.png" alt="循环队列"></p>
<p>顺序队列中，我们说 <code>front==rear</code> 的时候队列为空，循环队列中则不一样，也可能为满，如上图所示。解决办法有两种：</p>
<ol>
<li>可以设置一个标志变量 <code>flag</code>,当 <code>front==rear</code> 并且 <code>flag=0</code> 的时候队列为空，当<code>front==rear</code> 并且 <code>flag=1</code> 的时候队列为满。</li>
<li>队列为空的时候就是 <code>front==rear</code> ，队列满的时候，我们保证数组还有一个空闲的位置，rear 就指向这个空闲位置，如下图所示，那么现在判断队列是否为满的条件就是：<code>(rear+1) % QueueSize==front</code> 。</li>
</ol>
<h4 id="4-2-3-双端队列"><a href="#4-2-3-双端队列" class="headerlink" title="4.2.3 双端队列"></a>4.2.3 双端队列</h4><p><strong>双端队列 (Deque)</strong> 是一种在队列的两端都可以进行插入和删除操作的队列，相比单队列来说更加灵活。</p>
<p>一般来说，我们可以对双端队列进行 <code>addFirst</code>、<code>addLast</code>、<code>removeFirst</code> 和 <code>removeLast</code> 操作。</p>
<h4 id="4-2-4-优先队列"><a href="#4-2-4-优先队列" class="headerlink" title="4.2.4 优先队列"></a>4.2.4 优先队列</h4><p><strong>优先队列 (Priority Queue)</strong> 从底层结构上来讲并非线性的数据结构，它一般是由堆来实现的。</p>
<ol>
<li>在每个元素入队时，优先队列会将新元素其插入堆中并调整堆。</li>
<li>在队头出队时，优先队列会返回堆顶元素并调整堆。</li>
</ol>
<p>关于堆的具体实现可以看<a href="https://javaguide.cn/cs-basics/data-structure/heap.html">堆</a>这一节。</p>
<p>总而言之，不论我们进行什么操作，优先队列都能按照<strong>某种排序方式</strong>进行一系列堆的相关操作，从而保证整个集合的<strong>有序性</strong>。</p>
<p>虽然优先队列的底层并非严格的线性结构，但是在我们使用的过程中，我们是感知不到<strong>堆</strong>的，从使用者的眼中优先队列可以被认为是一种线性的数据结构：一种会自动排序的线性队列。</p>
<h3 id="4-3-队列的常见应用场景"><a href="#4-3-队列的常见应用场景" class="headerlink" title="4.3. 队列的常见应用场景"></a>4.3. 队列的常见应用场景</h3><p>当我们需要按照一定顺序来处理数据的时候可以考虑使用队列这个数据结构。</p>
<ul>
<li><strong>阻塞队列：</strong> 阻塞队列可以看成在队列基础上加了阻塞操作的队列。当队列为空的时候，出队操作阻塞，当队列满的时候，入队操作阻塞。使用阻塞队列我们可以很容易实现“生产者 - 消费者“模型。</li>
<li><strong>线程池中的请求&#x2F;任务队列：</strong> 线程池中没有空闲线程时，新的任务请求线程资源时，线程池该如何处理呢？答案是将这些请求放在队列中，当有空闲线程的时候，会循环中反复从队列中获取任务来执行。队列分为无界队列(基于链表)和有界队列(基于数组)。无界队列的特点就是可以一直入列，除非系统资源耗尽，比如：<code>FixedThreadPool</code> 使用无界队列 <code>LinkedBlockingQueue</code>。但是有界队列就不一样了，当队列满的话后面再有任务&#x2F;请求就会拒绝，在 Java 中的体现就是会抛出<code>java.util.concurrent.RejectedExecutionException</code> 异常。</li>
<li>栈：双端队列天生便可以实现栈的全部功能（<code>push</code>、<code>pop</code> 和 <code>peek</code>），并且在 Deque 接口中已经实现了相关方法。Stack 类已经和 Vector 一样被遗弃，现在在 Java 中普遍使用双端队列（Deque）来实现栈。</li>
<li>广度优先搜索（BFS），在图的广度优先搜索过程中，队列被用于存储待访问的节点，保证按照层次顺序遍历图的节点。</li>
<li>Linux 内核进程队列（按优先级排队）</li>
<li>现实生活中的派对，播放器上的播放列表;</li>
<li>消息队列</li>
<li>等等……</li>
</ul>
<!-- @include: @article-footer.snippet.md -->

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2024/08/27/sql-questions-05/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/08/27/sql-questions-05/" itemprop="url">SQL常见面试题总结（5）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-08-27T22:39:13+08:00">
                2024-08-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/" itemprop="url" rel="index">
                    <span itemprop="name">面试问题</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2024/08/27/sql-questions-05/" class="leancloud_visitors" data-flag-title="SQL常见面试题总结（5）">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  8.1k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  39 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>题目来源于：<a href="https://www.nowcoder.com/exam/oj?page=1&tab=SQL%E7%AF%87&topicId=240">牛客题霸 - SQL 进阶挑战</a></p>
</blockquote>
<p>较难或者困难的题目可以根据自身实际情况和面试需要来决定是否要跳过。</p>
<h2 id="空值处理"><a href="#空值处理" class="headerlink" title="空值处理"></a>空值处理</h2><h3 id="统计有未完成状态的试卷的未完成数和未完成率"><a href="#统计有未完成状态的试卷的未完成数和未完成率" class="headerlink" title="统计有未完成状态的试卷的未完成数和未完成率"></a>统计有未完成状态的试卷的未完成数和未完成率</h3><p><strong>描述</strong>：</p>
<p>现有试卷作答记录表 <code>exam_record</code>（<code>uid</code> 用户 ID, <code>exam_id</code> 试卷 ID, <code>start_time</code> 开始作答时间, <code>submit_time</code> 交卷时间, <code>score</code> 得分），数据如下：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>uid</th>
<th>exam_id</th>
<th>start_time</th>
<th>submit_time</th>
<th>score</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1001</td>
<td>9001</td>
<td>2020-01-02 09:01:01</td>
<td>2020-01-02 09:21:01</td>
<td>80</td>
</tr>
<tr>
<td>2</td>
<td>1001</td>
<td>9001</td>
<td>2021-05-02 10:01:01</td>
<td>2021-05-02 10:30:01</td>
<td>81</td>
</tr>
<tr>
<td>3</td>
<td>1001</td>
<td>9001</td>
<td>2021-09-02 12:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
</tbody></table>
<p>请统计有未完成状态的试卷的未完成数 incomplete_cnt 和未完成率 incomplete_rate。由示例数据结果输出如下：</p>
<table>
<thead>
<tr>
<th>exam_id</th>
<th>incomplete_cnt</th>
<th>complete_rate</th>
</tr>
</thead>
<tbody><tr>
<td>9001</td>
<td>1</td>
<td>0.333</td>
</tr>
</tbody></table>
<p>解释：试卷 9001 有 3 次被作答的记录，其中两次完成，1 次未完成，因此未完成数为 1，未完成率为 0.333（保留 3 位小数）</p>
<p><strong>思路</strong>：</p>
<p>这题只需要注意一个是有条件限制，一个是没条件限制的；要么分别查询条件，然后合并；要么直接在 select 里面进行条件判断。</p>
<p><strong>答案</strong>：</p>
<p>写法 1：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> exam_id,</span><br><span class="line">       <span class="built_in">count</span>(submit_time <span class="keyword">IS</span> <span class="keyword">NULL</span> <span class="keyword">OR</span> <span class="keyword">NULL</span>) incomplete_cnt,</span><br><span class="line">       ROUND(<span class="built_in">count</span>(submit_time <span class="keyword">IS</span> <span class="keyword">NULL</span> <span class="keyword">OR</span> <span class="keyword">NULL</span>) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>), <span class="number">3</span>) complete_rate</span><br><span class="line"><span class="keyword">FROM</span> exam_record</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> exam_id</span><br><span class="line"><span class="keyword">HAVING</span> incomplete_cnt <span class="operator">&lt;&gt;</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>写法 2：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> exam_id,</span><br><span class="line">       <span class="built_in">count</span>(submit_time <span class="keyword">IS</span> <span class="keyword">NULL</span> <span class="keyword">OR</span> <span class="keyword">NULL</span>) incomplete_cnt,</span><br><span class="line">       ROUND(<span class="built_in">count</span>(submit_time <span class="keyword">IS</span> <span class="keyword">NULL</span> <span class="keyword">OR</span> <span class="keyword">NULL</span>) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>), <span class="number">3</span>) complete_rate</span><br><span class="line"><span class="keyword">FROM</span> exam_record</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> exam_id</span><br><span class="line"><span class="keyword">HAVING</span> incomplete_cnt <span class="operator">&lt;&gt;</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>两种写法都可以，只有中间的写法不一样，一个是对符合条件的才<code>COUNT</code>，一个是直接上<code>IF</code>,后者更为直观，最后这个<code>having</code>解释一下， 无论是 <code>complete_rate</code> 还是 <code>incomplete_cnt</code>，只要不为 0 即可，不为 0 就意味着有未完成的。</p>
<h3 id="0-级用户高难度试卷的平均用时和平均得分"><a href="#0-级用户高难度试卷的平均用时和平均得分" class="headerlink" title="0 级用户高难度试卷的平均用时和平均得分"></a>0 级用户高难度试卷的平均用时和平均得分</h3><p><strong>描述</strong>：</p>
<p>现有用户信息表 <code>user_info</code>（<code>uid</code> 用户 ID，<code>nick_name</code> 昵称, <code>achievement</code> 成就值, <code>level</code> 等级, <code>job</code> 职业方向, <code>register_time</code> 注册时间），数据如下：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>uid</th>
<th>nick_name</th>
<th>achievement</th>
<th>level</th>
<th>job</th>
<th>register_time</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1001</td>
<td>牛客 1 号</td>
<td>10</td>
<td>0</td>
<td>算法</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>2</td>
<td>1002</td>
<td>牛客 2 号</td>
<td>2100</td>
<td>6</td>
<td>算法</td>
<td>2020-01-01 10:00:00</td>
</tr>
</tbody></table>
<p>试卷信息表 <code>examination_info</code>（<code>exam_id</code> 试卷 ID, <code>tag</code> 试卷类别, <code>difficulty</code> 试卷难度, <code>duration</code> 考试时长, <code>release_time</code> 发布时间），数据如下：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>exam_id</th>
<th>tag</th>
<th>difficulty</th>
<th>duration</th>
<th>release_time</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>9001</td>
<td>SQL</td>
<td>hard</td>
<td>60</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>2</td>
<td>9002</td>
<td>SQL</td>
<td>easy</td>
<td>60</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>3</td>
<td>9004</td>
<td>算法</td>
<td>medium</td>
<td>80</td>
<td>2020-01-01 10:00:00</td>
</tr>
</tbody></table>
<p>试卷作答记录表 <code>exam_record</code>（<code>uid</code> 用户 ID, <code>exam_id</code> 试卷 ID, <code>start_time</code> 开始作答时间, <code>submit_time</code> 交卷时间, <code>score</code> 得分），数据如下：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>uid</th>
<th>exam_id</th>
<th>start_time</th>
<th>submit_time</th>
<th>score</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1001</td>
<td>9001</td>
<td>2020-01-02 09:01:01</td>
<td>2020-01-02 09:21:59</td>
<td>80</td>
</tr>
<tr>
<td>2</td>
<td>1001</td>
<td>9001</td>
<td>2021-05-02 10:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>3</td>
<td>1001</td>
<td>9002</td>
<td>2021-02-02 19:01:01</td>
<td>2021-02-02 19:30:01</td>
<td>87</td>
</tr>
<tr>
<td>4</td>
<td>1001</td>
<td>9001</td>
<td>2021-06-02 19:01:01</td>
<td>2021-06-02 19:32:00</td>
<td>20</td>
</tr>
<tr>
<td>5</td>
<td>1001</td>
<td>9002</td>
<td>2021-09-05 19:01:01</td>
<td>2021-09-05 19:40:01</td>
<td>89</td>
</tr>
<tr>
<td>6</td>
<td>1001</td>
<td>9002</td>
<td>2021-09-01 12:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>7</td>
<td>1002</td>
<td>9002</td>
<td>2021-05-05 18:01:01</td>
<td>2021-05-05 18:59:02</td>
<td>90</td>
</tr>
</tbody></table>
<p>请输出每个 0 级用户所有的高难度试卷考试平均用时和平均得分，未完成的默认试卷最大考试时长和 0 分处理。由示例数据结果输出如下：</p>
<table>
<thead>
<tr>
<th>uid</th>
<th>avg_score</th>
<th>avg_time_took</th>
</tr>
</thead>
<tbody><tr>
<td>1001</td>
<td>33</td>
<td>36.7</td>
</tr>
</tbody></table>
<p>解释：0 级用户有 1001，高难度试卷有 9001，1001 作答 9001 的记录有 3 条，分别用时 20 分钟、未完成（试卷时长 60 分钟）、30 分钟（未满 31 分钟），分别得分为 80 分、未完成（0 分处理）、20 分。因此他的平均用时为 110&#x2F;3&#x3D;36.7（保留一位小数），平均得分为 33 分（取整）</p>
<p><strong>思路</strong>：这题用<code>IF</code>是判断的最方便的，因为涉及到 NULL 值的判断。当然 <code>case when</code>也可以，大同小异。这题的难点就在于空值的处理，其他的这些查询条件什么的，我相信难不倒大家。</p>
<p><strong>答案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> UID,</span><br><span class="line">       round(<span class="built_in">avg</span>(new_socre)) <span class="keyword">AS</span> avg_score,</span><br><span class="line">       round(<span class="built_in">avg</span>(time_diff), <span class="number">1</span>) <span class="keyword">AS</span> avg_time_took</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  (<span class="keyword">SELECT</span> er.uid,</span><br><span class="line">          IF (er.submit_time <span class="keyword">IS</span> <span class="keyword">NOT NULL</span>, TIMESTAMPDIFF(<span class="keyword">MINUTE</span>, start_time, submit_time), ef.duration) <span class="keyword">AS</span> time_diff,</span><br><span class="line">          IF (er.submit_time <span class="keyword">IS</span> <span class="keyword">NOT NULL</span>,er.score,<span class="number">0</span>) <span class="keyword">AS</span> new_socre</span><br><span class="line">   <span class="keyword">FROM</span> exam_record er</span><br><span class="line">   <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> user_info uf <span class="keyword">ON</span> er.uid <span class="operator">=</span> uf.uid</span><br><span class="line">   <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> examination_info ef <span class="keyword">ON</span> er.exam_id <span class="operator">=</span> ef.exam_id</span><br><span class="line">   <span class="keyword">WHERE</span> uf.LEVEL <span class="operator">=</span> <span class="number">0</span> <span class="keyword">AND</span> ef.difficulty <span class="operator">=</span> <span class="string">&#x27;hard&#x27;</span> ) t</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> UID</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> UID</span><br></pre></td></tr></table></figure>

<h2 id="高级条件语句"><a href="#高级条件语句" class="headerlink" title="高级条件语句"></a>高级条件语句</h2><h3 id="筛选限定昵称成就值活跃日期的用户（较难）"><a href="#筛选限定昵称成就值活跃日期的用户（较难）" class="headerlink" title="筛选限定昵称成就值活跃日期的用户（较难）"></a>筛选限定昵称成就值活跃日期的用户（较难）</h3><p><strong>描述</strong>：</p>
<p>现有用户信息表 <code>user_info</code>（<code>uid</code> 用户 ID，<code>nick_name</code> 昵称, <code>achievement</code> 成就值, <code>level</code> 等级, <code>job</code> 职业方向, <code>register_time</code> 注册时间）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>uid</th>
<th>nick_name</th>
<th>achievement</th>
<th>level</th>
<th>job</th>
<th>register_time</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1001</td>
<td>牛客 1 号</td>
<td>1000</td>
<td>2</td>
<td>算法</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>2</td>
<td>1002</td>
<td>牛客 2 号</td>
<td>1200</td>
<td>3</td>
<td>算法</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>3</td>
<td>1003</td>
<td>进击的 3 号</td>
<td>2200</td>
<td>5</td>
<td>算法</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>4</td>
<td>1004</td>
<td>牛客 4 号</td>
<td>2500</td>
<td>6</td>
<td>算法</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>5</td>
<td>1005</td>
<td>牛客 5 号</td>
<td>3000</td>
<td>7</td>
<td>C++</td>
<td>2020-01-01 10:00:00</td>
</tr>
</tbody></table>
<p>试卷作答记录表 <code>exam_record</code>（<code>uid</code> 用户 ID, <code>exam_id</code> 试卷 ID, <code>start_time</code> 开始作答时间, <code>submit_time</code> 交卷时间, <code>score</code> 得分）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>uid</th>
<th>exam_id</th>
<th>start_time</th>
<th>submit_time</th>
<th>score</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1001</td>
<td>9001</td>
<td>2020-01-02 09:01:01</td>
<td>2020-01-02 09:21:59</td>
<td>80</td>
</tr>
<tr>
<td>3</td>
<td>1001</td>
<td>9002</td>
<td>2021-02-02 19:01:01</td>
<td>2021-02-02 19:30:01</td>
<td>87</td>
</tr>
<tr>
<td>2</td>
<td>1001</td>
<td>9001</td>
<td>2021-05-02 10:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>4</td>
<td>1001</td>
<td>9001</td>
<td>2021-06-02 19:01:01</td>
<td>2021-06-02 19:32:00</td>
<td>20</td>
</tr>
<tr>
<td>6</td>
<td>1001</td>
<td>9002</td>
<td>2021-09-01 12:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>5</td>
<td>1001</td>
<td>9002</td>
<td>2021-09-05 19:01:01</td>
<td>2021-09-05 19:40:01</td>
<td>89</td>
</tr>
<tr>
<td>11</td>
<td>1002</td>
<td>9001</td>
<td>2020-01-01 12:01:01</td>
<td>2020-01-01 12:31:01</td>
<td>81</td>
</tr>
<tr>
<td>12</td>
<td>1002</td>
<td>9002</td>
<td>2020-02-01 12:01:01</td>
<td>2020-02-01 12:31:01</td>
<td>82</td>
</tr>
<tr>
<td>13</td>
<td>1002</td>
<td>9002</td>
<td>2020-02-02 12:11:01</td>
<td>2020-02-02 12:31:01</td>
<td>83</td>
</tr>
<tr>
<td>7</td>
<td>1002</td>
<td>9002</td>
<td>2021-05-05 18:01:01</td>
<td>2021-05-05 18:59:02</td>
<td>90</td>
</tr>
<tr>
<td>16</td>
<td>1002</td>
<td>9001</td>
<td>2021-09-06 12:01:01</td>
<td>2021-09-06 12:21:01</td>
<td>80</td>
</tr>
<tr>
<td>17</td>
<td>1002</td>
<td>9001</td>
<td>2021-09-06 12:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>18</td>
<td>1002</td>
<td>9001</td>
<td>2021-09-07 12:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>8</td>
<td>1003</td>
<td>9003</td>
<td>2021-02-06 12:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>9</td>
<td>1003</td>
<td>9001</td>
<td>2021-09-07 10:01:01</td>
<td>2021-09-07 10:31:01</td>
<td>89</td>
</tr>
<tr>
<td>10</td>
<td>1004</td>
<td>9002</td>
<td>2021-08-06 12:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>14</td>
<td>1005</td>
<td>9001</td>
<td>2021-02-01 11:01:01</td>
<td>2021-02-01 11:31:01</td>
<td>84</td>
</tr>
<tr>
<td>15</td>
<td>1006</td>
<td>9001</td>
<td>2021-02-01 11:01:01</td>
<td>2021-02-01 11:31:01</td>
<td>84</td>
</tr>
</tbody></table>
<p>题目练习记录表 <code>practice_record</code>（<code>uid</code> 用户 ID, <code>question_id</code> 题目 ID, <code>submit_time</code> 提交时间, <code>score</code> 得分）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>uid</th>
<th>question_id</th>
<th>submit_time</th>
<th>score</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1001</td>
<td>8001</td>
<td>2021-08-02 11:41:01</td>
<td>60</td>
</tr>
<tr>
<td>2</td>
<td>1002</td>
<td>8001</td>
<td>2021-09-02 19:30:01</td>
<td>50</td>
</tr>
<tr>
<td>3</td>
<td>1002</td>
<td>8001</td>
<td>2021-09-02 19:20:01</td>
<td>70</td>
</tr>
<tr>
<td>4</td>
<td>1002</td>
<td>8002</td>
<td>2021-09-02 19:38:01</td>
<td>70</td>
</tr>
<tr>
<td>5</td>
<td>1003</td>
<td>8002</td>
<td>2021-09-01 19:38:01</td>
<td>80</td>
</tr>
</tbody></table>
<p>请找到昵称以『牛客』开头『号』结尾、成就值在 1200~2500 之间，且最近一次活跃（答题或作答试卷）在 2021 年 9 月的用户信息。</p>
<p>由示例数据结果输出如下：</p>
<table>
<thead>
<tr>
<th>uid</th>
<th>nick_name</th>
<th>achievement</th>
</tr>
</thead>
<tbody><tr>
<td>1002</td>
<td>牛客 2 号</td>
<td>1200</td>
</tr>
</tbody></table>
<p><strong>解释</strong>：昵称以『牛客』开头『号』结尾且成就值在 1200~2500 之间的有 1002、1004；</p>
<p>1002 最近一次试卷区活跃为 2021 年 9 月，最近一次题目区活跃为 2021 年 9 月；1004 最近一次试卷区活跃为 2021 年 8 月，题目区未活跃。</p>
<p>因此最终满足条件的只有 1002。</p>
<p><strong>思路</strong>：</p>
<p>先根据条件列出主要查询语句</p>
<p>昵称以『牛客』开头『号』结尾: <code>nick_name LIKE &quot;牛客%号&quot;</code></p>
<p>成就值在 1200~2500 之间：<code>achievement BETWEEN 1200 AND 2500</code></p>
<p>第三个条件因为限定了为 9 月，所以直接写就行：<code>( date_format( record.submit_time, &#39;%Y%m&#39; )= 202109 OR date_format( pr.submit_time, &#39;%Y%m&#39; )= 202109 )</code></p>
<p><strong>答案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> u_info.uid,</span><br><span class="line">                u_info.nick_name,</span><br><span class="line">                u_info.achievement</span><br><span class="line"><span class="keyword">FROM</span> user_info u_info</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> exam_record record <span class="keyword">ON</span> record.uid <span class="operator">=</span> u_info.uid</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> practice_record pr <span class="keyword">ON</span> u_info.uid <span class="operator">=</span> pr.uid</span><br><span class="line"><span class="keyword">WHERE</span> u_info.nick_name <span class="keyword">LIKE</span> &quot;牛客%号&quot;</span><br><span class="line">  <span class="keyword">AND</span> u_info.achievement <span class="keyword">BETWEEN</span> <span class="number">1200</span></span><br><span class="line">  <span class="keyword">AND</span> <span class="number">2500</span></span><br><span class="line">  <span class="keyword">AND</span> (date_format(record.submit_time, <span class="string">&#x27;%Y%m&#x27;</span>)<span class="operator">=</span> <span class="number">202109</span></span><br><span class="line">       <span class="keyword">OR</span> date_format(pr.submit_time, <span class="string">&#x27;%Y%m&#x27;</span>)<span class="operator">=</span> <span class="number">202109</span>)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> u_info.uid</span><br></pre></td></tr></table></figure>

<h3 id="筛选昵称规则和试卷规则的作答记录（较难）"><a href="#筛选昵称规则和试卷规则的作答记录（较难）" class="headerlink" title="筛选昵称规则和试卷规则的作答记录（较难）"></a>筛选昵称规则和试卷规则的作答记录（较难）</h3><p><strong>描述</strong>：</p>
<p>现有用户信息表 <code>user_info</code>（<code>uid</code> 用户 ID，<code>nick_name</code> 昵称, <code>achievement</code> 成就值, <code>level</code> 等级, <code>job</code> 职业方向, <code>register_time</code> 注册时间）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>uid</th>
<th>nick_name</th>
<th>achievement</th>
<th>level</th>
<th>job</th>
<th>register_time</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1001</td>
<td>牛客 1 号</td>
<td>1900</td>
<td>2</td>
<td>算法</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>2</td>
<td>1002</td>
<td>牛客 2 号</td>
<td>1200</td>
<td>3</td>
<td>算法</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>3</td>
<td>1003</td>
<td>牛客 3 号 ♂</td>
<td>2200</td>
<td>5</td>
<td>算法</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>4</td>
<td>1004</td>
<td>牛客 4 号</td>
<td>2500</td>
<td>6</td>
<td>算法</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>5</td>
<td>1005</td>
<td>牛客 555 号</td>
<td>2000</td>
<td>7</td>
<td>C++</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>6</td>
<td>1006</td>
<td>666666</td>
<td>3000</td>
<td>6</td>
<td>C++</td>
<td>2020-01-01 10:00:00</td>
</tr>
</tbody></table>
<p>试卷信息表 <code>examination_info</code>（<code>exam_id</code> 试卷 ID, <code>tag</code> 试卷类别, <code>difficulty</code> 试卷难度, <code>duration</code> 考试时长, <code>release_time</code> 发布时间）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>exam_id</th>
<th>tag</th>
<th>difficulty</th>
<th>duration</th>
<th>release_time</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>9001</td>
<td>C++</td>
<td>hard</td>
<td>60</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>2</td>
<td>9002</td>
<td>c#</td>
<td>hard</td>
<td>80</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>3</td>
<td>9003</td>
<td>SQL</td>
<td>medium</td>
<td>70</td>
<td>2020-01-01 10:00:00</td>
</tr>
</tbody></table>
<p>试卷作答记录表 <code>exam_record</code>（<code>uid</code> 用户 ID, <code>exam_id</code> 试卷 ID, <code>start_time</code> 开始作答时间, <code>submit_time</code> 交卷时间, <code>score</code> 得分）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>uid</th>
<th>exam_id</th>
<th>start_time</th>
<th>submit_time</th>
<th>score</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1001</td>
<td>9001</td>
<td>2020-01-02 09:01:01</td>
<td>2020-01-02 09:21:59</td>
<td>80</td>
</tr>
<tr>
<td>2</td>
<td>1001</td>
<td>9001</td>
<td>2021-05-02 10:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>4</td>
<td>1001</td>
<td>9001</td>
<td>2021-06-02 19:01:01</td>
<td>2021-06-02 19:32:00</td>
<td>20</td>
</tr>
<tr>
<td>3</td>
<td>1001</td>
<td>9002</td>
<td>2021-02-02 19:01:01</td>
<td>2021-02-02 19:30:01</td>
<td>87</td>
</tr>
<tr>
<td>5</td>
<td>1001</td>
<td>9002</td>
<td>2021-09-05 19:01:01</td>
<td>2021-09-05 19:40:01</td>
<td>89</td>
</tr>
<tr>
<td>6</td>
<td>1001</td>
<td>9002</td>
<td>2021-09-01 12:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>11</td>
<td>1002</td>
<td>9001</td>
<td>2020-01-01 12:01:01</td>
<td>2020-01-01 12:31:01</td>
<td>81</td>
</tr>
<tr>
<td>16</td>
<td>1002</td>
<td>9001</td>
<td>2021-09-06 12:01:01</td>
<td>2021-09-06 12:21:01</td>
<td>80</td>
</tr>
<tr>
<td>17</td>
<td>1002</td>
<td>9001</td>
<td>2021-09-06 12:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>18</td>
<td>1002</td>
<td>9001</td>
<td>2021-09-07 12:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>7</td>
<td>1002</td>
<td>9002</td>
<td>2021-05-05 18:01:01</td>
<td>2021-05-05 18:59:02</td>
<td>90</td>
</tr>
<tr>
<td>12</td>
<td>1002</td>
<td>9002</td>
<td>2020-02-01 12:01:01</td>
<td>2020-02-01 12:31:01</td>
<td>82</td>
</tr>
<tr>
<td>13</td>
<td>1002</td>
<td>9002</td>
<td>2020-02-02 12:11:01</td>
<td>2020-02-02 12:31:01</td>
<td>83</td>
</tr>
<tr>
<td>9</td>
<td>1003</td>
<td>9001</td>
<td>2021-09-07 10:01:01</td>
<td>2021-09-07 10:31:01</td>
<td>89</td>
</tr>
<tr>
<td>8</td>
<td>1003</td>
<td>9003</td>
<td>2021-02-06 12:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>10</td>
<td>1004</td>
<td>9002</td>
<td>2021-08-06 12:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>14</td>
<td>1005</td>
<td>9001</td>
<td>2021-02-01 11:01:01</td>
<td>2021-02-01 11:31:01</td>
<td>84</td>
</tr>
<tr>
<td>15</td>
<td>1006</td>
<td>9001</td>
<td>2021-02-01 11:01:01</td>
<td>2021-09-01 11:31:01</td>
<td>84</td>
</tr>
</tbody></table>
<p>找到昵称以”牛客”+纯数字+”号”或者纯数字组成的用户对于字母 c 开头的试卷类别（如 C,C++,c#等）的已完成的试卷 ID 和平均得分，按用户 ID、平均分升序排序。由示例数据结果输出如下：</p>
<table>
<thead>
<tr>
<th>uid</th>
<th>exam_id</th>
<th>avg_score</th>
</tr>
</thead>
<tbody><tr>
<td>1002</td>
<td>9001</td>
<td>81</td>
</tr>
<tr>
<td>1002</td>
<td>9002</td>
<td>85</td>
</tr>
<tr>
<td>1005</td>
<td>9001</td>
<td>84</td>
</tr>
<tr>
<td>1006</td>
<td>9001</td>
<td>84</td>
</tr>
</tbody></table>
<p>解释：昵称满足条件的用户有 1002、1004、1005、1006；</p>
<p>c 开头的试卷有 9001、9002；</p>
<p>满足上述条件的作答记录中，1002 完成 9001 的得分有 81、80，平均分为 81（80.5 取整四舍五入得 81）；</p>
<p>1002 完成 9002 的得分有 90、82、83，平均分为 85；</p>
<p><strong>思路</strong>：</p>
<p>还是老样子，既然给出了条件，就先把各个条件先写出来</p>
<p>找到昵称以”牛客”+纯数字+”号”或者纯数字组成的用户： 我最开始是这么写的：<code>nick_name LIKE &#39;牛客%号&#39; OR nick_name REGEXP &#39;^[0-9]+$&#39;</code>，如果表中有个 “牛客 H 号” ，那也能通过。</p>
<p>所以这里还得用正则： <code>nick_name LIKE &#39;^牛客[0-9]+号&#39;</code></p>
<p>对于字母 c 开头的试卷类别： <code>e_info.tag LIKE &#39;c%&#39;</code> 或者 <code>tag regexp &#39;^c|^C&#39;</code> 第一个也能匹配到大写 C</p>
<p><strong>答案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> UID,</span><br><span class="line">       exam_id,</span><br><span class="line">       ROUND(<span class="built_in">AVG</span>(score), <span class="number">0</span>) avg_score</span><br><span class="line"><span class="keyword">FROM</span> exam_record</span><br><span class="line"><span class="keyword">WHERE</span> UID <span class="keyword">IN</span></span><br><span class="line">    (<span class="keyword">SELECT</span> UID</span><br><span class="line">     <span class="keyword">FROM</span> user_info</span><br><span class="line">     <span class="keyword">WHERE</span> nick_name RLIKE &quot;^牛客[0-9]+号 $&quot;</span><br><span class="line">       <span class="keyword">OR</span> nick_name RLIKE &quot;^[0-9]+$&quot;)</span><br><span class="line">  <span class="keyword">AND</span> exam_id <span class="keyword">IN</span></span><br><span class="line">    (<span class="keyword">SELECT</span> exam_id</span><br><span class="line">     <span class="keyword">FROM</span> examination_info</span><br><span class="line">     <span class="keyword">WHERE</span> tag RLIKE &quot;^[cC]&quot;)</span><br><span class="line">  <span class="keyword">AND</span> score <span class="keyword">IS</span> <span class="keyword">NOT NULL</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> UID,exam_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> UID,avg_score;</span><br></pre></td></tr></table></figure>

<h3 id="根据指定记录是否存在输出不同情况（困难）"><a href="#根据指定记录是否存在输出不同情况（困难）" class="headerlink" title="根据指定记录是否存在输出不同情况（困难）"></a>根据指定记录是否存在输出不同情况（困难）</h3><p><strong>描述</strong>：</p>
<p>现有用户信息表 <code>user_info</code>（<code>uid</code> 用户 ID，<code>nick_name</code> 昵称, <code>achievement</code> 成就值, <code>level</code> 等级, <code>job</code> 职业方向, <code>register_time</code> 注册时间）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>uid</th>
<th>nick_name</th>
<th>achievement</th>
<th>level</th>
<th>job</th>
<th>register_time</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1001</td>
<td>牛客 1 号</td>
<td>19</td>
<td>0</td>
<td>算法</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>2</td>
<td>1002</td>
<td>牛客 2 号</td>
<td>1200</td>
<td>3</td>
<td>算法</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>3</td>
<td>1003</td>
<td>进击的 3 号</td>
<td>22</td>
<td>0</td>
<td>算法</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>4</td>
<td>1004</td>
<td>牛客 4 号</td>
<td>25</td>
<td>0</td>
<td>算法</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>5</td>
<td>1005</td>
<td>牛客 555 号</td>
<td>2000</td>
<td>7</td>
<td>C++</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>6</td>
<td>1006</td>
<td>666666</td>
<td>3000</td>
<td>6</td>
<td>C++</td>
<td>2020-01-01 10:00:00</td>
</tr>
</tbody></table>
<p>试卷作答记录表 <code>exam_record</code>（<code>uid</code> 用户 ID, <code>exam_id</code> 试卷 ID, <code>start_time</code> 开始作答时间, <code>submit_time</code> 交卷时间, <code>score</code> 得分）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>uid</th>
<th>exam_id</th>
<th>start_time</th>
<th>submit_time</th>
<th>score</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1001</td>
<td>9001</td>
<td>2020-01-02 09:01:01</td>
<td>2020-01-02 09:21:59</td>
<td>80</td>
</tr>
<tr>
<td>2</td>
<td>1001</td>
<td>9001</td>
<td>2021-05-02 10:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>3</td>
<td>1001</td>
<td>9002</td>
<td>2021-02-02 19:01:01</td>
<td>2021-02-02 19:30:01</td>
<td>87</td>
</tr>
<tr>
<td>4</td>
<td>1001</td>
<td>9002</td>
<td>2021-09-01 12:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>5</td>
<td>1001</td>
<td>9003</td>
<td>2021-09-02 12:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>6</td>
<td>1001</td>
<td>9004</td>
<td>2021-09-03 12:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>7</td>
<td>1002</td>
<td>9001</td>
<td>2020-01-01 12:01:01</td>
<td>2020-01-01 12:31:01</td>
<td>99</td>
</tr>
<tr>
<td>8</td>
<td>1002</td>
<td>9003</td>
<td>2020-02-01 12:01:01</td>
<td>2020-02-01 12:31:01</td>
<td>82</td>
</tr>
<tr>
<td>9</td>
<td>1002</td>
<td>9003</td>
<td>2020-02-02 12:11:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>10</td>
<td>1002</td>
<td>9002</td>
<td>2021-05-05 18:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>11</td>
<td>1002</td>
<td>9001</td>
<td>2021-09-06 12:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>12</td>
<td>1003</td>
<td>9003</td>
<td>2021-02-06 12:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>13</td>
<td>1003</td>
<td>9001</td>
<td>2021-09-07 10:01:01</td>
<td>2021-09-07 10:31:01</td>
<td>89</td>
</tr>
</tbody></table>
<p>请你筛选表中的数据，当有任意一个 0 级用户未完成试卷数大于 2 时，输出每个 0 级用户的试卷未完成数和未完成率（保留 3 位小数）；若不存在这样的用户，则输出所有有作答记录的用户的这两个指标。结果按未完成率升序排序。</p>
<p>由示例数据结果输出如下：</p>
<table>
<thead>
<tr>
<th>uid</th>
<th>incomplete_cnt</th>
<th>incomplete_rate</th>
</tr>
</thead>
<tbody><tr>
<td>1004</td>
<td>0</td>
<td>0.000</td>
</tr>
<tr>
<td>1003</td>
<td>1</td>
<td>0.500</td>
</tr>
<tr>
<td>1001</td>
<td>4</td>
<td>0.667</td>
</tr>
</tbody></table>
<p><strong>解释</strong>：0 级用户有 1001、1003、1004；他们作答试卷数和未完成数分别为：6:4、2:1、0:0；</p>
<p>存在 1001 这个 0 级用户未完成试卷数大于 2，因此输出这三个用户的未完成数和未完成率（1004 未作答过试卷，未完成率默认填 0，保留 3 位小数后是 0.000）；</p>
<p>结果按照未完成率升序排序。</p>
<p>附：如果 1001 不满足『未完成试卷数大于 2』，则需要输出 1001、1002、1003 的这两个指标，因为试卷作答记录表里只有这三个用户的作答记录。</p>
<p><strong>思路</strong>：</p>
<p>先把可能满足条件<strong>“0 级用户未完成试卷数大于 2”</strong>的 SQL 写出来</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ui.uid UID</span><br><span class="line"><span class="keyword">FROM</span> user_info ui</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> exam_record er <span class="keyword">ON</span> ui.uid <span class="operator">=</span> er.uid</span><br><span class="line"><span class="keyword">WHERE</span> ui.uid <span class="keyword">IN</span></span><br><span class="line">    (<span class="keyword">SELECT</span> ui.uid</span><br><span class="line">     <span class="keyword">FROM</span> user_info ui</span><br><span class="line">     <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> exam_record er <span class="keyword">ON</span> ui.uid <span class="operator">=</span> er.uid</span><br><span class="line">     <span class="keyword">WHERE</span> er.submit_time <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line">       <span class="keyword">AND</span> ui.LEVEL <span class="operator">=</span> <span class="number">0</span> )</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> ui.uid</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">sum</span>(IF(er.submit_time <span class="keyword">IS</span> <span class="keyword">NULL</span>, <span class="number">1</span>, <span class="number">0</span>)) <span class="operator">&gt;</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>然后再分别写出两种情况的 SQL 查询语句：</p>
<p>情况 1. 查询存在条件要求的 0 级用户的试卷未完成率</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	tmp1.uid uid,</span><br><span class="line">	<span class="built_in">sum</span>(</span><br><span class="line">	IF</span><br><span class="line">	( er.submit_time <span class="keyword">IS</span> <span class="keyword">NULL</span> <span class="keyword">AND</span> er.start_time <span class="keyword">IS</span> <span class="keyword">NOT NULL</span>, <span class="number">1</span>, <span class="number">0</span> )) incomplete_cnt,</span><br><span class="line">	round(</span><br><span class="line">		<span class="built_in">sum</span>(</span><br><span class="line">		IF</span><br><span class="line">		( er.submit_time <span class="keyword">IS</span> <span class="keyword">NULL</span> <span class="keyword">AND</span> er.start_time <span class="keyword">IS</span> <span class="keyword">NOT NULL</span>, <span class="number">1</span>, <span class="number">0</span> ))<span class="operator">/</span> <span class="built_in">count</span>( tmp1.uid ),</span><br><span class="line">		<span class="number">3</span></span><br><span class="line">	) incomplete_rate</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span></span><br><span class="line">		ui.uid</span><br><span class="line">	<span class="keyword">FROM</span></span><br><span class="line">		user_info ui</span><br><span class="line">		<span class="keyword">LEFT</span> <span class="keyword">JOIN</span> exam_record er <span class="keyword">ON</span> ui.uid <span class="operator">=</span> er.uid</span><br><span class="line">	<span class="keyword">WHERE</span></span><br><span class="line">		er.submit_time <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line">		<span class="keyword">AND</span> ui.LEVEL <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">	) tmp1</span><br><span class="line">	<span class="keyword">LEFT</span> <span class="keyword">JOIN</span> exam_record er <span class="keyword">ON</span> tmp1.uid <span class="operator">=</span> er.uid</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">	tmp1.uid</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">	incomplete_rate</span><br></pre></td></tr></table></figure>

<p>情况 2. 查询不存在条件要求时所有有作答记录的 yong 用户的试卷未完成率</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	ui.uid uid,</span><br><span class="line">	<span class="built_in">sum</span>( <span class="keyword">CASE</span> <span class="keyword">WHEN</span> er.submit_time <span class="keyword">IS</span> <span class="keyword">NULL</span> <span class="keyword">AND</span> er.start_time <span class="keyword">IS</span> <span class="keyword">NOT NULL</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span> ) incomplete_cnt,</span><br><span class="line">	round(</span><br><span class="line">		<span class="built_in">sum</span>(</span><br><span class="line">		IF</span><br><span class="line">		( er.submit_time <span class="keyword">IS</span> <span class="keyword">NULL</span> <span class="keyword">AND</span> er.start_time <span class="keyword">IS</span> <span class="keyword">NOT NULL</span>, <span class="number">1</span>, <span class="number">0</span> ))<span class="operator">/</span> <span class="built_in">count</span>( ui.uid ),</span><br><span class="line">		<span class="number">3</span></span><br><span class="line">	) incomplete_rate</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	user_info ui</span><br><span class="line">	<span class="keyword">JOIN</span> exam_record er <span class="keyword">ON</span> ui.uid <span class="operator">=</span> er.uid</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">	ui.uid</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">	incomplete_rate</span><br></pre></td></tr></table></figure>

<p>拼在一起，就是答案</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> host_user <span class="keyword">AS</span></span><br><span class="line">  (<span class="keyword">SELECT</span> ui.uid UID</span><br><span class="line">   <span class="keyword">FROM</span> user_info ui</span><br><span class="line">   <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> exam_record er <span class="keyword">ON</span> ui.uid <span class="operator">=</span> er.uid</span><br><span class="line">   <span class="keyword">WHERE</span> ui.uid <span class="keyword">IN</span></span><br><span class="line">       (<span class="keyword">SELECT</span> ui.uid</span><br><span class="line">        <span class="keyword">FROM</span> user_info ui</span><br><span class="line">        <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> exam_record er <span class="keyword">ON</span> ui.uid <span class="operator">=</span> er.uid</span><br><span class="line">        <span class="keyword">WHERE</span> er.submit_time <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line">          <span class="keyword">AND</span> ui.LEVEL <span class="operator">=</span> <span class="number">0</span> )</span><br><span class="line">   <span class="keyword">GROUP</span> <span class="keyword">BY</span> ui.uid</span><br><span class="line">   <span class="keyword">HAVING</span> <span class="built_in">sum</span>(IF (er.submit_time <span class="keyword">IS</span> <span class="keyword">NULL</span>, <span class="number">1</span>, <span class="number">0</span>))<span class="operator">&gt;</span> <span class="number">2</span>),</span><br><span class="line">     tt1 <span class="keyword">AS</span></span><br><span class="line">  (<span class="keyword">SELECT</span> tmp1.uid UID,</span><br><span class="line">                   <span class="built_in">sum</span>(IF (er.submit_time <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line">                           <span class="keyword">AND</span> er.start_time <span class="keyword">IS</span> <span class="keyword">NOT NULL</span>, <span class="number">1</span>, <span class="number">0</span>)) incomplete_cnt,</span><br><span class="line">                   round(<span class="built_in">sum</span>(IF (er.submit_time <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line">                                 <span class="keyword">AND</span> er.start_time <span class="keyword">IS</span> <span class="keyword">NOT NULL</span>, <span class="number">1</span>, <span class="number">0</span>))<span class="operator">/</span> <span class="built_in">count</span>(tmp1.uid), <span class="number">3</span>) incomplete_rate</span><br><span class="line">   <span class="keyword">FROM</span></span><br><span class="line">     (<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> ui.uid</span><br><span class="line">      <span class="keyword">FROM</span> user_info ui</span><br><span class="line">      <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> exam_record er <span class="keyword">ON</span> ui.uid <span class="operator">=</span> er.uid</span><br><span class="line">      <span class="keyword">WHERE</span> er.submit_time <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line">        <span class="keyword">AND</span> ui.LEVEL <span class="operator">=</span> <span class="number">0</span> ) tmp1</span><br><span class="line">   <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> exam_record er <span class="keyword">ON</span> tmp1.uid <span class="operator">=</span> er.uid</span><br><span class="line">   <span class="keyword">GROUP</span> <span class="keyword">BY</span> tmp1.uid</span><br><span class="line">   <span class="keyword">ORDER</span> <span class="keyword">BY</span> incomplete_rate),</span><br><span class="line">     tt2 <span class="keyword">AS</span></span><br><span class="line">  (<span class="keyword">SELECT</span> ui.uid UID,</span><br><span class="line">                 <span class="built_in">sum</span>(<span class="keyword">CASE</span></span><br><span class="line">                         <span class="keyword">WHEN</span> er.submit_time <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line">                              <span class="keyword">AND</span> er.start_time <span class="keyword">IS</span> <span class="keyword">NOT NULL</span> <span class="keyword">THEN</span> <span class="number">1</span></span><br><span class="line">                         <span class="keyword">ELSE</span> <span class="number">0</span></span><br><span class="line">                     <span class="keyword">END</span>) incomplete_cnt,</span><br><span class="line">                 round(<span class="built_in">sum</span>(IF (er.submit_time <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line">                               <span class="keyword">AND</span> er.start_time <span class="keyword">IS</span> <span class="keyword">NOT NULL</span>, <span class="number">1</span>, <span class="number">0</span>))<span class="operator">/</span> <span class="built_in">count</span>(ui.uid), <span class="number">3</span>) incomplete_rate</span><br><span class="line">   <span class="keyword">FROM</span> user_info ui</span><br><span class="line">   <span class="keyword">JOIN</span> exam_record er <span class="keyword">ON</span> ui.uid <span class="operator">=</span> er.uid</span><br><span class="line">   <span class="keyword">GROUP</span> <span class="keyword">BY</span> ui.uid</span><br><span class="line">   <span class="keyword">ORDER</span> <span class="keyword">BY</span> incomplete_rate)</span><br><span class="line">  (<span class="keyword">SELECT</span> tt1.<span class="operator">*</span></span><br><span class="line">   <span class="keyword">FROM</span> tt1</span><br><span class="line">   <span class="keyword">LEFT</span> <span class="keyword">JOIN</span></span><br><span class="line">     (<span class="keyword">SELECT</span> UID</span><br><span class="line">      <span class="keyword">FROM</span> host_user) t1 <span class="keyword">ON</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">   <span class="keyword">WHERE</span> t1.uid <span class="keyword">IS</span> <span class="keyword">NOT NULL</span> )</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line">  (<span class="keyword">SELECT</span> tt2.<span class="operator">*</span></span><br><span class="line">   <span class="keyword">FROM</span> tt2</span><br><span class="line">   <span class="keyword">LEFT</span> <span class="keyword">JOIN</span></span><br><span class="line">     (<span class="keyword">SELECT</span> UID</span><br><span class="line">      <span class="keyword">FROM</span> host_user) t2 <span class="keyword">ON</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">   <span class="keyword">WHERE</span> t2.uid <span class="keyword">IS</span> <span class="keyword">NULL</span>)</span><br></pre></td></tr></table></figure>

<p>V2 版本（根据上面做出的改进，答案缩短了，逻辑更强）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	ui.uid,</span><br><span class="line">	<span class="built_in">SUM</span>(</span><br><span class="line">	IF</span><br><span class="line">	( start_time <span class="keyword">IS</span> <span class="keyword">NOT NULL</span> <span class="keyword">AND</span> score <span class="keyword">IS</span> <span class="keyword">NULL</span>, <span class="number">1</span>, <span class="number">0</span> )) <span class="keyword">AS</span> incomplete_cnt,#<span class="number">3.</span>试卷未完成数</span><br><span class="line">	ROUND( <span class="built_in">AVG</span>( IF ( start_time <span class="keyword">IS</span> <span class="keyword">NOT NULL</span> <span class="keyword">AND</span> score <span class="keyword">IS</span> <span class="keyword">NULL</span>, <span class="number">1</span>, <span class="number">0</span> )), <span class="number">3</span> ) <span class="keyword">AS</span> incomplete_rate #<span class="number">4.</span>未完成率</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	user_info ui</span><br><span class="line">	<span class="keyword">LEFT</span> <span class="keyword">JOIN</span> exam_record <span class="keyword">USING</span> ( uid )</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line"><span class="keyword">CASE</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">WHEN</span> (#<span class="number">1.</span>当有任意一个<span class="number">0</span>级用户未完成试卷数大于<span class="number">2</span>时</span><br><span class="line">		<span class="keyword">SELECT</span></span><br><span class="line">			<span class="built_in">MAX</span>( lv0_incom_cnt )</span><br><span class="line">		<span class="keyword">FROM</span></span><br><span class="line">			(</span><br><span class="line">			<span class="keyword">SELECT</span></span><br><span class="line">				<span class="built_in">SUM</span>(</span><br><span class="line">				IF</span><br><span class="line">				( score <span class="keyword">IS</span> <span class="keyword">NULL</span>, <span class="number">1</span>, <span class="number">0</span> )) <span class="keyword">AS</span> lv0_incom_cnt</span><br><span class="line">			<span class="keyword">FROM</span></span><br><span class="line">				user_info</span><br><span class="line">				<span class="keyword">JOIN</span> exam_record <span class="keyword">USING</span> ( uid )</span><br><span class="line">			<span class="keyword">WHERE</span></span><br><span class="line">				LEVEL <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">			<span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">				uid</span><br><span class="line">			) table1</span><br><span class="line">			)<span class="operator">&gt;</span> <span class="number">2</span> <span class="keyword">THEN</span></span><br><span class="line">			uid <span class="keyword">IN</span> ( #<span class="number">1.1</span>找出每个<span class="number">0</span>级用户</span><br><span class="line">			<span class="keyword">SELECT</span> uid <span class="keyword">FROM</span> user_info <span class="keyword">WHERE</span> LEVEL <span class="operator">=</span> <span class="number">0</span> ) <span class="keyword">ELSE</span> uid <span class="keyword">IN</span> ( #<span class="number">2.</span>若不存在这样的用户，找出有作答记录的用户</span><br><span class="line">			<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> uid <span class="keyword">FROM</span> exam_record )</span><br><span class="line">		<span class="keyword">END</span></span><br><span class="line">		<span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">			ui.uid</span><br><span class="line">	<span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">	incomplete_rate #<span class="number">5.</span>结果按未完成率升序排序</span><br></pre></td></tr></table></figure>

<h3 id="各用户等级的不同得分表现占比（较难）"><a href="#各用户等级的不同得分表现占比（较难）" class="headerlink" title="各用户等级的不同得分表现占比（较难）"></a>各用户等级的不同得分表现占比（较难）</h3><p><strong>描述</strong>：</p>
<p>现有用户信息表 <code>user_info</code>（<code>uid</code> 用户 ID，<code>nick_name</code> 昵称, <code>achievement</code> 成就值, <code>level</code> 等级, <code>job</code> 职业方向, <code>register_time</code> 注册时间）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>uid</th>
<th>nick_name</th>
<th>achievement</th>
<th>level</th>
<th>job</th>
<th>register_time</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1001</td>
<td>牛客 1 号</td>
<td>19</td>
<td>0</td>
<td>算法</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>2</td>
<td>1002</td>
<td>牛客 2 号</td>
<td>1200</td>
<td>3</td>
<td>算法</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>3</td>
<td>1003</td>
<td>牛客 3 号 ♂</td>
<td>22</td>
<td>0</td>
<td>算法</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>4</td>
<td>1004</td>
<td>牛客 4 号</td>
<td>25</td>
<td>0</td>
<td>算法</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>5</td>
<td>1005</td>
<td>牛客 555 号</td>
<td>2000</td>
<td>7</td>
<td>C++</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>6</td>
<td>1006</td>
<td>666666</td>
<td>3000</td>
<td>6</td>
<td>C++</td>
<td>2020-01-01 10:00:00</td>
</tr>
</tbody></table>
<p>试卷作答记录表 exam_record（uid 用户 ID, exam_id 试卷 ID, start_time 开始作答时间, submit_time 交卷时间, score 得分）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>uid</th>
<th>exam_id</th>
<th>start_time</th>
<th>submit_time</th>
<th>score</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1001</td>
<td>9001</td>
<td>2020-01-02 09:01:01</td>
<td>2020-01-02 09:21:59</td>
<td>80</td>
</tr>
<tr>
<td>2</td>
<td>1001</td>
<td>9001</td>
<td>2021-05-02 10:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>3</td>
<td>1001</td>
<td>9002</td>
<td>2021-02-02 19:01:01</td>
<td>2021-02-02 19:30:01</td>
<td>75</td>
</tr>
<tr>
<td>4</td>
<td>1001</td>
<td>9002</td>
<td>2021-09-01 12:01:01</td>
<td>2021-09-01 12:11:01</td>
<td>60</td>
</tr>
<tr>
<td>5</td>
<td>1001</td>
<td>9003</td>
<td>2021-09-02 12:01:01</td>
<td>2021-09-02 12:41:01</td>
<td>90</td>
</tr>
<tr>
<td>6</td>
<td>1001</td>
<td>9001</td>
<td>2021-06-02 19:01:01</td>
<td>2021-06-02 19:32:00</td>
<td>20</td>
</tr>
<tr>
<td>7</td>
<td>1001</td>
<td>9002</td>
<td>2021-09-05 19:01:01</td>
<td>2021-09-05 19:40:01</td>
<td>89</td>
</tr>
<tr>
<td>8</td>
<td>1001</td>
<td>9004</td>
<td>2021-09-03 12:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>9</td>
<td>1002</td>
<td>9001</td>
<td>2020-01-01 12:01:01</td>
<td>2020-01-01 12:31:01</td>
<td>99</td>
</tr>
<tr>
<td>10</td>
<td>1002</td>
<td>9003</td>
<td>2020-02-01 12:01:01</td>
<td>2020-02-01 12:31:01</td>
<td>82</td>
</tr>
<tr>
<td>11</td>
<td>1002</td>
<td>9003</td>
<td>2020-02-02 12:11:01</td>
<td>2020-02-02 12:41:01</td>
<td>76</td>
</tr>
</tbody></table>
<p>为了得到用户试卷作答的定性表现，我们将试卷得分按分界点[90,75,60]分为优良中差四个得分等级（分界点划分到左区间），请统计不同用户等级的人在完成过的试卷中各得分等级占比（结果保留 3 位小数），未完成过试卷的用户无需输出，结果按用户等级降序、占比降序排序。</p>
<p>由示例数据结果输出如下：</p>
<table>
<thead>
<tr>
<th>level</th>
<th>score_grade</th>
<th>ratio</th>
</tr>
</thead>
<tbody><tr>
<td>3</td>
<td>良</td>
<td>0.667</td>
</tr>
<tr>
<td>3</td>
<td>优</td>
<td>0.333</td>
</tr>
<tr>
<td>0</td>
<td>良</td>
<td>0.500</td>
</tr>
<tr>
<td>0</td>
<td>中</td>
<td>0.167</td>
</tr>
<tr>
<td>0</td>
<td>优</td>
<td>0.167</td>
</tr>
<tr>
<td>0</td>
<td>差</td>
<td>0.167</td>
</tr>
</tbody></table>
<p>解释：完成过试卷的用户有 1001、1002；完成了的试卷对应的用户等级和分数等级如下：</p>
<table>
<thead>
<tr>
<th>uid</th>
<th>exam_id</th>
<th>score</th>
<th>level</th>
<th>score_grade</th>
</tr>
</thead>
<tbody><tr>
<td>1001</td>
<td>9001</td>
<td>80</td>
<td>0</td>
<td>良</td>
</tr>
<tr>
<td>1001</td>
<td>9002</td>
<td>75</td>
<td>0</td>
<td>良</td>
</tr>
<tr>
<td>1001</td>
<td>9002</td>
<td>60</td>
<td>0</td>
<td>中</td>
</tr>
<tr>
<td>1001</td>
<td>9003</td>
<td>90</td>
<td>0</td>
<td>优</td>
</tr>
<tr>
<td>1001</td>
<td>9001</td>
<td>20</td>
<td>0</td>
<td>差</td>
</tr>
<tr>
<td>1001</td>
<td>9002</td>
<td>89</td>
<td>0</td>
<td>良</td>
</tr>
<tr>
<td>1002</td>
<td>9001</td>
<td>99</td>
<td>3</td>
<td>优</td>
</tr>
<tr>
<td>1002</td>
<td>9003</td>
<td>82</td>
<td>3</td>
<td>良</td>
</tr>
<tr>
<td>1002</td>
<td>9003</td>
<td>76</td>
<td>3</td>
<td>良</td>
</tr>
</tbody></table>
<p>因此 0 级用户（只有 1001）的各分数等级比例为：优 1&#x2F;6，良 1&#x2F;6，中 1&#x2F;6，差 3&#x2F;6；3 级用户（只有 1002）各分数等级比例为：优 1&#x2F;3，良 2&#x2F;3。结果保留 3 位小数。</p>
<p><strong>思路</strong>：</p>
<p>先把 <strong>“将试卷得分按分界点[90,75,60]分为优良中差四个得分等级”</strong>这个条件写出来，这里可以用到<code>case when</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CASE</span></span><br><span class="line">		<span class="keyword">WHEN</span> a.score <span class="operator">&gt;=</span> <span class="number">90</span> <span class="keyword">THEN</span></span><br><span class="line">		<span class="string">&#x27;优&#x27;</span></span><br><span class="line">		<span class="keyword">WHEN</span> a.score <span class="operator">&lt;</span> <span class="number">90</span> <span class="keyword">AND</span> a.score <span class="operator">&gt;=</span> <span class="number">75</span> <span class="keyword">THEN</span></span><br><span class="line">		<span class="string">&#x27;良&#x27;</span></span><br><span class="line">		<span class="keyword">WHEN</span> a.score <span class="operator">&lt;</span> <span class="number">75</span> <span class="keyword">AND</span> a.score <span class="operator">&gt;=</span> <span class="number">60</span> <span class="keyword">THEN</span></span><br><span class="line">	<span class="string">&#x27;中&#x27;</span> <span class="keyword">ELSE</span> <span class="string">&#x27;差&#x27;</span></span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>

<p>这题的关键点就在于这，其他剩下的就是条件拼接了</p>
<p><strong>答案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.LEVEL,</span><br><span class="line">       a.score_grade,</span><br><span class="line">       ROUND(a.cur_count <span class="operator">/</span> b.total_num, <span class="number">3</span>) <span class="keyword">AS</span> ratio</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  (<span class="keyword">SELECT</span> b.LEVEL <span class="keyword">AS</span> LEVEL,</span><br><span class="line">          (<span class="keyword">CASE</span></span><br><span class="line">               <span class="keyword">WHEN</span> a.score <span class="operator">&gt;=</span> <span class="number">90</span> <span class="keyword">THEN</span> <span class="string">&#x27;优&#x27;</span></span><br><span class="line">               <span class="keyword">WHEN</span> a.score <span class="operator">&lt;</span> <span class="number">90</span></span><br><span class="line">                    <span class="keyword">AND</span> a.score <span class="operator">&gt;=</span> <span class="number">75</span> <span class="keyword">THEN</span> <span class="string">&#x27;良&#x27;</span></span><br><span class="line">               <span class="keyword">WHEN</span> a.score <span class="operator">&lt;</span> <span class="number">75</span></span><br><span class="line">                    <span class="keyword">AND</span> a.score <span class="operator">&gt;=</span> <span class="number">60</span> <span class="keyword">THEN</span> <span class="string">&#x27;中&#x27;</span></span><br><span class="line">               <span class="keyword">ELSE</span> <span class="string">&#x27;差&#x27;</span></span><br><span class="line">           <span class="keyword">END</span>) <span class="keyword">AS</span> score_grade,</span><br><span class="line">          <span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">AS</span> cur_count</span><br><span class="line">   <span class="keyword">FROM</span> exam_record a</span><br><span class="line">   <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> user_info b <span class="keyword">ON</span> a.uid <span class="operator">=</span> b.uid</span><br><span class="line">   <span class="keyword">WHERE</span> a.submit_time <span class="keyword">IS</span> <span class="keyword">NOT NULL</span></span><br><span class="line">   <span class="keyword">GROUP</span> <span class="keyword">BY</span> b.LEVEL,</span><br><span class="line">            score_grade) a</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span></span><br><span class="line">  (<span class="keyword">SELECT</span> b.LEVEL <span class="keyword">AS</span> LEVEL,</span><br><span class="line">          <span class="built_in">count</span>(b.LEVEL) <span class="keyword">AS</span> total_num</span><br><span class="line">   <span class="keyword">FROM</span> exam_record a</span><br><span class="line">   <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> user_info b <span class="keyword">ON</span> a.uid <span class="operator">=</span> b.uid</span><br><span class="line">   <span class="keyword">WHERE</span> a.submit_time <span class="keyword">IS</span> <span class="keyword">NOT NULL</span></span><br><span class="line">   <span class="keyword">GROUP</span> <span class="keyword">BY</span> b.LEVEL) b <span class="keyword">ON</span> a.LEVEL <span class="operator">=</span> b.LEVEL</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> a.LEVEL <span class="keyword">DESC</span>,</span><br><span class="line">         ratio <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>

<h2 id="限量查询"><a href="#限量查询" class="headerlink" title="限量查询"></a>限量查询</h2><h3 id="注册时间最早的三个人"><a href="#注册时间最早的三个人" class="headerlink" title="注册时间最早的三个人"></a>注册时间最早的三个人</h3><p><strong>描述</strong>：</p>
<p>现有用户信息表 <code>user_info</code>（<code>uid</code> 用户 ID，<code>nick_name</code> 昵称, <code>achievement</code> 成就值, <code>level</code> 等级, <code>job</code> 职业方向, <code>register_time</code> 注册时间）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>uid</th>
<th>nick_name</th>
<th>achievement</th>
<th>level</th>
<th>job</th>
<th>register_time</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1001</td>
<td>牛客 1 号</td>
<td>19</td>
<td>0</td>
<td>算法</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>2</td>
<td>1002</td>
<td>牛客 2 号</td>
<td>1200</td>
<td>3</td>
<td>算法</td>
<td>2020-02-01 10:00:00</td>
</tr>
<tr>
<td>3</td>
<td>1003</td>
<td>牛客 3 号 ♂</td>
<td>22</td>
<td>0</td>
<td>算法</td>
<td>2020-01-02 10:00:00</td>
</tr>
<tr>
<td>4</td>
<td>1004</td>
<td>牛客 4 号</td>
<td>25</td>
<td>0</td>
<td>算法</td>
<td>2020-01-02 11:00:00</td>
</tr>
<tr>
<td>5</td>
<td>1005</td>
<td>牛客 555 号</td>
<td>4000</td>
<td>7</td>
<td>C++</td>
<td>2020-01-11 10:00:00</td>
</tr>
<tr>
<td>6</td>
<td>1006</td>
<td>666666</td>
<td>3000</td>
<td>6</td>
<td>C++</td>
<td>2020-11-01 10:00:00</td>
</tr>
</tbody></table>
<p>请从中找到注册时间最早的 3 个人。由示例数据结果输出如下：</p>
<table>
<thead>
<tr>
<th>uid</th>
<th>nick_name</th>
<th>register_time</th>
</tr>
</thead>
<tbody><tr>
<td>1001</td>
<td>牛客 1</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>1003</td>
<td>牛客 3 号 ♂</td>
<td>2020-01-02 10:00:00</td>
</tr>
<tr>
<td>1004</td>
<td>牛客 4 号</td>
<td>2020-01-02 11:00:00</td>
</tr>
</tbody></table>
<p>解释：按注册时间排序后选取前三名，输出其用户 ID、昵称、注册时间。</p>
<p><strong>答案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> uid, nick_name, register_time</span><br><span class="line">    <span class="keyword">FROM</span> user_info</span><br><span class="line">    <span class="keyword">ORDER</span> <span class="keyword">BY</span> register_time</span><br><span class="line">    LIMIT <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h3 id="注册当天就完成了试卷的名单第三页（较难）"><a href="#注册当天就完成了试卷的名单第三页（较难）" class="headerlink" title="注册当天就完成了试卷的名单第三页（较难）"></a>注册当天就完成了试卷的名单第三页（较难）</h3><p><strong>描述</strong>：现有用户信息表 <code>user_info</code>（<code>uid</code> 用户 ID，<code>nick_name</code> 昵称, <code>achievement</code> 成就值, <code>level</code> 等级, <code>job</code> 职业方向, <code>register_time</code> 注册时间）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>uid</th>
<th>nick_name</th>
<th>achievement</th>
<th>level</th>
<th>job</th>
<th>register_time</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1001</td>
<td>牛客 1</td>
<td>19</td>
<td>0</td>
<td>算法</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>2</td>
<td>1002</td>
<td>牛客 2 号</td>
<td>1200</td>
<td>3</td>
<td>算法</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>3</td>
<td>1003</td>
<td>牛客 3 号 ♂</td>
<td>22</td>
<td>0</td>
<td>算法</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>4</td>
<td>1004</td>
<td>牛客 4 号</td>
<td>25</td>
<td>0</td>
<td>算法</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>5</td>
<td>1005</td>
<td>牛客 555 号</td>
<td>4000</td>
<td>7</td>
<td>算法</td>
<td>2020-01-11 10:00:00</td>
</tr>
<tr>
<td>6</td>
<td>1006</td>
<td>牛客 6 号</td>
<td>25</td>
<td>0</td>
<td>算法</td>
<td>2020-01-02 11:00:00</td>
</tr>
<tr>
<td>7</td>
<td>1007</td>
<td>牛客 7 号</td>
<td>25</td>
<td>0</td>
<td>算法</td>
<td>2020-01-02 11:00:00</td>
</tr>
<tr>
<td>8</td>
<td>1008</td>
<td>牛客 8 号</td>
<td>25</td>
<td>0</td>
<td>算法</td>
<td>2020-01-02 11:00:00</td>
</tr>
<tr>
<td>9</td>
<td>1009</td>
<td>牛客 9 号</td>
<td>25</td>
<td>0</td>
<td>算法</td>
<td>2020-01-02 11:00:00</td>
</tr>
<tr>
<td>10</td>
<td>1010</td>
<td>牛客 10 号</td>
<td>25</td>
<td>0</td>
<td>算法</td>
<td>2020-01-02 11:00:00</td>
</tr>
<tr>
<td>11</td>
<td>1011</td>
<td>666666</td>
<td>3000</td>
<td>6</td>
<td>C++</td>
<td>2020-01-02 10:00:00</td>
</tr>
</tbody></table>
<p>试卷信息表 examination_info（exam_id 试卷 ID, tag 试卷类别, difficulty 试卷难度, duration 考试时长, release_time 发布时间）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>exam_id</th>
<th>tag</th>
<th>difficulty</th>
<th>duration</th>
<th>release_time</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>9001</td>
<td>算法</td>
<td>hard</td>
<td>60</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>2</td>
<td>9002</td>
<td>算法</td>
<td>hard</td>
<td>80</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>3</td>
<td>9003</td>
<td>SQL</td>
<td>medium</td>
<td>70</td>
<td>2020-01-01 10:00:00</td>
</tr>
</tbody></table>
<p>试卷作答记录表 <code>exam_record</code>（<code>uid</code> 用户 ID, <code>exam_id</code> 试卷 ID, <code>start_time</code> 开始作答时间, <code>submit_time</code> 交卷时间, <code>score</code> 得分）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>uid</th>
<th>exam_id</th>
<th>start_time</th>
<th>submit_time</th>
<th>score</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1001</td>
<td>9001</td>
<td>2020-01-02 09:01:01</td>
<td>2020-01-02 09:21:59</td>
<td>80</td>
</tr>
<tr>
<td>2</td>
<td>1002</td>
<td>9003</td>
<td>2020-01-20 10:01:01</td>
<td>2020-01-20 10:10:01</td>
<td>81</td>
</tr>
<tr>
<td>3</td>
<td>1002</td>
<td>9002</td>
<td>2020-01-01 12:11:01</td>
<td>2020-01-01 12:31:01</td>
<td>83</td>
</tr>
<tr>
<td>4</td>
<td>1003</td>
<td>9002</td>
<td>2020-01-01 19:01:01</td>
<td>2020-01-01 19:30:01</td>
<td>75</td>
</tr>
<tr>
<td>5</td>
<td>1004</td>
<td>9002</td>
<td>2020-01-01 12:01:01</td>
<td>2020-01-01 12:11:01</td>
<td>60</td>
</tr>
<tr>
<td>6</td>
<td>1005</td>
<td>9002</td>
<td>2020-01-01 12:01:01</td>
<td>2020-01-01 12:41:01</td>
<td>90</td>
</tr>
<tr>
<td>7</td>
<td>1006</td>
<td>9001</td>
<td>2020-01-02 19:01:01</td>
<td>2020-01-02 19:32:00</td>
<td>20</td>
</tr>
<tr>
<td>8</td>
<td>1007</td>
<td>9002</td>
<td>2020-01-02 19:01:01</td>
<td>2020-01-02 19:40:01</td>
<td>89</td>
</tr>
<tr>
<td>9</td>
<td>1008</td>
<td>9003</td>
<td>2020-01-02 12:01:01</td>
<td>2020-01-02 12:20:01</td>
<td>99</td>
</tr>
<tr>
<td>10</td>
<td>1008</td>
<td>9001</td>
<td>2020-01-02 12:01:01</td>
<td>2020-01-02 12:31:01</td>
<td>98</td>
</tr>
<tr>
<td>11</td>
<td>1009</td>
<td>9002</td>
<td>2020-01-02 12:01:01</td>
<td>2020-01-02 12:31:01</td>
<td>82</td>
</tr>
<tr>
<td>12</td>
<td>1010</td>
<td>9002</td>
<td>2020-01-02 12:11:01</td>
<td>2020-01-02 12:41:01</td>
<td>76</td>
</tr>
<tr>
<td>13</td>
<td>1011</td>
<td>9001</td>
<td>2020-01-02 10:01:01</td>
<td>2020-01-02 10:31:01</td>
<td>89</td>
</tr>
</tbody></table>
<p><img src="https://oss.javaguide.cn/github/javaguide/database/sql/D2B491866B85826119EE3474F10D3636.png"></p>
<p>找到求职方向为算法工程师，且注册当天就完成了算法类试卷的人，按参加过的所有考试最高得分排名。排名榜很长，我们将采用分页展示，每页 3 条，现在需要你取出第 3 页（页码从 1 开始）的人的信息。</p>
<p>由示例数据结果输出如下：</p>
<table>
<thead>
<tr>
<th>uid</th>
<th>level</th>
<th>register_time</th>
<th>max_score</th>
</tr>
</thead>
<tbody><tr>
<td>1010</td>
<td>0</td>
<td>2020-01-02 11:00:00</td>
<td>76</td>
</tr>
<tr>
<td>1003</td>
<td>0</td>
<td>2020-01-01 10:00:00</td>
<td>75</td>
</tr>
<tr>
<td>1004</td>
<td>0</td>
<td>2020-01-01 11:00:00</td>
<td>60</td>
</tr>
</tbody></table>
<p>解释：除了 1011 其他用户的求职方向都为算法工程师；算法类试卷有 9001 和 9002，11 个用户注册当天都完成了算法类试卷；计算他们的所有考试最大分时，只有 1002 和 1008 完成了两次考试，其他人只完成了一场考试，1002 两场考试最高分为 81，1008 最高分为 99。</p>
<p>按最高分排名如下：</p>
<table>
<thead>
<tr>
<th>uid</th>
<th>level</th>
<th>register_time</th>
<th>max_score</th>
</tr>
</thead>
<tbody><tr>
<td>1008</td>
<td>0</td>
<td>2020-01-02 11:00:00</td>
<td>99</td>
</tr>
<tr>
<td>1005</td>
<td>7</td>
<td>2020-01-01 10:00:00</td>
<td>90</td>
</tr>
<tr>
<td>1007</td>
<td>0</td>
<td>2020-01-02 11:00:00</td>
<td>89</td>
</tr>
<tr>
<td>1002</td>
<td>3</td>
<td>2020-01-01 10:00:00</td>
<td>83</td>
</tr>
<tr>
<td>1009</td>
<td>0</td>
<td>2020-01-02 11:00:00</td>
<td>82</td>
</tr>
<tr>
<td>1001</td>
<td>0</td>
<td>2020-01-01 10:00:00</td>
<td>80</td>
</tr>
<tr>
<td>1010</td>
<td>0</td>
<td>2020-01-02 11:00:00</td>
<td>76</td>
</tr>
<tr>
<td>1003</td>
<td>0</td>
<td>2020-01-01 10:00:00</td>
<td>75</td>
</tr>
<tr>
<td>1004</td>
<td>0</td>
<td>2020-01-01 11:00:00</td>
<td>60</td>
</tr>
<tr>
<td>1006</td>
<td>0</td>
<td>2020-01-02 11:00:00</td>
<td>20</td>
</tr>
</tbody></table>
<p>每页 3 条，第三页也就是第 7~9 条，返回 1010、1003、1004 的行记录即可。</p>
<p><strong>思路</strong>：</p>
<ol>
<li><p>每页三条，即需要取出第三页的人的信息，要用到<code>limit</code></p>
</li>
<li><p>统计求职方向为算法工程师且注册当天就完成了算法类试卷的人的<strong>信息和每次记录的得分</strong>，先求满足条件的用户，后用 left join 做连接查找信息和每次记录的得分</p>
</li>
</ol>
<p><strong>答案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> t1.uid,</span><br><span class="line">       LEVEL,</span><br><span class="line">       register_time,</span><br><span class="line">       <span class="built_in">max</span>(score) <span class="keyword">AS</span> max_score</span><br><span class="line"><span class="keyword">FROM</span> exam_record t</span><br><span class="line"><span class="keyword">JOIN</span> examination_info <span class="keyword">USING</span> (exam_id)</span><br><span class="line"><span class="keyword">JOIN</span> user_info t1 <span class="keyword">ON</span> t.uid <span class="operator">=</span> t1.uid</span><br><span class="line"><span class="keyword">AND</span> <span class="type">date</span>(t.submit_time) <span class="operator">=</span> <span class="type">date</span>(t1.register_time)</span><br><span class="line"><span class="keyword">WHERE</span> job <span class="operator">=</span> <span class="string">&#x27;算法&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> tag <span class="operator">=</span> <span class="string">&#x27;算法&#x27;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> t1.uid,</span><br><span class="line">         LEVEL,</span><br><span class="line">         register_time</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> max_score <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">6</span>,<span class="number">3</span></span><br></pre></td></tr></table></figure>

<h2 id="文本转换函数"><a href="#文本转换函数" class="headerlink" title="文本转换函数"></a>文本转换函数</h2><h3 id="修复串列了的记录"><a href="#修复串列了的记录" class="headerlink" title="修复串列了的记录"></a>修复串列了的记录</h3><p><strong>描述</strong>：现有试卷信息表 <code>examination_info</code>（<code>exam_id</code> 试卷 ID, <code>tag</code> 试卷类别, <code>difficulty</code> 试卷难度, <code>duration</code> 考试时长, <code>release_time</code> 发布时间）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>exam_id</th>
<th>tag</th>
<th>difficulty</th>
<th>duration</th>
<th>release_time</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>9001</td>
<td>算法</td>
<td>hard</td>
<td>60</td>
<td>2021-01-01 10:00:00</td>
</tr>
<tr>
<td>2</td>
<td>9002</td>
<td>算法</td>
<td>hard</td>
<td>80</td>
<td>2021-01-01 10:00:00</td>
</tr>
<tr>
<td>3</td>
<td>9003</td>
<td>SQL</td>
<td>medium</td>
<td>70</td>
<td>2021-01-01 10:00:00</td>
</tr>
<tr>
<td>4</td>
<td>9004</td>
<td>算法,medium,80</td>
<td></td>
<td>0</td>
<td>2021-01-01 10:00:00</td>
</tr>
</tbody></table>
<p>录题同学有一次手误将部分记录的试题类别 tag、难度、时长同时录入到了 tag 字段，请帮忙找出这些录错了的记录，并拆分后按正确的列类型输出。</p>
<p>由示例数据结果输出如下：</p>
<table>
<thead>
<tr>
<th>exam_id</th>
<th>tag</th>
<th>difficulty</th>
<th>duration</th>
</tr>
</thead>
<tbody><tr>
<td>9004</td>
<td>算法</td>
<td>medium</td>
<td>80</td>
</tr>
</tbody></table>
<p><strong>思路</strong>：</p>
<p>先来学习下本题要用到的函数</p>
<p><code>SUBSTRING_INDEX</code> 函数用于提取字符串中指定分隔符的部分。它接受三个参数：原始字符串、分隔符和指定要返回的部分的数量。</p>
<p>以下是 <code>SUBSTRING_INDEX</code> 函数的语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUBSTRING_INDEX(str, delimiter, count)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>str</code>：要进行分割的原始字符串。</li>
<li><code>delimiter</code>：用作分割的字符串或字符。</li>
<li><code>count</code>：指定要返回的部分的数量。<ul>
<li>如果 <code>count</code> 大于 0，则返回从左边开始的前 <code>count</code> 个部分（以分隔符为界）。</li>
<li>如果 <code>count</code> 小于 0，则返回从右边开始的前 <code>count</code> 个部分（以分隔符为界），即从右侧向左计数。</li>
</ul>
</li>
</ul>
<p>下面是一些示例，演示了 <code>SUBSTRING_INDEX</code> 函数的使用：</p>
<ol>
<li><p>提取字符串中的第一个部分：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> SUBSTRING_INDEX(<span class="string">&#x27;apple,banana,cherry&#x27;</span>, <span class="string">&#x27;,&#x27;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">-- 输出结果：&#x27;apple&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>提取字符串中的最后一个部分：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> SUBSTRING_INDEX(<span class="string">&#x27;apple,banana,cherry&#x27;</span>, <span class="string">&#x27;,&#x27;</span>, <span class="number">-1</span>);</span><br><span class="line"><span class="comment">-- 输出结果：&#x27;cherry&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>提取字符串中的前两个部分：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> SUBSTRING_INDEX(<span class="string">&#x27;apple,banana,cherry&#x27;</span>, <span class="string">&#x27;,&#x27;</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">-- 输出结果：&#x27;apple,banana&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>提取字符串中的最后两个部分：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> SUBSTRING_INDEX(<span class="string">&#x27;apple,banana,cherry&#x27;</span>, <span class="string">&#x27;,&#x27;</span>, <span class="number">-2</span>);</span><br><span class="line"><span class="comment">-- 输出结果：&#x27;banana,cherry&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>答案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	exam_id,</span><br><span class="line">	substring_index( tag, <span class="string">&#x27;,&#x27;</span>, <span class="number">1</span> ) tag,</span><br><span class="line">	substring_index( substring_index( tag, <span class="string">&#x27;,&#x27;</span>, <span class="number">2</span> ), <span class="string">&#x27;,&#x27;</span>,<span class="operator">-</span> <span class="number">1</span> ) difficulty,</span><br><span class="line">	substring_index( tag, <span class="string">&#x27;,&#x27;</span>,<span class="operator">-</span> <span class="number">1</span> ) duration</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	examination_info</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	difficulty <span class="operator">=</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="对过长的昵称截取处理"><a href="#对过长的昵称截取处理" class="headerlink" title="对过长的昵称截取处理"></a>对过长的昵称截取处理</h3><p><strong>描述</strong>：现有用户信息表 <code>user_info</code>（<code>uid</code> 用户 ID，<code>nick_name</code> 昵称, <code>achievement</code> 成就值, <code>level</code> 等级, <code>job</code> 职业方向, <code>register_time</code> 注册时间）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>uid</th>
<th>nick_name</th>
<th>achievement</th>
<th>level</th>
<th>job</th>
<th>register_time</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1001</td>
<td>牛客 1</td>
<td>19</td>
<td>0</td>
<td>算法</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>2</td>
<td>1002</td>
<td>牛客 2 号</td>
<td>1200</td>
<td>3</td>
<td>算法</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>3</td>
<td>1003</td>
<td>牛客 3 号 ♂</td>
<td>22</td>
<td>0</td>
<td>算法</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>4</td>
<td>1004</td>
<td>牛客 4 号</td>
<td>25</td>
<td>0</td>
<td>算法</td>
<td>2020-01-01 11:00:00</td>
</tr>
<tr>
<td>5</td>
<td>1005</td>
<td>牛客 5678901234 号</td>
<td>4000</td>
<td>7</td>
<td>算法</td>
<td>2020-01-11 10:00:00</td>
</tr>
<tr>
<td>6</td>
<td>1006</td>
<td>牛客 67890123456789 号</td>
<td>25</td>
<td>0</td>
<td>算法</td>
<td>2020-01-02 11:00:00</td>
</tr>
</tbody></table>
<p>有的用户的昵称特别长，在一些展示场景会导致样式混乱，因此需要将特别长的昵称转换一下再输出，请输出字符数大于 10 的用户信息，对于字符数大于 13 的用户输出前 10 个字符然后加上三个点号：『…』。</p>
<p>由示例数据结果输出如下：</p>
<table>
<thead>
<tr>
<th>uid</th>
<th>nick_name</th>
</tr>
</thead>
<tbody><tr>
<td>1005</td>
<td>牛客 5678901234 号</td>
</tr>
<tr>
<td>1006</td>
<td>牛客 67890123…</td>
</tr>
</tbody></table>
<p>解释：字符数大于 10 的用户有 1005 和 1006，长度分别为 13、17；因此需要对 1006 的昵称截断输出。</p>
<p><strong>思路</strong>：</p>
<p>这题涉及到字符的计算，要计算字符串的字符数（即字符串的长度），可以使用 <code>LENGTH</code> 函数或 <code>CHAR_LENGTH</code> 函数。这两个函数的区别在于对待多字节字符的方式。</p>
<ol>
<li><code>LENGTH</code> 函数：它返回给定字符串的字节数。对于包含多字节字符的字符串，每个字符都会被当作一个字节来计算。</li>
</ol>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> LENGTH(<span class="string">&#x27;你好&#x27;</span>); <span class="comment">-- 输出结果：6，因为 &#x27;你好&#x27; 中的每个汉字每个占3个字节</span></span><br></pre></td></tr></table></figure>

<ol>
<li><code>CHAR_LENGTH</code> 函数：它返回给定字符串的字符数。对于包含多字节字符的字符串，每个字符会被当作一个字符来计算。</li>
</ol>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CHAR_LENGTH</span>(<span class="string">&#x27;你好&#x27;</span>); <span class="comment">-- 输出结果：2，因为 &#x27;你好&#x27; 中有两个字符，即两个汉字</span></span><br></pre></td></tr></table></figure>

<p><strong>答案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	uid,</span><br><span class="line"><span class="keyword">CASE</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">WHEN</span> <span class="keyword">CHAR_LENGTH</span>( nick_name ) <span class="operator">&gt;</span> <span class="number">13</span> <span class="keyword">THEN</span></span><br><span class="line">		CONCAT( SUBSTR( nick_name, <span class="number">1</span>, <span class="number">10</span> ), <span class="string">&#x27;...&#x27;</span> ) <span class="keyword">ELSE</span> nick_name</span><br><span class="line">	<span class="keyword">END</span> <span class="keyword">AS</span> nick_name</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	user_info</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	<span class="keyword">CHAR_LENGTH</span>( nick_name ) <span class="operator">&gt;</span> <span class="number">10</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">	uid;</span><br></pre></td></tr></table></figure>

<h3 id="大小写混乱时的筛选统计（较难）"><a href="#大小写混乱时的筛选统计（较难）" class="headerlink" title="大小写混乱时的筛选统计（较难）"></a>大小写混乱时的筛选统计（较难）</h3><p><strong>描述</strong>：</p>
<p>现有试卷信息表 <code>examination_info</code>（<code>exam_id</code> 试卷 ID, <code>tag</code> 试卷类别, <code>difficulty</code> 试卷难度, <code>duration</code> 考试时长, <code>release_time</code> 发布时间）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>exam_id</th>
<th>tag</th>
<th>difficulty</th>
<th>duration</th>
<th>release_time</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>9001</td>
<td>算法</td>
<td>hard</td>
<td>60</td>
<td>2021-01-01 10:00:00</td>
</tr>
<tr>
<td>2</td>
<td>9002</td>
<td>C++</td>
<td>hard</td>
<td>80</td>
<td>2021-01-01 10:00:00</td>
</tr>
<tr>
<td>3</td>
<td>9003</td>
<td>C++</td>
<td>hard</td>
<td>80</td>
<td>2021-01-01 10:00:00</td>
</tr>
<tr>
<td>4</td>
<td>9004</td>
<td>sql</td>
<td>medium</td>
<td>70</td>
<td>2021-01-01 10:00:00</td>
</tr>
<tr>
<td>5</td>
<td>9005</td>
<td>C++</td>
<td>hard</td>
<td>80</td>
<td>2021-01-01 10:00:00</td>
</tr>
<tr>
<td>6</td>
<td>9006</td>
<td>C++</td>
<td>hard</td>
<td>80</td>
<td>2021-01-01 10:00:00</td>
</tr>
<tr>
<td>7</td>
<td>9007</td>
<td>C++</td>
<td>hard</td>
<td>80</td>
<td>2021-01-01 10:00:00</td>
</tr>
<tr>
<td>8</td>
<td>9008</td>
<td>SQL</td>
<td>medium</td>
<td>70</td>
<td>2021-01-01 10:00:00</td>
</tr>
<tr>
<td>9</td>
<td>9009</td>
<td>SQL</td>
<td>medium</td>
<td>70</td>
<td>2021-01-01 10:00:00</td>
</tr>
<tr>
<td>10</td>
<td>9010</td>
<td>SQL</td>
<td>medium</td>
<td>70</td>
<td>2021-01-01 10:00:00</td>
</tr>
</tbody></table>
<p>试卷作答信息表 <code>exam_record</code>（<code>uid</code> 用户 ID, <code>exam_id</code> 试卷 ID, <code>start_time</code> 开始作答时间, <code>submit_time</code> 交卷时间, <code>score</code> 得分）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>uid</th>
<th>exam_id</th>
<th>start_time</th>
<th>submit_time</th>
<th>score</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1001</td>
<td>9001</td>
<td>2020-01-01 09:01:01</td>
<td>2020-01-01 09:21:59</td>
<td>80</td>
</tr>
<tr>
<td>2</td>
<td>1002</td>
<td>9003</td>
<td>2020-01-20 10:01:01</td>
<td>2020-01-20 10:10:01</td>
<td>81</td>
</tr>
<tr>
<td>3</td>
<td>1002</td>
<td>9002</td>
<td>2020-02-01 12:11:01</td>
<td>2020-02-01 12:31:01</td>
<td>83</td>
</tr>
<tr>
<td>4</td>
<td>1003</td>
<td>9002</td>
<td>2020-03-01 19:01:01</td>
<td>2020-03-01 19:30:01</td>
<td>75</td>
</tr>
<tr>
<td>5</td>
<td>1004</td>
<td>9002</td>
<td>2020-03-01 12:01:01</td>
<td>2020-03-01 12:11:01</td>
<td>60</td>
</tr>
<tr>
<td>6</td>
<td>1005</td>
<td>9002</td>
<td>2020-03-01 12:01:01</td>
<td>2020-03-01 12:41:01</td>
<td>90</td>
</tr>
<tr>
<td>7</td>
<td>1006</td>
<td>9001</td>
<td>2020-05-02 19:01:01</td>
<td>2020-05-02 19:32:00</td>
<td>20</td>
</tr>
<tr>
<td>8</td>
<td>1007</td>
<td>9003</td>
<td>2020-01-02 19:01:01</td>
<td>2020-01-02 19:40:01</td>
<td>89</td>
</tr>
<tr>
<td>9</td>
<td>1008</td>
<td>9004</td>
<td>2020-02-02 12:01:01</td>
<td>2020-02-02 12:20:01</td>
<td>99</td>
</tr>
<tr>
<td>10</td>
<td>1008</td>
<td>9001</td>
<td>2020-02-02 12:01:01</td>
<td>2020-02-02 12:31:01</td>
<td>98</td>
</tr>
<tr>
<td>11</td>
<td>1009</td>
<td>9002</td>
<td>2020-02-02 12:01:01</td>
<td>2020-01-02 12:43:01</td>
<td>81</td>
</tr>
<tr>
<td>12</td>
<td>1010</td>
<td>9001</td>
<td>2020-01-02 12:11:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>13</td>
<td>1010</td>
<td>9001</td>
<td>2020-02-02 12:01:01</td>
<td>2020-01-02 10:31:01</td>
<td>89</td>
</tr>
</tbody></table>
<p>试卷的类别 tag 可能出现大小写混乱的情况，请先筛选出试卷作答数小于 3 的类别 tag，统计将其转换为大写后对应的原本试卷作答数。</p>
<p>如果转换后 tag 并没有发生变化，不输出该条结果。</p>
<p>由示例数据结果输出如下：</p>
<table>
<thead>
<tr>
<th>tag</th>
<th>answer_cnt</th>
</tr>
</thead>
<tbody><tr>
<td>C++</td>
<td>6</td>
</tr>
</tbody></table>
<p>解释：被作答过的试卷有 9001、9002、9003、9004，他们的 tag 和被作答次数如下：</p>
<table>
<thead>
<tr>
<th>exam_id</th>
<th>tag</th>
<th>answer_cnt</th>
</tr>
</thead>
<tbody><tr>
<td>9001</td>
<td>算法</td>
<td>4</td>
</tr>
<tr>
<td>9002</td>
<td>C++</td>
<td>6</td>
</tr>
<tr>
<td>9003</td>
<td>c++</td>
<td>2</td>
</tr>
<tr>
<td>9004</td>
<td>sql</td>
<td>2</td>
</tr>
</tbody></table>
<p>作答次数小于 3 的 tag 有 c++和 sql，而转为大写后只有 C++本来就有作答数，于是输出 c++转化大写后的作答次数为 6。</p>
<p><strong>思路</strong>：</p>
<p>首先，这题有点混乱，9004 根据示例数据查出来只有 1 次，这里显示有 2 次。</p>
<p>先看一下大小写转换函数：</p>
<p>1.<code>UPPER(s)</code>或<code>UCASE(s)</code>函数可以将字符串 s 中的字母字符全部转换成大写字母；</p>
<p>2.<code>LOWER(s)</code>或者<code>LCASE(s)</code>函数可以将字符串 s 中的字母字符全部转换成小写字母。</p>
<p>难点在于相同表做连接要查询不同的值</p>
<p><strong>答案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> a <span class="keyword">AS</span></span><br><span class="line">  (<span class="keyword">SELECT</span> tag,</span><br><span class="line">          <span class="built_in">COUNT</span>(start_time) <span class="keyword">AS</span> answer_cnt</span><br><span class="line">   <span class="keyword">FROM</span> exam_record er</span><br><span class="line">   <span class="keyword">JOIN</span> examination_info ei <span class="keyword">ON</span> er.exam_id <span class="operator">=</span> ei.exam_id</span><br><span class="line">   <span class="keyword">GROUP</span> <span class="keyword">BY</span> tag)</span><br><span class="line"><span class="keyword">SELECT</span> a.tag,</span><br><span class="line">       b.answer_cnt</span><br><span class="line"><span class="keyword">FROM</span> a</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> a <span class="keyword">AS</span> b <span class="keyword">ON</span> <span class="built_in">UPPER</span>(a.tag)<span class="operator">=</span> b.tag #a小写 b大写</span><br><span class="line"><span class="keyword">AND</span> a.tag <span class="operator">!=</span> b.tag</span><br><span class="line"><span class="keyword">WHERE</span> a.answer_cnt <span class="operator">&lt;</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<!-- @include: @article-footer.snippet.md -->

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2024/08/26/J2EE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/08/26/J2EE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" itemprop="url">J2EE要点</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-08-26T20:56:07+08:00">
                2024-08-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/WEB/" itemprop="url" rel="index">
                    <span itemprop="name">WEB</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2024/08/26/J2EE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="leancloud_visitors" data-flag-title="J2EE要点">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  5.4k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  19 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Servlet-总结"><a href="#Servlet-总结" class="headerlink" title="Servlet 总结"></a>Servlet 总结</h1><p>在 Java Web 程序中，<strong>Servlet</strong>主要负责接收用户请求 <code>HttpServletRequest</code>,在<code>doGet()</code>,<code>doPost()</code>中做相应的处理，并将回应<code>HttpServletResponse</code>反馈给用户。<strong>Servlet</strong> 可以设置初始化参数，供 Servlet 内部使用。一个 Servlet 类只会有一个实例，在它初始化时调用<code>init()</code>方法，销毁时调用<code>destroy()</code>方法<strong>。</strong>Servlet 需要在 web.xml 中配置（MyEclipse 中创建 Servlet 会自动配置），<strong>一个 Servlet 可以设置多个 URL 访问</strong>。<strong>Servlet 不是线程安全</strong>，因此要谨慎使用类变量。</p>
<h2 id="阐述-Servlet-和-CGI-的区别"><a href="#阐述-Servlet-和-CGI-的区别" class="headerlink" title="阐述 Servlet 和 CGI 的区别?"></a>阐述 Servlet 和 CGI 的区别?</h2><h3 id="CGI-的不足之处"><a href="#CGI-的不足之处" class="headerlink" title="CGI 的不足之处"></a>CGI 的不足之处</h3><p>1，需要为每个请求启动一个操作 CGI 程序的系统进程。如果请求频繁，这将会带来很大的开销。</p>
<p>2，需要为每个请求加载和运行一个 CGI 程序，这将带来很大的开销</p>
<p>3，需要重复编写处理网络协议的代码以及编码，这些工作都是非常耗时的。</p>
<h3 id="Servlet-的优点"><a href="#Servlet-的优点" class="headerlink" title="Servlet 的优点"></a>Servlet 的优点</h3><p>1，只需要启动一个操作系统进程以及加载一个 JVM，大大降低了系统的开销</p>
<p>2，如果多个请求需要做同样处理的时候，这时候只需要加载一个类，这也大大降低了开销</p>
<p>3，所有动态加载的类可以实现对网络协议以及请求解码的共享，大大降低了工作量。</p>
<p>4，Servlet 能直接和 Web 服务器交互，而普通的 CGI 程序不能。Servlet 还能在各个程序之间共享数据，使数据库连接池之类的功能很容易实现。</p>
<p>补充：Sun Microsystems 公司在 1996 年发布 Servlet 技术就是为了和 CGI 进行竞争，Servlet 是一个特殊的 Java 程序，一个基于 Java 的 Web 应用通常包含一个或多个 Servlet 类。Servlet 不能够自行创建并执行，它是在 Servlet 容器中运行的，容器将用户的请求传递给 Servlet 程序，并将 Servlet 的响应回传给用户。通常一个 Servlet 会关联一个或多个 JSP 页面。以前 CGI 经常因为性能开销上的问题被诟病，然而 Fast CGI 早就已经解决了 CGI 效率上的问题，所以面试的时候大可不必信口开河的诟病 CGI，事实上有很多你熟悉的网站都使用了 CGI 技术。</p>
<p>参考：《javaweb 整合开发王者归来》P7</p>
<h2 id="Servlet-接口中有哪些方法及-Servlet-生命周期探秘"><a href="#Servlet-接口中有哪些方法及-Servlet-生命周期探秘" class="headerlink" title="Servlet 接口中有哪些方法及 Servlet 生命周期探秘"></a>Servlet 接口中有哪些方法及 Servlet 生命周期探秘</h2><p>Servlet 接口定义了 5 个方法，其中<strong>前三个方法与 Servlet 生命周期相关</strong>：</p>
<ul>
<li><code>void init(ServletConfig config) throws ServletException</code></li>
<li><code>void service(ServletRequest req, ServletResponse resp) throws ServletException, java.io.IOException</code></li>
<li><code>void destroy()</code></li>
<li><code>java.lang.String getServletInfo()</code></li>
<li><code>ServletConfig getServletConfig()</code></li>
</ul>
<p><strong>生命周期：</strong> <strong>Web 容器加载 Servlet 并将其实例化后，Servlet 生命周期开始</strong>，容器运行其<strong>init()方法</strong>进行 Servlet 的初始化；请求到达时调用 Servlet 的<strong>service()方法</strong>，service()方法会根据需要调用与请求对应的<strong>doGet 或 doPost</strong>等方法；当服务器关闭或项目被卸载时服务器会将 Servlet 实例销毁，此时会调用 Servlet 的<strong>destroy()方法</strong>。<strong>init 方法和 destroy 方法只会执行一次，service 方法客户端每次请求 Servlet 都会执行</strong>。Servlet 中有时会用到一些需要初始化与销毁的资源，因此可以把初始化资源的代码放入 init 方法中，销毁资源的代码放入 destroy 方法中，这样就不需要每次处理客户端的请求都要初始化与销毁资源。</p>
<p>参考：《javaweb 整合开发王者归来》P81</p>
<h2 id="GET-和-POST-的区别"><a href="#GET-和-POST-的区别" class="headerlink" title="GET 和 POST 的区别"></a>GET 和 POST 的区别</h2><p>这个问题在知乎上被讨论的挺火热的，地址：<a href="https://www.zhihu.com/question/28586791">https://www.zhihu.com/question/28586791</a> 。</p>
<p><img src="https://static001.geekbang.org/infoq/04/0454a5fff1437c32754f1dfcc3881148.png"></p>
<p>GET 和 POST 是 HTTP 协议中两种常用的请求方法，它们在不同的场景和目的下有不同的特点和用法。一般来说，可以从以下几个方面来区分它们：</p>
<ul>
<li>语义上的区别：GET 通常用于获取或查询资源，而 POST 通常用于创建或修改资源。GET 请求应该是幂等的，即多次重复执行不会改变资源的状态，而 POST 请求则可能有副作用，即每次执行可能会产生不同的结果或影响资源的状态。</li>
<li>格式上的区别：GET 请求的参数通常放在 URL 中，形成查询字符串（querystring），而 POST 请求的参数通常放在请求体（body）中，可以有多种编码格式，如 application&#x2F;x-www-form-urlencoded、multipart&#x2F;form-data、application&#x2F;json 等。GET 请求的 URL 长度受到浏览器和服务器的限制，而 POST 请求的 body 大小则没有明确的限制。</li>
<li>缓存上的区别：由于 GET 请求是幂等的，它可以被浏览器或其他中间节点（如代理、网关）缓存起来，以提高性能和效率。而 POST 请求则不适合被缓存，因为它可能有副作用，每次执行可能需要实时的响应。</li>
<li>安全性上的区别：GET 请求和 POST 请求都不是绝对安全的，因为 HTTP 协议本身是明文传输的，无论是 URL、header 还是 body 都可能被窃取或篡改。为了保证安全性，必须使用 HTTPS 协议来加密传输数据。不过，在一些场景下，GET 请求相比 POST 请求更容易泄露敏感数据，因为 GET 请求的参数会出现在 URL 中，而 URL 可能会被记录在浏览器历史、服务器日志、代理日志等地方。因此，一般情况下，私密数据传输应该使用 POST + body。</li>
</ul>
<p>重点搞清了，两者在语义上的区别即可。不过，也有一些项目所有的请求都用 POST，这个并不是固定的，项目组达成共识即可。</p>
<h2 id="什么情况下调用-doGet-和-doPost"><a href="#什么情况下调用-doGet-和-doPost" class="headerlink" title="什么情况下调用 doGet()和 doPost()"></a>什么情况下调用 doGet()和 doPost()</h2><p>Form 标签里的 method 的属性为 get 时调用 doGet()，为 post 时调用 doPost()。</p>
<h2 id="转发-Forward-和重定向-Redirect-的区别"><a href="#转发-Forward-和重定向-Redirect-的区别" class="headerlink" title="转发(Forward)和重定向(Redirect)的区别"></a>转发(Forward)和重定向(Redirect)的区别</h2><p><strong>转发是服务器行为，重定向是客户端行为。</strong></p>
<p><strong>转发（Forward）</strong><br>通过 RequestDispatcher 对象的 forward（HttpServletRequest request,HttpServletResponse response）方法实现的。RequestDispatcher 可以通过 HttpServletRequest 的 getRequestDispatcher()方法获得。例如下面的代码就是跳转到 login_success.jsp 页面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.getRequestDispatcher(<span class="string">&quot;login_success.jsp&quot;</span>).forward(request, response);</span><br></pre></td></tr></table></figure>

<p><strong>重定向（Redirect）</strong> 是利用服务器返回的状态码来实现的。客户端浏览器请求服务器的时候，服务器会返回一个状态码。服务器通过 <code>HttpServletResponse</code> 的 <code>setStatus(int status)</code> 方法设置状态码。如果服务器返回 301 或者 302，则浏览器会到新的网址重新请求该资源。</p>
<ol>
<li><p><strong>从地址栏显示来说</strong></p>
<p>forward 是服务器请求资源,服务器直接访问目标地址的 URL,把那个 URL 的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址.<br>redirect 是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的 URL.</p>
</li>
<li><p><strong>从数据共享来说</strong></p>
<p>forward:转发页面和转发到的页面可以共享 request 里面的数据.<br>redirect:不能共享数据.</p>
</li>
<li><p><strong>从运用地方来说</strong></p>
<p>forward:一般用于用户登陆的时候,根据角色转发到相应的模块.<br>redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等</p>
</li>
<li><p>从效率来说</p>
<p>forward:高.<br>redirect:低.</p>
</li>
</ol>
<h2 id="自动刷新-Refresh"><a href="#自动刷新-Refresh" class="headerlink" title="自动刷新(Refresh)"></a>自动刷新(Refresh)</h2><p>自动刷新不仅可以实现一段时间之后自动跳转到另一个页面，还可以实现一段时间之后自动刷新本页面。Servlet 中通过 HttpServletResponse 对象设置 Header 属性实现自动刷新例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response.setHeader(<span class="string">&quot;Refresh&quot;</span>,<span class="string">&quot;5;URL=http://localhost:8080/servlet/example.htm&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>其中 5 为时间，单位为秒。URL 指定就是要跳转的页面（如果设置自己的路径，就会实现每过 5 秒自动刷新本页面一次）</p>
<h2 id="Servlet-与线程安全"><a href="#Servlet-与线程安全" class="headerlink" title="Servlet 与线程安全"></a>Servlet 与线程安全</h2><p><strong>Servlet 不是线程安全的，多线程并发的读写会导致数据不同步的问题。</strong> 解决的办法是尽量不要定义 name 属性，而是要把 name 变量分别定义在 doGet()和 doPost()方法内。虽然使用 synchronized(name){}语句块可以解决问题，但是会造成线程的等待，不是很科学的办法。<br>注意：多线程的并发的读写 Servlet 类属性会导致数据不同步。但是如果只是并发地读取属性而不写入，则不存在数据不同步的问题。因此 Servlet 里的只读属性最好定义为 final 类型的。</p>
<p>参考：《javaweb 整合开发王者归来》P92</p>
<h2 id="JSP-和-Servlet-是什么关系"><a href="#JSP-和-Servlet-是什么关系" class="headerlink" title="JSP 和 Servlet 是什么关系"></a>JSP 和 Servlet 是什么关系</h2><p>其实这个问题在上面已经阐述过了，Servlet 是一个特殊的 Java 程序，它运行于服务器的 JVM 中，能够依靠服务器的支持向浏览器提供显示内容。JSP 本质上是 Servlet 的一种简易形式，JSP 会被服务器处理成一个类似于 Servlet 的 Java 程序，可以简化页面内容的生成。Servlet 和 JSP 最主要的不同点在于，Servlet 的应用逻辑是在 Java 文件中，并且完全从表示层中的 HTML 分离开来。而 JSP 的情况是 Java 和 HTML 可以组合成一个扩展名为.jsp 的文件。有人说，Servlet 就是在 Java 中写 HTML，而 JSP 就是在 HTML 中写 Java 代码，当然这个说法是很片面且不够准确的。JSP 侧重于视图，Servlet 更侧重于控制逻辑，在 MVC 架构模式中，JSP 适合充当视图（view）而 Servlet 适合充当控制器（controller）。</p>
<h2 id="JSP-工作原理"><a href="#JSP-工作原理" class="headerlink" title="JSP 工作原理"></a>JSP 工作原理</h2><p>JSP 是一种 Servlet，但是与 HttpServlet 的工作方式不太一样。HttpServlet 是先由源代码编译为 class 文件后部署到服务器下，为先编译后部署。而 JSP 则是先部署后编译。JSP 会在客户端第一次请求 JSP 文件时被编译为 HttpJspPage 类（接口 Servlet 的一个子类）。该类会被服务器临时存放在服务器工作目录里面。下面通过实例给大家介绍。<br>工程 JspLoginDemo 下有一个名为 login.jsp 的 Jsp 文件，把工程第一次部署到服务器上后访问这个 Jsp 文件，我们发现这个目录下多了下图这两个东东。<br>.class 文件便是 JSP 对应的 Servlet。编译完毕后再运行 class 文件来响应客户端请求。以后客户端访问 login.jsp 的时候，Tomcat 将不再重新编译 JSP 文件，而是直接调用 class 文件来响应客户端请求。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/1.jpeg" alt="JSP工作原理"></p>
<p>由于 JSP 只会在客户端第一次请求的时候被编译 ，因此第一次请求 JSP 时会感觉比较慢，之后就会感觉快很多。如果把服务器保存的 class 文件删除，服务器也会重新编译 JSP。</p>
<p>开发 Web 程序时经常需要修改 JSP。Tomcat 能够自动检测到 JSP 程序的改动。如果检测到 JSP 源代码发生了改动。Tomcat 会在下次客户端请求 JSP 时重新编译 JSP，而不需要重启 Tomcat。这种自动检测功能是默认开启的，检测改动会消耗少量的时间，在部署 Web 应用的时候可以在 web.xml 中将它关掉。</p>
<p>参考：《javaweb 整合开发王者归来》P97</p>
<h2 id="JSP-有哪些内置对象、作用分别是什么"><a href="#JSP-有哪些内置对象、作用分别是什么" class="headerlink" title="JSP 有哪些内置对象、作用分别是什么"></a>JSP 有哪些内置对象、作用分别是什么</h2><p><a href="http://blog.csdn.net/qq_34337272/article/details/64310849">JSP 内置对象 - CSDN 博客</a></p>
<p>JSP 有 9 个内置对象：</p>
<ul>
<li>request：封装客户端的请求，其中包含来自 GET 或 POST 请求的参数；</li>
<li>response：封装服务器对客户端的响应；</li>
<li>pageContext：通过该对象可以获取其他对象；</li>
<li>session：封装用户会话的对象；</li>
<li>application：封装服务器运行环境的对象；</li>
<li>out：输出服务器响应的输出流对象；</li>
<li>config：Web 应用的配置对象；</li>
<li>page：JSP 页面本身（相当于 Java 程序中的 this）；</li>
<li>exception：封装页面抛出异常的对象。</li>
</ul>
<h2 id="Request-对象的主要方法有哪些"><a href="#Request-对象的主要方法有哪些" class="headerlink" title="Request 对象的主要方法有哪些"></a>Request 对象的主要方法有哪些</h2><ul>
<li><code>setAttribute(String name,Object)</code>：设置名字为 name 的 request 的参数值</li>
<li><code>getAttribute(String name)</code>：返回由 name 指定的属性值</li>
<li><code>getAttributeNames()</code>：返回 request 对象所有属性的名字集合，结果是一个枚举的实例</li>
<li><code>getCookies()</code>：返回客户端的所有 Cookie 对象，结果是一个 Cookie 数组</li>
<li><code>getCharacterEncoding()</code>：返回请求中的字符编码方式 &#x3D; getContentLength()&#96;：返回请求的 Body 的长度</li>
<li><code>getHeader(String name)</code>：获得 HTTP 协议定义的文件头信息</li>
<li><code>getHeaders(String name)</code>：返回指定名字的 request Header 的所有值，结果是一个枚举的实例</li>
<li><code>getHeaderNames()</code>：返回所以 request Header 的名字，结果是一个枚举的实例</li>
<li><code>getInputStream()</code>：返回请求的输入流，用于获得请求中的数据</li>
<li><code>getMethod()</code>：获得客户端向服务器端传送数据的方法</li>
<li><code>getParameter(String name)</code>：获得客户端传送给服务器端的有 name 指定的参数值</li>
<li><code>getParameterNames()</code>：获得客户端传送给服务器端的所有参数的名字，结果是一个枚举的实例</li>
<li><code>getParameterValues(String name)</code>：获得有 name 指定的参数的所有值</li>
<li><code>getProtocol()</code>：获取客户端向服务器端传送数据所依据的协议名称</li>
<li><code>getQueryString()</code>：获得查询字符串</li>
<li><code>getRequestURI()</code>：获取发出请求字符串的客户端地址</li>
<li><code>getRemoteAddr()</code>：获取客户端的 IP 地址</li>
<li><code>getRemoteHost()</code>：获取客户端的名字</li>
<li><code>getSession([Boolean create])</code>：返回和请求相关 Session</li>
<li><code>getServerName()</code>：获取服务器的名字</li>
<li><code>getServletPath()</code>：获取客户端所请求的脚本文件的路径</li>
<li><code>getServerPort()</code>：获取服务器的端口号</li>
<li><code>removeAttribute(String name)</code>：删除请求中的一个属性</li>
</ul>
<h2 id="request-getAttribute-和-request-getParameter-有何区别"><a href="#request-getAttribute-和-request-getParameter-有何区别" class="headerlink" title="request.getAttribute()和 request.getParameter()有何区别"></a>request.getAttribute()和 request.getParameter()有何区别</h2><p><strong>从获取方向来看：</strong></p>
<p><code>getParameter()</code>是获取 POST&#x2F;GET 传递的参数值；</p>
<p><code>getAttribute()</code>是获取对象容器中的数据值；</p>
<p><strong>从用途来看：</strong></p>
<p><code>getParameter()</code>用于客户端重定向时，即点击了链接或提交按扭时传值用，即用于在用表单或 url 重定向传值时接收数据用。</p>
<p><code>getAttribute()</code> 用于服务器端重定向时，即在 sevlet 中使用了 forward 函数,或 struts 中使用了<br>mapping.findForward。 getAttribute 只能收到程序用 setAttribute 传过来的值。</p>
<p>另外，可以用 <code>setAttribute()</code>,<code>getAttribute()</code> 发送接收对象.而 <code>getParameter()</code> 显然只能传字符串。<br><code>setAttribute()</code> 是应用服务器把这个对象放在该页面所对应的一块内存中去，当你的页面服务器重定向到另一个页面时，应用服务器会把这块内存拷贝另一个页面所对应的内存中。这样<code>getAttribute()</code>就能取得你所设下的值，当然这种方法可以传对象。session 也一样，只是对象在内存中的生命周期不一样而已。<code>getParameter()</code>只是应用服务器在分析你送上来的 request 页面的文本时，取得你设在表单或 url 重定向时的值。</p>
<p><strong>总结：</strong></p>
<p><code>getParameter()</code>返回的是 String,用于读取提交的表单中的值;（获取之后会根据实际需要转换为自己需要的相应类型，比如整型，日期类型啊等等）</p>
<p><code>getAttribute()</code>返回的是 Object，需进行转换,可用<code>setAttribute()</code>设置成任意对象，使用很灵活，可随时用</p>
<h2 id="include-指令-include-的行为的区别"><a href="#include-指令-include-的行为的区别" class="headerlink" title="include 指令 include 的行为的区别"></a>include 指令 include 的行为的区别</h2><p><strong>include 指令：</strong> JSP 可以通过 include 指令来包含其他文件。被包含的文件可以是 JSP 文件、HTML 文件或文本文件。包含的文件就好像是该 JSP 文件的一部分，会被同时编译执行。 语法格式如下：<br>&lt;%@ include file&#x3D;”文件相对 url 地址” %&gt;</p>
<p>i<strong>nclude 动作：</strong> <code>&lt;jsp:include&gt;</code>动作元素用来包含静态和动态的文件。该动作把指定文件插入正在生成的页面。语法格式如下：<br>&lt;jsp:include page&#x3D;”相对 URL 地址” flush&#x3D;”true” &#x2F;&gt;</p>
<h2 id="JSP-九大内置对象，七大动作，三大指令"><a href="#JSP-九大内置对象，七大动作，三大指令" class="headerlink" title="JSP 九大内置对象，七大动作，三大指令"></a>JSP 九大内置对象，七大动作，三大指令</h2><p><a href="http://blog.csdn.net/qq_34337272/article/details/64310849">JSP 九大内置对象，七大动作，三大指令总结</a></p>
<h2 id="讲解-JSP-中的四种作用域"><a href="#讲解-JSP-中的四种作用域" class="headerlink" title="讲解 JSP 中的四种作用域"></a>讲解 JSP 中的四种作用域</h2><p>JSP 中的四种作用域包括 page、request、session 和 application，具体来说：</p>
<ul>
<li><strong>page</strong>代表与一个页面相关的对象和属性。</li>
<li><strong>request</strong>代表与 Web 客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个 Web 组件；需要在页面显示的临时数据可以置于此作用域。</li>
<li><strong>session</strong>代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的 session 中。</li>
<li><strong>application</strong>代表与整个 Web 应用程序相关的对象和属性，它实质上是跨越整个 Web 应用程序，包括多个页面、请求和会话的一个全局作用域。</li>
</ul>
<h2 id="如何实现-JSP-或-Servlet-的单线程模式"><a href="#如何实现-JSP-或-Servlet-的单线程模式" class="headerlink" title="如何实现 JSP 或 Servlet 的单线程模式"></a>如何实现 JSP 或 Servlet 的单线程模式</h2><p>对于 JSP 页面，可以通过 page 指令进行设置。<br><code>&lt;%@page isThreadSafe=&quot;false&quot;%&gt;</code></p>
<p>对于 Servlet，可以让自定义的 Servlet 实现 SingleThreadModel 标识接口。</p>
<p>说明：如果将 JSP 或 Servlet 设置成单线程工作模式，会导致每个请求创建一个 Servlet 实例，这种实践将导致严重的性能问题（服务器的内存压力很大，还会导致频繁的垃圾回收），所以通常情况下并不会这么做。</p>
<h2 id="实现会话跟踪的技术有哪些"><a href="#实现会话跟踪的技术有哪些" class="headerlink" title="实现会话跟踪的技术有哪些"></a>实现会话跟踪的技术有哪些</h2><ol>
<li><p><strong>使用 Cookie</strong></p>
<p>向客户端发送 Cookie</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Cookie</span> <span class="variable">c</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;value&quot;</span>); <span class="comment">//创建Cookie</span></span><br><span class="line">c.setMaxAge(<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>); <span class="comment">//设置最大时效，此处设置的最大时效为一天</span></span><br><span class="line">response.addCookie(c); <span class="comment">//把Cookie放入到HTTP响应中</span></span><br></pre></td></tr></table></figure>

<p>从客户端读取 Cookie</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span><span class="string">&quot;name&quot;</span>;</span><br><span class="line">Cookie[]cookies =request.getCookies();</span><br><span class="line"><span class="keyword">if</span>(cookies !=<span class="literal">null</span>)&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">0</span>;i&lt;cookies.length;i++)&#123;</span><br><span class="line">    <span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span>cookies[i];</span><br><span class="line">    <span class="keyword">if</span>(name.equals(cookis.getName()))</span><br><span class="line">    <span class="comment">//something is here.</span></span><br><span class="line">    <span class="comment">//you can get the value</span></span><br><span class="line">    cookie.getValue();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>优点:</strong> 数据可以持久保存，不需要服务器资源，简单，基于文本的 Key-Value</p>
<p><strong>缺点:</strong> 大小受到限制，用户可以禁用 Cookie 功能，由于保存在本地，有一定的安全风险。</p>
</li>
<li><p>URL 重写</p>
<p>在 URL 中添加用户会话的信息作为请求的参数，或者将唯一的会话 ID 添加到 URL 结尾以标识一个会话。</p>
<p><strong>优点：</strong> 在 Cookie 被禁用的时候依然可以使用</p>
<p><strong>缺点：</strong> 必须对网站的 URL 进行编码，所有页面必须动态生成，不能用预先记录下来的 URL 进行访问。</p>
</li>
<li><p>隐藏的表单域</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;session&quot;</span> <span class="attr">value</span>=<span class="string">&quot;...&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong> Cookie 被禁时可以使用</p>
<p><strong>缺点：</strong> 所有页面必须是表单提交之后的结果。</p>
</li>
<li><p>HttpSession</p>
<p>在所有会话跟踪技术中，HttpSession 对象是最强大也是功能最多的。当一个用户第一次访问某个网站时会自动创建 HttpSession，每个用户可以访问他自己的 HttpSession。可以通过 HttpServletRequest 对象的 getSession 方 法获得 HttpSession，通过 HttpSession 的 setAttribute 方法可以将一个值放在 HttpSession 中，通过调用 HttpSession 对象的 getAttribute 方法，同时传入属性名就可以获取保存在 HttpSession 中的对象。与上面三种方式不同的 是，HttpSession 放在服务器的内存中，因此不要将过大的对象放在里面，即使目前的 Servlet 容器可以在内存将满时将 HttpSession 中的对象移到其他存储设备中，但是这样势必影响性能。添加到 HttpSession 中的值可以是任意 Java 对象，这个对象最好实现了 Serializable 接口，这样 Servlet 容器在必要的时候可以将其序列化到文件中，否则在序列化时就会出现异常。</p>
</li>
</ol>
<h2 id="Cookie-和-Session-的区别"><a href="#Cookie-和-Session-的区别" class="headerlink" title="Cookie 和 Session 的区别"></a>Cookie 和 Session 的区别</h2><p>Cookie 和 Session 都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。</p>
<p><strong>Cookie 一般用来保存用户信息</strong> 比如 ① 我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；② 一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；③ 登录一次网站后访问网站其他页面不需要重新登录。<strong>Session 的主要作用就是通过服务端记录用户的状态。</strong> 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。</p>
<p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。</p>
<p>Cookie 存储在客户端中，而 Session 存储在服务器上，相对来说 Session 安全性更高。如果使用 Cookie 的一些敏感信息不要写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</p>
<!-- @include: @article-footer.snippet.md -->

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2024/08/24/sql-syntax-summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/08/24/sql-syntax-summary/" itemprop="url">SQL语法基础知识总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-08-24T21:43:41+08:00">
                2024-08-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/" itemprop="url" rel="index">
                    <span itemprop="name">面试问题</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2024/08/24/sql-syntax-summary/" class="leancloud_visitors" data-flag-title="SQL语法基础知识总结">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  8.9k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  34 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本文整理完善自下面这两份资料：</p>
<ul>
<li><a href="https://juejin.cn/post/6844903790571700231">SQL 语法速成手册</a></li>
<li><a href="https://www.begtut.com/mysql/mysql-tutorial.html">MySQL 超全教程</a></li>
</ul>
</blockquote>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="数据库术语"><a href="#数据库术语" class="headerlink" title="数据库术语"></a>数据库术语</h3><ul>
<li><code>数据库（database）</code> - 保存有组织的数据的容器（通常是一个文件或一组文件）。</li>
<li><code>数据表（table）</code> - 某种特定类型数据的结构化清单。</li>
<li><code>模式（schema）</code> - 关于数据库和表的布局及特性的信息。模式定义了数据在表中如何存储，包含存储什么样的数据，数据如何分解，各部分信息如何命名等信息。数据库和表都有模式。</li>
<li><code>列（column）</code> - 表中的一个字段。所有表都是由一个或多个列组成的。</li>
<li><code>行（row）</code> - 表中的一个记录。</li>
<li><code>主键（primary key）</code> - 一列（或一组列），其值能够唯一标识表中每一行。</li>
</ul>
<h3 id="SQL-语法"><a href="#SQL-语法" class="headerlink" title="SQL 语法"></a>SQL 语法</h3><p>SQL（Structured Query Language)，标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSI SQL。各个 DBMS 都有自己的实现，如 PL&#x2F;SQL、Transact-SQL 等。</p>
<h4 id="SQL-语法结构"><a href="#SQL-语法结构" class="headerlink" title="SQL 语法结构"></a>SQL 语法结构</h4><p><img src="https://oss.javaguide.cn/p3-juejin/cb684d4c75fc430e92aaee226069c7da~tplv-k3u1fbpfcp-zoom-1.png"></p>
<p>SQL 语法结构包括：</p>
<ul>
<li><strong><code>子句</code></strong> - 是语句和查询的组成成分。（在某些情况下，这些都是可选的。）</li>
<li><strong><code>表达式</code></strong> - 可以产生任何标量值，或由列和行的数据库表</li>
<li><strong><code>谓词</code></strong> - 给需要评估的 SQL 三值逻辑（3VL）（true&#x2F;false&#x2F;unknown）或布尔真值指定条件，并限制语句和查询的效果，或改变程序流程。</li>
<li><strong><code>查询</code></strong> - 基于特定条件检索数据。这是 SQL 的一个重要组成部分。</li>
<li><strong><code>语句</code></strong> - 可以持久地影响纲要和数据，也可以控制数据库事务、程序流程、连接、会话或诊断。</li>
</ul>
<h4 id="SQL-语法要点"><a href="#SQL-语法要点" class="headerlink" title="SQL 语法要点"></a>SQL 语法要点</h4><ul>
<li><strong>SQL 语句不区分大小写</strong>，但是数据库表名、列名和值是否区分，依赖于具体的 DBMS 以及配置。例如：<code>SELECT</code> 与 <code>select</code>、<code>Select</code> 是相同的。</li>
<li><strong>多条 SQL 语句必须以分号（<code>;</code>）分隔</strong>。</li>
<li>处理 SQL 语句时，<strong>所有空格都被忽略</strong>。</li>
</ul>
<p>SQL 语句可以写成一行，也可以分写为多行。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 一行 SQL 语句</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> username<span class="operator">=</span><span class="string">&#x27;robot&#x27;</span>, password<span class="operator">=</span><span class="string">&#x27;robot&#x27;</span> <span class="keyword">WHERE</span> username <span class="operator">=</span> <span class="string">&#x27;root&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 多行 SQL 语句</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">SET</span> username<span class="operator">=</span><span class="string">&#x27;robot&#x27;</span>, password<span class="operator">=</span><span class="string">&#x27;robot&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> username <span class="operator">=</span> <span class="string">&#x27;root&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>SQL 支持三种注释：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">## 注释<span class="number">1</span></span><br><span class="line"><span class="comment">-- 注释2</span></span><br><span class="line"><span class="comment">/* 注释3 */</span></span><br></pre></td></tr></table></figure>

<h3 id="SQL-分类"><a href="#SQL-分类" class="headerlink" title="SQL 分类"></a>SQL 分类</h3><h4 id="数据定义语言（DDL）"><a href="#数据定义语言（DDL）" class="headerlink" title="数据定义语言（DDL）"></a>数据定义语言（DDL）</h4><p>数据定义语言（Data Definition Language，DDL）是 SQL 语言集中负责数据结构定义与数据库对象定义的语言。</p>
<p>DDL 的主要功能是<strong>定义数据库对象</strong>。</p>
<p>DDL 的核心指令是 <code>CREATE</code>、<code>ALTER</code>、<code>DROP</code>。</p>
<h4 id="数据操纵语言（DML）"><a href="#数据操纵语言（DML）" class="headerlink" title="数据操纵语言（DML）"></a>数据操纵语言（DML）</h4><p>数据操纵语言（Data Manipulation Language, DML）是用于数据库操作，对数据库其中的对象和数据运行访问工作的编程语句。</p>
<p>DML 的主要功能是 <strong>访问数据</strong>，因此其语法都是以<strong>读写数据库</strong>为主。</p>
<p>DML 的核心指令是 <code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>SELECT</code>。这四个指令合称 CRUD(Create, Read, Update, Delete)，即增删改查。</p>
<h4 id="事务控制语言（TCL）"><a href="#事务控制语言（TCL）" class="headerlink" title="事务控制语言（TCL）"></a>事务控制语言（TCL）</h4><p>事务控制语言 (Transaction Control Language, TCL) 用于<strong>管理数据库中的事务</strong>。这些用于管理由 DML 语句所做的更改。它还允许将语句分组为逻辑事务。</p>
<p>TCL 的核心指令是 <code>COMMIT</code>、<code>ROLLBACK</code>。</p>
<h4 id="数据控制语言（DCL）"><a href="#数据控制语言（DCL）" class="headerlink" title="数据控制语言（DCL）"></a>数据控制语言（DCL）</h4><p>数据控制语言 (Data Control Language, DCL) 是一种可对数据访问权进行控制的指令，它可以控制特定用户账户对数据表、查看表、预存程序、用户自定义函数等数据库对象的控制权。</p>
<p>DCL 的核心指令是 <code>GRANT</code>、<code>REVOKE</code>。</p>
<p>DCL 以<strong>控制用户的访问权限</strong>为主，因此其指令作法并不复杂，可利用 DCL 控制的权限有：<code>CONNECT</code>、<code>SELECT</code>、<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>EXECUTE</code>、<code>USAGE</code>、<code>REFERENCES</code>。</p>
<p>根据不同的 DBMS 以及不同的安全性实体，其支持的权限控制也有所不同。</p>
<p><strong>我们先来介绍 DML 语句用法。 DML 的主要功能是读写数据库实现增删改查。</strong></p>
<h2 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h2><p>增删改查，又称为 CRUD，数据库基本操作中的基本操作。</p>
<h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p><code>INSERT INTO</code> 语句用于向表中插入新记录。</p>
<p><strong>插入完整的行</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 插入一行</span><br><span class="line"><span class="keyword">INSERT INTO</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">10</span>, <span class="string">&#x27;root&#x27;</span>, <span class="string">&#x27;root&#x27;</span>, <span class="string">&#x27;xxxx@163.com&#x27;</span>);</span><br><span class="line"># 插入多行</span><br><span class="line"><span class="keyword">INSERT INTO</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">10</span>, <span class="string">&#x27;root&#x27;</span>, <span class="string">&#x27;root&#x27;</span>, <span class="string">&#x27;xxxx@163.com&#x27;</span>), (<span class="number">12</span>, <span class="string">&#x27;user1&#x27;</span>, <span class="string">&#x27;user1&#x27;</span>, <span class="string">&#x27;xxxx@163.com&#x27;</span>), (<span class="number">18</span>, <span class="string">&#x27;user2&#x27;</span>, <span class="string">&#x27;user2&#x27;</span>, <span class="string">&#x27;xxxx@163.com&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>插入行的一部分</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> <span class="keyword">user</span>(username, password, email)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;xxxx@163.com&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>插入查询出来的数据</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> <span class="keyword">user</span>(username)</span><br><span class="line"><span class="keyword">SELECT</span> name</span><br><span class="line"><span class="keyword">FROM</span> account;</span><br></pre></td></tr></table></figure>

<h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><p><code>UPDATE</code> 语句用于更新表中的记录。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">SET</span> username<span class="operator">=</span><span class="string">&#x27;robot&#x27;</span>, password<span class="operator">=</span><span class="string">&#x27;robot&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> username <span class="operator">=</span> <span class="string">&#x27;root&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><ul>
<li><code>DELETE</code> 语句用于删除表中的记录。</li>
<li><code>TRUNCATE TABLE</code> 可以清空表，也就是删除所有行。说明：<code>TRUNCATE</code> 语句不属于 DML 语法而是 DDL 语法。</li>
</ul>
<p><strong>删除表中的指定数据</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">WHERE</span> username <span class="operator">=</span> <span class="string">&#x27;robot&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>清空表中的数据</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>

<h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><p><code>SELECT</code> 语句用于从数据库中查询数据。</p>
<p><code>DISTINCT</code> 用于返回唯一不同的值。它作用于所有列，也就是说所有列的值都相同才算相同。</p>
<p><code>LIMIT</code> 限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。</p>
<ul>
<li><code>ASC</code>：升序（默认）</li>
<li><code>DESC</code>：降序</li>
</ul>
<p><strong>查询单列</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> products;</span><br></pre></td></tr></table></figure>

<p><strong>查询多列</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products;</span><br></pre></td></tr></table></figure>

<p><strong>查询所有列</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> products;</span><br></pre></td></tr></table></figure>

<p><strong>查询不同的值</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span></span><br><span class="line">vend_id <span class="keyword">FROM</span> products;</span><br></pre></td></tr></table></figure>

<p><strong>限制查询结果</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 返回前 5 行</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mytable LIMIT <span class="number">5</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mytable LIMIT <span class="number">0</span>, <span class="number">5</span>;</span><br><span class="line"><span class="comment">-- 返回第 3 ~ 5 行</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mytable LIMIT <span class="number">2</span>, <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p><code>order by</code> 用于对结果集按照一个列或者多个列进行排序。默认按照升序对记录进行排序，如果需要按照降序对记录进行排序，可以使用 <code>desc</code> 关键字。</p>
<p><code>order by</code> 对多列排序的时候，先排序的列放前面，后排序的列放后面。并且，不同的列可以有不同的排序规则。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_price <span class="keyword">DESC</span>, prod_name <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>

<h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>**<code>group by</code>**：</p>
<ul>
<li><code>group by</code> 子句将记录分组到汇总行中。</li>
<li><code>group by</code> 为每个组返回一个记录。</li>
<li><code>group by</code> 通常还涉及聚合<code>count</code>，<code>max</code>，<code>sum</code>，<code>avg</code> 等。</li>
<li><code>group by</code> 可以按一列或多列进行分组。</li>
<li><code>group by</code> 按分组字段进行排序后，<code>order by</code> 可以以汇总字段来进行排序。</li>
</ul>
<p><strong>分组</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, <span class="built_in">COUNT</span>(cust_address) <span class="keyword">AS</span> addr_num</span><br><span class="line"><span class="keyword">FROM</span> Customers <span class="keyword">GROUP</span> <span class="keyword">BY</span> cust_name;</span><br></pre></td></tr></table></figure>

<p><strong>分组后排序</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, <span class="built_in">COUNT</span>(cust_address) <span class="keyword">AS</span> addr_num</span><br><span class="line"><span class="keyword">FROM</span> Customers <span class="keyword">GROUP</span> <span class="keyword">BY</span> cust_name</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cust_name <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<p>**<code>having</code>**：</p>
<ul>
<li><code>having</code> 用于对汇总的 <code>group by</code> 结果进行过滤。</li>
<li><code>having</code> 一般都是和 <code>group by</code> 连用。</li>
<li><code>where</code> 和 <code>having</code> 可以在相同的查询中。</li>
</ul>
<p><strong>使用 WHERE 和 HAVING 过滤数据</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> NumberOfOrders</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_email <span class="keyword">IS</span> <span class="keyword">NOT NULL</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> cust_name</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>**<code>having</code> vs <code>where</code>**：</p>
<ul>
<li><code>where</code>：过滤过滤指定的行，后面不能加聚合函数（分组函数）。<code>where</code> 在<code>group by</code> 前。</li>
<li><code>having</code>：过滤分组，一般都是和 <code>group by</code> 连用，不能单独使用。<code>having</code> 在 <code>group by</code> 之后。</li>
</ul>
<h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>子查询是嵌套在较大查询中的 SQL 查询，也称内部查询或内部选择，包含子查询的语句也称为外部查询或外部选择。简单来说，子查询就是指将一个 <code>select</code> 查询（子查询）的结果作为另一个 SQL 语句（主查询）的数据来源或者判断条件。</p>
<p>子查询可以嵌入 <code>SELECT</code>、<code>INSERT</code>、<code>UPDATE</code> 和 <code>DELETE</code> 语句中，也可以和 <code>=</code>、<code>&lt;</code>、<code>&gt;</code>、<code>IN</code>、<code>BETWEEN</code>、<code>EXISTS</code> 等运算符一起使用。</p>
<p>子查询常用在 <code>WHERE</code> 子句和 <code>FROM</code> 子句后边：</p>
<ul>
<li>当用于 <code>WHERE</code> 子句时，根据不同的运算符，子查询可以返回单行单列、多行单列、单行多列数据。子查询就是要返回能够作为 <code>WHERE</code> 子句查询条件的值。</li>
<li>当用于 <code>FROM</code> 子句时，一般返回多行多列数据，相当于返回一张临时表，这样才符合 <code>FROM</code> 后面是表的规则。这种做法能够实现多表联合查询。</li>
</ul>
<blockquote>
<p>注意：MYSQL 数据库从 4.1 版本才开始支持子查询，早期版本是不支持的。</p>
</blockquote>
<p>用于 <code>WHERE</code> 子句的子查询的基本语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> column_name [, column_name ]</span><br><span class="line"><span class="keyword">from</span>   table1 [, table2 ]</span><br><span class="line"><span class="keyword">where</span>  column_name operator</span><br><span class="line">    (<span class="keyword">select</span> column_name [, column_name ]</span><br><span class="line">    <span class="keyword">from</span> table1 [, table2 ]</span><br><span class="line">    [<span class="keyword">where</span>])</span><br></pre></td></tr></table></figure>

<ul>
<li>子查询需要放在括号<code>( )</code>内。</li>
<li><code>operator</code> 表示用于 where 子句的运算符。</li>
</ul>
<p>用于 <code>FROM</code> 子句的子查询的基本语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> column_name [, column_name ]</span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">select</span> column_name [, column_name ]</span><br><span class="line">      <span class="keyword">from</span> table1 [, table2 ]</span><br><span class="line">      [<span class="keyword">where</span>]) <span class="keyword">as</span> temp_table_name</span><br><span class="line"><span class="keyword">where</span>  <span class="keyword">condition</span></span><br></pre></td></tr></table></figure>

<p>用于 <code>FROM</code> 的子查询返回的结果相当于一张临时表，所以需要使用 AS 关键字为该临时表起一个名字。</p>
<p><strong>子查询的子查询</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> cust_id</span><br><span class="line">                  <span class="keyword">FROM</span> orders</span><br><span class="line">                  <span class="keyword">WHERE</span> order_num <span class="keyword">IN</span> (<span class="keyword">SELECT</span> order_num</span><br><span class="line">                                      <span class="keyword">FROM</span> orderitems</span><br><span class="line">                                      <span class="keyword">WHERE</span> prod_id <span class="operator">=</span> <span class="string">&#x27;RGAN01&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>内部查询首先在其父查询之前执行，以便可以将内部查询的结果传递给外部查询。执行过程可以参考下图：</p>
<p><img src="https://oss.javaguide.cn/p3-juejin/c439da1f5d4e4b00bdfa4316b933d764~tplv-k3u1fbpfcp-zoom-1.png"></p>
<h3 id="WHERE"><a href="#WHERE" class="headerlink" title="WHERE"></a>WHERE</h3><ul>
<li><code>WHERE</code> 子句用于过滤记录，即缩小访问数据的范围。</li>
<li><code>WHERE</code> 后跟一个返回 <code>true</code> 或 <code>false</code> 的条件。</li>
<li><code>WHERE</code> 可以与 <code>SELECT</code>，<code>UPDATE</code> 和 <code>DELETE</code> 一起使用。</li>
<li>可以在 <code>WHERE</code> 子句中使用的操作符。</li>
</ul>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;</td>
<td>等于</td>
</tr>
<tr>
<td>&lt;&gt;</td>
<td>不等于。注释：在 SQL 的一些版本中，该操作符可被写成 !&#x3D;</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td>&gt;&#x3D;</td>
<td>大于等于</td>
</tr>
<tr>
<td>&lt;&#x3D;</td>
<td>小于等于</td>
</tr>
<tr>
<td>BETWEEN</td>
<td>在某个范围内</td>
</tr>
<tr>
<td>LIKE</td>
<td>搜索某种模式</td>
</tr>
<tr>
<td>IN</td>
<td>指定针对某个列的多个可能值</td>
</tr>
</tbody></table>
<p><strong><code>SELECT</code> 语句中的 <code>WHERE</code> 子句</strong></p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM Customers</span><br><span class="line">WHERE <span class="attr">cust_name</span> = <span class="string">&#x27;Kids Place&#x27;</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p><strong><code>UPDATE</code> 语句中的 <code>WHERE</code> 子句</strong></p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE Customers</span><br><span class="line">SET <span class="attr">cust_name</span> = <span class="string">&#x27;Jack Jones&#x27;</span></span><br><span class="line">WHERE <span class="attr">cust_name</span> = <span class="string">&#x27;Kids Place&#x27;</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p><strong><code>DELETE</code> 语句中的 <code>WHERE</code> 子句</strong></p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM Customers</span><br><span class="line">WHERE <span class="attr">cust_name</span> = <span class="string">&#x27;Kids Place&#x27;</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>

<h3 id="IN-和-BETWEEN"><a href="#IN-和-BETWEEN" class="headerlink" title="IN 和 BETWEEN"></a>IN 和 BETWEEN</h3><ul>
<li><code>IN</code> 操作符在 <code>WHERE</code> 子句中使用，作用是在指定的几个特定值中任选一个值。</li>
<li><code>BETWEEN</code> 操作符在 <code>WHERE</code> 子句中使用，作用是选取介于某个范围内的值。</li>
</ul>
<p><strong>IN 示例</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="keyword">IN</span> (<span class="string">&#x27;DLL01&#x27;</span>, <span class="string">&#x27;BRS01&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>BETWEEN 示例</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="keyword">BETWEEN</span> <span class="number">3</span> <span class="keyword">AND</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<h3 id="AND、OR、NOT"><a href="#AND、OR、NOT" class="headerlink" title="AND、OR、NOT"></a>AND、OR、NOT</h3><ul>
<li><code>AND</code>、<code>OR</code>、<code>NOT</code> 是用于对过滤条件的逻辑处理指令。</li>
<li><code>AND</code> 优先级高于 <code>OR</code>，为了明确处理顺序，可以使用 <code>()</code>。</li>
<li><code>AND</code> 操作符表示左右条件都要满足。</li>
<li><code>OR</code> 操作符表示左右条件满足任意一个即可。</li>
<li><code>NOT</code> 操作符用于否定一个条件。</li>
</ul>
<p><strong>AND 示例</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="operator">=</span> <span class="string">&#x27;DLL01&#x27;</span> <span class="keyword">AND</span> prod_price <span class="operator">&lt;=</span> <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<p><strong>OR 示例</strong></p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_id, prod_name, prod_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE <span class="attr">vend_id</span> = <span class="string">&#x27;DLL01&#x27;</span> OR vend_id = <span class="string">&#x27;BRS01&#x27;</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p><strong>NOT 示例</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="keyword">NOT</span> <span class="keyword">BETWEEN</span> <span class="number">3</span> <span class="keyword">AND</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<h3 id="LIKE"><a href="#LIKE" class="headerlink" title="LIKE"></a>LIKE</h3><ul>
<li><code>LIKE</code> 操作符在 <code>WHERE</code> 子句中使用，作用是确定字符串是否匹配模式。</li>
<li>只有字段是文本值时才使用 <code>LIKE</code>。</li>
<li><code>LIKE</code> 支持两个通配符匹配选项：<code>%</code> 和 <code>_</code>。</li>
<li>不要滥用通配符，通配符位于开头处匹配会非常慢。</li>
<li><code>%</code> 表示任何字符出现任意次数。</li>
<li><code>_</code> 表示任何字符出现一次。</li>
</ul>
<p><strong>% 示例</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name <span class="keyword">LIKE</span> <span class="string">&#x27;%bean bag%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>_ 示例</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name <span class="keyword">LIKE</span> <span class="string">&#x27;__ inch teddy bear&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p>JOIN 是“连接”的意思，顾名思义，SQL JOIN 子句用于将两个或者多个表联合起来进行查询。</p>
<p>连接表时需要在每个表中选择一个字段，并对这些字段的值进行比较，值相同的两条记录将合并为一条。<strong>连接表的本质就是将不同表的记录合并起来，形成一张新表。当然，这张新表只是临时的，它仅存在于本次查询期间</strong>。</p>
<p>使用 <code>JOIN</code> 连接两个表的基本语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> table1.column1, table2.column2...</span><br><span class="line"><span class="keyword">from</span> table1</span><br><span class="line"><span class="keyword">join</span> table2</span><br><span class="line"><span class="keyword">on</span> table1.common_column1 <span class="operator">=</span> table2.common_column2;</span><br></pre></td></tr></table></figure>

<p><code>table1.common_column1 = table2.common_column2</code> 是连接条件，只有满足此条件的记录才会合并为一行。您可以使用多个运算符来连接表，例如 &#x3D;、&gt;、&lt;、&lt;&gt;、&lt;&#x3D;、&gt;&#x3D;、!&#x3D;、<code>between</code>、<code>like</code> 或者 <code>not</code>，但是最常见的是使用 &#x3D;。</p>
<p>当两个表中有同名的字段时，为了帮助数据库引擎区分是哪个表的字段，在书写同名字段名时需要加上表名。当然，如果书写的字段名在两个表中是唯一的，也可以不使用以上格式，只写字段名即可。</p>
<p>另外，如果两张表的关联字段名相同，也可以使用 <code>USING</code>子句来代替 <code>ON</code>，举个例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># join....on</span><br><span class="line"><span class="keyword">select</span> c.cust_name, o.order_num</span><br><span class="line"><span class="keyword">from</span> Customers c</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> Orders o</span><br><span class="line"><span class="keyword">on</span> c.cust_id <span class="operator">=</span> o.cust_id</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> c.cust_name;</span><br><span class="line"></span><br><span class="line"># 如果两张表的关联字段名相同，也可以使用<span class="keyword">USING</span>子句：join....using()</span><br><span class="line"><span class="keyword">select</span> c.cust_name, o.order_num</span><br><span class="line"><span class="keyword">from</span> Customers c</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> Orders o</span><br><span class="line"><span class="keyword">using</span>(cust_id)</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> c.cust_name;</span><br></pre></td></tr></table></figure>

<p><strong><code>ON</code> 和 <code>WHERE</code> 的区别</strong>：</p>
<ul>
<li>连接表时，SQL 会根据连接条件生成一张新的临时表。<code>ON</code> 就是连接条件，它决定临时表的生成。</li>
<li><code>WHERE</code> 是在临时表生成以后，再对临时表中的数据进行过滤，生成最终的结果集，这个时候已经没有 JOIN-ON 了。</li>
</ul>
<p>所以总结来说就是：<strong>SQL 先根据 ON 生成一张临时表，然后再根据 WHERE 对临时表进行筛选</strong>。</p>
<p>SQL 允许在 <code>JOIN</code> 左边加上一些修饰性的关键词，从而形成不同类型的连接，如下表所示：</p>
<table>
<thead>
<tr>
<th>连接类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>INNER JOIN 内连接</td>
<td>（默认连接方式）只有当两个表都存在满足条件的记录时才会返回行。</td>
</tr>
<tr>
<td>LEFT JOIN &#x2F; LEFT OUTER JOIN 左(外)连接</td>
<td>返回左表中的所有行，即使右表中没有满足条件的行也是如此。</td>
</tr>
<tr>
<td>RIGHT JOIN &#x2F; RIGHT OUTER JOIN 右(外)连接</td>
<td>返回右表中的所有行，即使左表中没有满足条件的行也是如此。</td>
</tr>
<tr>
<td>FULL JOIN &#x2F; FULL OUTER JOIN 全(外)连接</td>
<td>只要其中有一个表存在满足条件的记录，就返回行。</td>
</tr>
<tr>
<td>SELF JOIN</td>
<td>将一个表连接到自身，就像该表是两个表一样。为了区分两个表，在 SQL 语句中需要至少重命名一个表。</td>
</tr>
<tr>
<td>CROSS JOIN</td>
<td>交叉连接，从两个或者多个连接表中返回记录集的笛卡尔积。</td>
</tr>
</tbody></table>
<p>下图展示了 LEFT JOIN、RIGHT JOIN、INNER JOIN、OUTER JOIN 相关的 7 种用法。</p>
<p><img src="https://oss.javaguide.cn/p3-juejin/701670942f0f45d3a3a2187cd04a12ad~tplv-k3u1fbpfcp-zoom-1.png"></p>
<p>如果不加任何修饰词，只写 <code>JOIN</code>，那么默认为 <code>INNER JOIN</code></p>
<p>对于 <code>INNER JOIN</code> 来说，还有一种隐式的写法，称为 “<strong>隐式内连接</strong>”，也就是没有 <code>INNER JOIN</code> 关键字，使用 <code>WHERE</code> 语句实现内连接的功能</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 隐式内连接</span><br><span class="line"><span class="keyword">select</span> c.cust_name, o.order_num</span><br><span class="line"><span class="keyword">from</span> Customers c, Orders o</span><br><span class="line"><span class="keyword">where</span> c.cust_id <span class="operator">=</span> o.cust_id</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> c.cust_name;</span><br><span class="line"></span><br><span class="line"># 显式内连接</span><br><span class="line"><span class="keyword">select</span> c.cust_name, o.order_num</span><br><span class="line"><span class="keyword">from</span> Customers c <span class="keyword">inner</span> <span class="keyword">join</span> Orders o</span><br><span class="line"><span class="keyword">using</span>(cust_id)</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> c.cust_name;</span><br></pre></td></tr></table></figure>

<h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p><code>UNION</code> 运算符将两个或更多查询的结果组合起来，并生成一个结果集，其中包含来自 <code>UNION</code> 中参与查询的提取行。</p>
<p><code>UNION</code> 基本规则：</p>
<ul>
<li>所有查询的列数和列顺序必须相同。</li>
<li>每个查询中涉及表的列的数据类型必须相同或兼容。</li>
<li>通常返回的列名取自第一个查询。</li>
</ul>
<p>默认地，<code>UNION</code> 操作符选取不同的值。如果允许重复的值，请使用 <code>UNION ALL</code>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> table2;</span><br></pre></td></tr></table></figure>

<p><code>UNION</code> 结果集中的列名总是等于 <code>UNION</code> 中第一个 <code>SELECT</code> 语句中的列名。</p>
<p><code>JOIN</code> vs <code>UNION</code>：</p>
<ul>
<li><code>JOIN</code> 中连接表的列可能不同，但在 <code>UNION</code> 中，所有查询的列数和列顺序必须相同。</li>
<li><code>UNION</code> 将查询之后的行放在一起（垂直放置），但 <code>JOIN</code> 将查询之后的列放在一起（水平放置），即它构成一个笛卡尔积。</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>不同数据库的函数往往各不相同，因此不可移植。本节主要以 MySQL 的函数为例。</p>
<h3 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h3><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>LEFT()</code>、<code>RIGHT()</code></td>
<td>左边或者右边的字符</td>
</tr>
<tr>
<td><code>LOWER()</code>、<code>UPPER()</code></td>
<td>转换为小写或者大写</td>
</tr>
<tr>
<td><code>LTRIM()</code>、<code>RTRIM()</code></td>
<td>去除左边或者右边的空格</td>
</tr>
<tr>
<td><code>LENGTH()</code></td>
<td>长度，以字节为单位</td>
</tr>
<tr>
<td><code>SOUNDEX()</code></td>
<td>转换为语音值</td>
</tr>
</tbody></table>
<p>其中， <strong><code>SOUNDEX()</code></strong> 可以将一个字符串转换为描述其语音表示的字母数字模式。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> SOUNDEX(col1) <span class="operator">=</span> SOUNDEX(<span class="string">&#x27;apple&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="日期和时间处理"><a href="#日期和时间处理" class="headerlink" title="日期和时间处理"></a>日期和时间处理</h3><ul>
<li>日期格式：<code>YYYY-MM-DD</code></li>
<li>时间格式：<code>HH:MM:SS</code></li>
</ul>
<table>
<thead>
<tr>
<th>函 数</th>
<th>说 明</th>
</tr>
</thead>
<tbody><tr>
<td><code>AddDate()</code></td>
<td>增加一个日期（天、周等）</td>
</tr>
<tr>
<td><code>AddTime()</code></td>
<td>增加一个时间（时、分等）</td>
</tr>
<tr>
<td><code>CurDate()</code></td>
<td>返回当前日期</td>
</tr>
<tr>
<td><code>CurTime()</code></td>
<td>返回当前时间</td>
</tr>
<tr>
<td><code>Date()</code></td>
<td>返回日期时间的日期部分</td>
</tr>
<tr>
<td><code>DateDiff()</code></td>
<td>计算两个日期之差</td>
</tr>
<tr>
<td><code>Date_Add()</code></td>
<td>高度灵活的日期运算函数</td>
</tr>
<tr>
<td><code>Date_Format()</code></td>
<td>返回一个格式化的日期或时间串</td>
</tr>
<tr>
<td><code>Day()</code></td>
<td>返回一个日期的天数部分</td>
</tr>
<tr>
<td><code>DayOfWeek()</code></td>
<td>对于一个日期，返回对应的星期几</td>
</tr>
<tr>
<td><code>Hour()</code></td>
<td>返回一个时间的小时部分</td>
</tr>
<tr>
<td><code>Minute()</code></td>
<td>返回一个时间的分钟部分</td>
</tr>
<tr>
<td><code>Month()</code></td>
<td>返回一个日期的月份部分</td>
</tr>
<tr>
<td><code>Now()</code></td>
<td>返回当前日期和时间</td>
</tr>
<tr>
<td><code>Second()</code></td>
<td>返回一个时间的秒部分</td>
</tr>
<tr>
<td><code>Time()</code></td>
<td>返回一个日期时间的时间部分</td>
</tr>
<tr>
<td><code>Year()</code></td>
<td>返回一个日期的年份部分</td>
</tr>
</tbody></table>
<h3 id="数值处理"><a href="#数值处理" class="headerlink" title="数值处理"></a>数值处理</h3><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>SIN()</td>
<td>正弦</td>
</tr>
<tr>
<td>COS()</td>
<td>余弦</td>
</tr>
<tr>
<td>TAN()</td>
<td>正切</td>
</tr>
<tr>
<td>ABS()</td>
<td>绝对值</td>
</tr>
<tr>
<td>SQRT()</td>
<td>平方根</td>
</tr>
<tr>
<td>MOD()</td>
<td>余数</td>
</tr>
<tr>
<td>EXP()</td>
<td>指数</td>
</tr>
<tr>
<td>PI()</td>
<td>圆周率</td>
</tr>
<tr>
<td>RAND()</td>
<td>随机数</td>
</tr>
</tbody></table>
<h3 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h3><table>
<thead>
<tr>
<th>函 数</th>
<th>说 明</th>
</tr>
</thead>
<tbody><tr>
<td><code>AVG()</code></td>
<td>返回某列的平均值</td>
</tr>
<tr>
<td><code>COUNT()</code></td>
<td>返回某列的行数</td>
</tr>
<tr>
<td><code>MAX()</code></td>
<td>返回某列的最大值</td>
</tr>
<tr>
<td><code>MIN()</code></td>
<td>返回某列的最小值</td>
</tr>
<tr>
<td><code>SUM()</code></td>
<td>返回某列值之和</td>
</tr>
</tbody></table>
<p><code>AVG()</code> 会忽略 NULL 行。</p>
<p>使用 <code>DISTINCT</code> 可以让汇总函数值汇总不同的值。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(<span class="keyword">DISTINCT</span> col1) <span class="keyword">AS</span> avg_col</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br></pre></td></tr></table></figure>

<p><strong>接下来，我们来介绍 DDL 语句用法。DDL 的主要功能是定义数据库对象（如：数据库、数据表、视图、索引等）</strong></p>
<h2 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h2><h3 id="数据库（DATABASE）"><a href="#数据库（DATABASE）" class="headerlink" title="数据库（DATABASE）"></a>数据库（DATABASE）</h3><h4 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE test;</span><br></pre></td></tr></table></figure>

<h4 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE test;</span><br></pre></td></tr></table></figure>

<h4 id="选择数据库"><a href="#选择数据库" class="headerlink" title="选择数据库"></a>选择数据库</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USE test;</span><br></pre></td></tr></table></figure>

<h3 id="数据表（TABLE）"><a href="#数据表（TABLE）" class="headerlink" title="数据表（TABLE）"></a>数据表（TABLE）</h3><h4 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h4><p><strong>普通创建</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> <span class="keyword">user</span> (</span><br><span class="line">  id <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;Id&#x27;</span>,</span><br><span class="line">  username <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;default&#x27;</span> COMMENT <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">  password <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;default&#x27;</span> COMMENT <span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">  email <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;default&#x27;</span> COMMENT <span class="string">&#x27;邮箱&#x27;</span></span><br><span class="line">) COMMENT<span class="operator">=</span><span class="string">&#x27;用户表&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>根据已有的表创建新表</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> vip_user <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>

<h4 id="删除数据表"><a href="#删除数据表" class="headerlink" title="删除数据表"></a>删除数据表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>

<h4 id="修改数据表"><a href="#修改数据表" class="headerlink" title="修改数据表"></a>修改数据表</h4><p><strong>添加列</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">ADD</span> age <span class="type">int</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p><strong>删除列</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> age;</span><br></pre></td></tr></table></figure>

<p><strong>修改列</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> `<span class="keyword">user</span>`</span><br><span class="line">MODIFY <span class="keyword">COLUMN</span> age tinyint;</span><br></pre></td></tr></table></figure>

<p><strong>添加主键</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">PRIMARY KEY</span> (id);</span><br></pre></td></tr></table></figure>

<p><strong>删除主键</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PRIMARY KEY</span>;</span><br></pre></td></tr></table></figure>

<h3 id="视图（VIEW）"><a href="#视图（VIEW）" class="headerlink" title="视图（VIEW）"></a>视图（VIEW）</h3><p>定义：</p>
<ul>
<li>视图是基于 SQL 语句的结果集的可视化的表。</li>
<li>视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作。对视图的操作和对普通表的操作一样。</li>
</ul>
<p>作用：</p>
<ul>
<li>简化复杂的 SQL 操作，比如复杂的联结；</li>
<li>只使用实际表的一部分数据；</li>
<li>通过只给用户访问视图的权限，保证数据的安全性；</li>
<li>更改数据格式和表示。</li>
</ul>
<p><img src="https://oss.javaguide.cn/p3-juejin/ec4c975296ea4a7097879dac7c353878~tplv-k3u1fbpfcp-zoom-1.jpeg" alt="mysql视图"></p>
<h4 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> top_10_user_view <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> id, username</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">&lt;</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h4 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> top_10_user_view;</span><br></pre></td></tr></table></figure>

<h3 id="索引（INDEX）"><a href="#索引（INDEX）" class="headerlink" title="索引（INDEX）"></a>索引（INDEX）</h3><p><strong>索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。</strong></p>
<p>索引的作用就相当于书的目录。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>使用索引可以大大加快 数据的检索速度（大大减少检索的数据量）, 这也是创建索引的最主要的原因。</li>
<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li>
<li>索引需要使用物理文件存储，也会耗费一定空间。</li>
</ul>
<p>但是，<strong>使用索引一定能提高查询性能吗?</strong></p>
<p>大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。</p>
<p>关于索引的详细介绍，请看我写的 <a href="https://javaguide.cn/database/mysql/mysql-index.html">MySQL 索引详解</a> 这篇文章。</p>
<h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX user_index</span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">user</span> (id);</span><br></pre></td></tr></table></figure>

<h4 id="添加索引"><a href="#添加索引" class="headerlink" title="添加索引"></a>添加索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER table</span> <span class="keyword">user</span> <span class="keyword">ADD</span> INDEX user_index(id)</span><br></pre></td></tr></table></figure>

<h4 id="创建唯一索引"><a href="#创建唯一索引" class="headerlink" title="创建唯一索引"></a>创建唯一索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX user_index</span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">user</span> (id);</span><br></pre></td></tr></table></figure>

<h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">DROP</span> INDEX user_index;</span><br></pre></td></tr></table></figure>

<h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p>SQL 约束用于规定表中的数据规则。</p>
<p>如果存在违反约束的数据行为，行为会被约束终止。</p>
<p>约束可以在创建表时规定（通过 CREATE TABLE 语句），或者在表创建之后规定（通过 ALTER TABLE 语句）。</p>
<p>约束类型：</p>
<ul>
<li><code>NOT NULL</code> - 指示某列不能存储 NULL 值。</li>
<li><code>UNIQUE</code> - 保证某列的每行必须有唯一的值。</li>
<li><code>PRIMARY KEY</code> - NOT NULL 和 UNIQUE 的结合。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。</li>
<li><code>FOREIGN KEY</code> - 保证一个表中的数据匹配另一个表中的值的参照完整性。</li>
<li><code>CHECK</code> - 保证列中的值符合指定的条件。</li>
<li><code>DEFAULT</code> - 规定没有给列赋值时的默认值。</li>
</ul>
<p>创建表时使用约束条件：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> Users (</span><br><span class="line">  Id <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;自增Id&#x27;</span>,</span><br><span class="line">  Username <span class="type">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT NULL</span> <span class="keyword">UNIQUE</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;default&#x27;</span> COMMENT <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">  Password <span class="type">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;default&#x27;</span> COMMENT <span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">  Email <span class="type">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;default&#x27;</span> COMMENT <span class="string">&#x27;邮箱地址&#x27;</span>,</span><br><span class="line">  Enabled TINYINT(<span class="number">4</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;是否有效&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (Id)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">2</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 COMMENT<span class="operator">=</span><span class="string">&#x27;用户表&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>接下来，我们来介绍 TCL 语句用法。TCL 的主要功能是管理数据库中的事务。</strong></p>
<h2 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h2><p>不能回退 <code>SELECT</code> 语句，回退 <code>SELECT</code> 语句也没意义；也不能回退 <code>CREATE</code> 和 <code>DROP</code> 语句。</p>
<p><strong>MySQL 默认是隐式提交</strong>，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 <code>START TRANSACTION</code> 语句时，会关闭隐式提交；当 <code>COMMIT</code> 或 <code>ROLLBACK</code> 语句执行后，事务会自动关闭，重新恢复隐式提交。</p>
<p>通过 <code>set autocommit=0</code> 可以取消自动提交，直到 <code>set autocommit=1</code> 才会提交；<code>autocommit</code> 标记是针对每个连接而不是针对服务器的。</p>
<p>指令：</p>
<ul>
<li><code>START TRANSACTION</code> - 指令用于标记事务的起始点。</li>
<li><code>SAVEPOINT</code> - 指令用于创建保留点。</li>
<li><code>ROLLBACK TO</code> - 指令用于回滚到指定的保留点；如果没有设置保留点，则回退到 <code>START TRANSACTION</code> 语句处。</li>
<li><code>COMMIT</code> - 提交事务。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开始事务</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入操作 A</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> `<span class="keyword">user</span>`</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;root1&#x27;</span>, <span class="string">&#x27;root1&#x27;</span>, <span class="string">&#x27;xxxx@163.com&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建保留点 updateA</span></span><br><span class="line"><span class="keyword">SAVEPOINT</span> updateA;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入操作 B</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> `<span class="keyword">user</span>`</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">&#x27;root2&#x27;</span>, <span class="string">&#x27;root2&#x27;</span>, <span class="string">&#x27;xxxx@163.com&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 回滚到保留点 updateA</span></span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> updateA;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提交事务，只有操作 A 生效</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p><strong>接下来，我们来介绍 DCL 语句用法。DCL 的主要功能是控制用户的访问权限。</strong></p>
<h2 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h2><p>要授予用户帐户权限，可以用<code>GRANT</code>命令。要撤销用户的权限，可以用<code>REVOKE</code>命令。这里以 MySQL 为例，介绍权限控制实际应用。</p>
<p><code>GRANT</code>授予权限语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> privilege,[privilege],.. <span class="keyword">ON</span> privilege_level</span><br><span class="line"><span class="keyword">TO</span> <span class="keyword">user</span> [IDENTIFIED <span class="keyword">BY</span> password]</span><br><span class="line">[REQUIRE tsl_option]</span><br><span class="line">[<span class="keyword">WITH</span> [GRANT_OPTION <span class="operator">|</span> resource_option]];</span><br></pre></td></tr></table></figure>

<p>简单解释一下：</p>
<ol>
<li>在<code>GRANT</code>关键字后指定一个或多个权限。如果授予用户多个权限，则每个权限由逗号分隔。</li>
<li><code>ON privilege_level</code> 确定权限应用级别。MySQL 支持 global（<code>*.*</code>），database（<code>database.*</code>），table（<code>database.table</code>）和列级别。如果使用列权限级别，则必须在每个权限之后指定一个或逗号分隔列的列表。</li>
<li><code>user</code> 是要授予权限的用户。如果用户已存在，则<code>GRANT</code>语句将修改其权限。否则，<code>GRANT</code>语句将创建一个新用户。可选子句<code>IDENTIFIED BY</code>允许您为用户设置新的密码。</li>
<li><code>REQUIRE tsl_option</code>指定用户是否必须通过 SSL，X059 等安全连接连接到数据库服务器。</li>
<li>可选 <code>WITH GRANT OPTION</code> 子句允许您授予其他用户或从其他用户中删除您拥有的权限。此外，您可以使用<code>WITH</code>子句分配 MySQL 数据库服务器的资源，例如，设置用户每小时可以使用的连接数或语句数。这在 MySQL 共享托管等共享环境中非常有用。</li>
</ol>
<p><code>REVOKE</code> 撤销权限语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span>   privilege_type [(column_list)]</span><br><span class="line">        [, priv_type [(column_list)]]...</span><br><span class="line"><span class="keyword">ON</span> [object_type] privilege_level</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">user</span> [, <span class="keyword">user</span>]...</span><br></pre></td></tr></table></figure>

<p>简单解释一下：</p>
<ol>
<li>在 <code>REVOKE</code> 关键字后面指定要从用户撤消的权限列表。您需要用逗号分隔权限。</li>
<li>指定在 <code>ON</code> 子句中撤销特权的特权级别。</li>
<li>指定要撤消 <code>FROM</code> 子句中的权限的用户帐户。</li>
</ol>
<p><code>GRANT</code> 和 <code>REVOKE</code> 可在几个层次上控制访问权限：</p>
<ul>
<li>整个服务器，使用 <code>GRANT ALL</code> 和 <code>REVOKE ALL</code>；</li>
<li>整个数据库，使用 <code>ON database.*</code>；</li>
<li>特定的表，使用 <code>ON database.table</code>；</li>
<li>特定的列；</li>
<li>特定的存储过程。</li>
</ul>
<p>新创建的账户没有任何权限。账户用 <code>username@host</code> 的形式定义，<code>username@%</code> 使用的是默认主机名。MySQL 的账户信息保存在 mysql 这个数据库中。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">USE mysql;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">user</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>

<p>下表说明了可用于<code>GRANT</code>和<code>REVOKE</code>语句的所有允许权限：</p>
<table>
<thead>
<tr>
<th><strong>特权</strong></th>
<th><strong>说明</strong></th>
<th><strong>级别</strong></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>全局</strong></td>
<td>数据库</td>
<td><strong>表</strong></td>
<td><strong>列</strong></td>
<td><strong>程序</strong></td>
<td><strong>代理</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ALL [PRIVILEGES]</td>
<td>授予除 GRANT OPTION 之外的指定访问级别的所有权限</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ALTER</td>
<td>允许用户使用 ALTER TABLE 语句</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ALTER ROUTINE</td>
<td>允许用户更改或删除存储的例程</td>
<td>X</td>
<td>X</td>
<td></td>
<td></td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>CREATE</td>
<td>允许用户创建数据库和表</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>CREATE ROUTINE</td>
<td>允许用户创建存储的例程</td>
<td>X</td>
<td>X</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>CREATE TABLESPACE</td>
<td>允许用户创建，更改或删除表空间和日志文件组</td>
<td>X</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>CREATE TEMPORARY TABLES</td>
<td>允许用户使用 CREATE TEMPORARY TABLE 创建临时表</td>
<td>X</td>
<td>X</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>CREATE USER</td>
<td>允许用户使用 CREATE USER，DROP USER，RENAME USER 和 REVOKE ALL PRIVILEGES 语句。</td>
<td>X</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>CREATE VIEW</td>
<td>允许用户创建或修改视图。</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>DELETE</td>
<td>允许用户使用 DELETE</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>DROP</td>
<td>允许用户删除数据库，表和视图</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>EVENT</td>
<td>启用事件计划程序的事件使用。</td>
<td>X</td>
<td>X</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>EXECUTE</td>
<td>允许用户执行存储的例程</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>FILE</td>
<td>允许用户读取数据库目录中的任何文件。</td>
<td>X</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>GRANT OPTION</td>
<td>允许用户拥有授予或撤消其他帐户权限的权限。</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td></td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>INDEX</td>
<td>允许用户创建或删除索引。</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>INSERT</td>
<td>允许用户使用 INSERT 语句</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>LOCK TABLES</td>
<td>允许用户对具有 SELECT 权限的表使用 LOCK TABLES</td>
<td>X</td>
<td>X</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>PROCESS</td>
<td>允许用户使用 SHOW PROCESSLIST 语句查看所有进程。</td>
<td>X</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>PROXY</td>
<td>启用用户代理。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>REFERENCES</td>
<td>允许用户创建外键</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>RELOAD</td>
<td>允许用户使用 FLUSH 操作</td>
<td>X</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>REPLICATION CLIENT</td>
<td>允许用户查询以查看主服务器或从属服务器的位置</td>
<td>X</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>REPLICATION SLAVE</td>
<td>允许用户使用复制从属从主服务器读取二进制日志事件。</td>
<td>X</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>SELECT</td>
<td>允许用户使用 SELECT 语句</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>SHOW DATABASES</td>
<td>允许用户显示所有数据库</td>
<td>X</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>SHOW VIEW</td>
<td>允许用户使用 SHOW CREATE VIEW 语句</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>SHUTDOWN</td>
<td>允许用户使用 mysqladmin shutdown 命令</td>
<td>X</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>SUPER</td>
<td>允许用户使用其他管理操作，例如 CHANGE MASTER TO，KILL，PURGE BINARY LOGS，SET GLOBAL 和 mysqladmin 命令</td>
<td>X</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>TRIGGER</td>
<td>允许用户使用 TRIGGER 操作。</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>UPDATE</td>
<td>允许用户使用 UPDATE 语句</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>USAGE</td>
<td>相当于“没有特权”</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="创建账户"><a href="#创建账户" class="headerlink" title="创建账户"></a>创建账户</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> myuser IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;mypassword&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="修改账户名"><a href="#修改账户名" class="headerlink" title="修改账户名"></a>修改账户名</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> <span class="keyword">user</span><span class="operator">=</span><span class="string">&#x27;newuser&#x27;</span> <span class="keyword">WHERE</span> <span class="keyword">user</span><span class="operator">=</span><span class="string">&#x27;myuser&#x27;</span>;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<h3 id="删除账户"><a href="#删除账户" class="headerlink" title="删除账户"></a>删除账户</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> myuser;</span><br></pre></td></tr></table></figure>

<h3 id="查看权限"><a href="#查看权限" class="headerlink" title="查看权限"></a>查看权限</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> myuser;</span><br></pre></td></tr></table></figure>

<h3 id="授予权限"><a href="#授予权限" class="headerlink" title="授予权限"></a>授予权限</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span> <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> myuser;</span><br></pre></td></tr></table></figure>

<h3 id="删除权限"><a href="#删除权限" class="headerlink" title="删除权限"></a>删除权限</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span> <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">FROM</span> myuser;</span><br></pre></td></tr></table></figure>

<h3 id="更改密码"><a href="#更改密码" class="headerlink" title="更改密码"></a>更改密码</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> PASSWORD <span class="keyword">FOR</span> myuser <span class="operator">=</span> <span class="string">&#x27;mypass&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>存储过程可以看成是对一系列 SQL 操作的批处理。存储过程可以由触发器，其他存储过程以及 Java， Python，PHP 等应用程序调用。</p>
<p><img src="https://oss.javaguide.cn/p3-juejin/60afdc9c9a594f079727ec64a2e698a3~tplv-k3u1fbpfcp-zoom-1.jpeg" alt="mysql存储过程"></p>
<p>使用存储过程的好处：</p>
<ul>
<li>代码封装，保证了一定的安全性；</li>
<li>代码复用；</li>
<li>由于是预先编译，因此具有很高的性能。</li>
</ul>
<p>创建存储过程：</p>
<ul>
<li>命令行中创建存储过程需要自定义分隔符，因为命令行是以 <code>;</code> 为结束符，而存储过程中也包含了分号，因此会错误把这部分分号当成是结束符，造成语法错误。</li>
<li>包含 <code>in</code>、<code>out</code> 和 <code>inout</code> 三种参数。</li>
<li>给变量赋值都需要用 <code>select into</code> 语句。</li>
<li>每次只能给一个变量赋值，不支持集合的操作。</li>
</ul>
<p>需要注意的是：<strong>阿里巴巴《Java 开发手册》强制禁止使用存储过程。因为存储过程难以调试和扩展，更没有移植性。</strong></p>
<p><img src="https://oss.javaguide.cn/p3-juejin/93a5e011ade4450ebfa5d82057532a49~tplv-k3u1fbpfcp-zoom-1.png"></p>
<p>至于到底要不要在项目中使用，还是要看项目实际需求，权衡好利弊即可！</p>
<h3 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> IF <span class="keyword">EXISTS</span> `proc_adder`;</span><br><span class="line">DELIMITER ;;</span><br><span class="line"><span class="keyword">CREATE</span> DEFINER<span class="operator">=</span>`root`@`localhost` <span class="keyword">PROCEDURE</span> `proc_adder`(<span class="keyword">IN</span> a <span class="type">int</span>, <span class="keyword">IN</span> b <span class="type">int</span>, <span class="keyword">OUT</span> sum <span class="type">int</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> c <span class="type">int</span>;</span><br><span class="line">    if a <span class="keyword">is</span> <span class="keyword">null</span> <span class="keyword">then</span> <span class="keyword">set</span> a <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span> if;</span><br><span class="line"></span><br><span class="line">    if b <span class="keyword">is</span> <span class="keyword">null</span> <span class="keyword">then</span> <span class="keyword">set</span> b <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span> if;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> sum  <span class="operator">=</span> a <span class="operator">+</span> b;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">;;</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<h3 id="使用存储过程"><a href="#使用存储过程" class="headerlink" title="使用存储过程"></a>使用存储过程</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">set</span> @<span class="selector-tag">b</span>=<span class="number">5</span>;</span><br><span class="line"><span class="selector-tag">call</span> <span class="selector-tag">proc_adder</span>(<span class="number">2</span>,<span class="variable">@b</span>,<span class="variable">@s</span>);</span><br><span class="line"><span class="selector-tag">select</span> @<span class="selector-tag">s</span> <span class="selector-tag">as</span> <span class="selector-tag">sum</span>;</span><br></pre></td></tr></table></figure>

<h2 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h2><p>游标（cursor）是一个存储在 DBMS 服务器上的数据库查询，它不是一条 <code>SELECT</code> 语句，而是被该语句检索出来的结果集。</p>
<p>在存储过程中使用游标可以对一个结果集进行移动遍历。</p>
<p>游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改。</p>
<p>使用游标的几个明确步骤：</p>
<ul>
<li><p>在使用游标前，必须声明(定义)它。这个过程实际上没有检索数据， 它只是定义要使用的 <code>SELECT</code> 语句和游标选项。</p>
</li>
<li><p>一旦声明，就必须打开游标以供使用。这个过程用前面定义的 SELECT 语句把数据实际检索出来。</p>
</li>
<li><p>对于填有数据的游标，根据需要取出(检索)各行。</p>
</li>
<li><p>在结束游标使用时，必须关闭游标，可能的话，释放游标(有赖于具</p>
<p>体的 DBMS)。</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">PROCEDURE</span> getTotal()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> total <span class="type">INT</span>;</span><br><span class="line">    <span class="comment">-- 创建接收游标数据的变量</span></span><br><span class="line">    <span class="keyword">DECLARE</span> sid <span class="type">INT</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> sname <span class="type">VARCHAR</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">-- 创建总数变量</span></span><br><span class="line">    <span class="keyword">DECLARE</span> sage <span class="type">INT</span>;</span><br><span class="line">    <span class="comment">-- 创建结束标志变量</span></span><br><span class="line">    <span class="keyword">DECLARE</span> done <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">-- 创建游标</span></span><br><span class="line">    <span class="keyword">DECLARE</span> cur <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> <span class="keyword">SELECT</span> id,name,age <span class="keyword">from</span> cursor_table <span class="keyword">where</span> age<span class="operator">&gt;</span><span class="number">30</span>;</span><br><span class="line">    <span class="comment">-- 指定游标循环结束时的返回值</span></span><br><span class="line">    <span class="keyword">DECLARE</span> CONTINUE HANDLER <span class="keyword">FOR</span> <span class="keyword">NOT</span> FOUND <span class="keyword">SET</span> done <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">SET</span> total <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">OPEN</span> cur;</span><br><span class="line">    <span class="keyword">FETCH</span> cur <span class="keyword">INTO</span> sid, sname, sage;</span><br><span class="line">    WHILE(<span class="keyword">NOT</span> done)</span><br><span class="line">    DO</span><br><span class="line">        <span class="keyword">SET</span> total <span class="operator">=</span> total <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">FETCH</span> cur <span class="keyword">INTO</span> sid, sname, sage;</span><br><span class="line">    <span class="keyword">END</span> WHILE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">CLOSE</span> cur;</span><br><span class="line">    <span class="keyword">SELECT</span> total;</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 调用存储过程</span></span><br><span class="line"><span class="keyword">call</span> getTotal();</span><br></pre></td></tr></table></figure>

<h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>触发器是一种与表操作有关的数据库对象，当触发器所在表上出现指定事件时，将调用该对象，即表的操作事件触发表上的触发器的执行。</p>
<p>我们可以使用触发器来进行审计跟踪，把修改记录到另外一张表中。</p>
<p>使用触发器的优点：</p>
<ul>
<li>SQL 触发器提供了另一种检查数据完整性的方法。</li>
<li>SQL 触发器可以捕获数据库层中业务逻辑中的错误。</li>
<li>SQL 触发器提供了另一种运行计划任务的方法。通过使用 SQL 触发器，您不必等待运行计划任务，因为在对表中的数据进行更改之前或之后会自动调用触发器。</li>
<li>SQL 触发器对于审计表中数据的更改非常有用。</li>
</ul>
<p>使用触发器的缺点：</p>
<ul>
<li>SQL 触发器只能提供扩展验证，并且不能替换所有验证。必须在应用程序层中完成一些简单的验证。例如，您可以使用 JavaScript 在客户端验证用户的输入，或者使用服务器端脚本语言（如 JSP，PHP，ASP.NET，Perl）在服务器端验证用户的输入。</li>
<li>从客户端应用程序调用和执行 SQL 触发器是不可见的，因此很难弄清楚数据库层中发生了什么。</li>
<li>SQL 触发器可能会增加数据库服务器的开销。</li>
</ul>
<p>MySQL 不允许在触发器中使用 CALL 语句 ，也就是不能调用存储过程。</p>
<blockquote>
<p>注意：在 MySQL 中，分号 <code>;</code> 是语句结束的标识符，遇到分号表示该段语句已经结束，MySQL 可以开始执行了。因此，解释器遇到触发器执行动作中的分号后就开始执行，然后会报错，因为没有找到和 BEGIN 匹配的 END。</p>
<p>这时就会用到 <code>DELIMITER</code> 命令（DELIMITER 是定界符，分隔符的意思）。它是一条命令，不需要语句结束标识，语法为：<code>DELIMITER new_delimiter</code>。<code>new_delimiter</code> 可以设为 1 个或多个长度的符号，默认的是分号 <code>;</code>，我们可以把它修改为其他符号，如 <code>$</code> - <code>DELIMITER $</code> 。在这之后的语句，以分号结束，解释器不会有什么反应，只有遇到了 <code>$</code>，才认为是语句结束。注意，使用完之后，我们还应该记得把它给修改回来。</p>
</blockquote>
<p>在 MySQL 5.7.2 版之前，可以为每个表定义最多六个触发器。</p>
<ul>
<li><code>BEFORE INSERT</code> - 在将数据插入表格之前激活。</li>
<li><code>AFTER INSERT</code> - 将数据插入表格后激活。</li>
<li><code>BEFORE UPDATE</code> - 在更新表中的数据之前激活。</li>
<li><code>AFTER UPDATE</code> - 更新表中的数据后激活。</li>
<li><code>BEFORE DELETE</code> - 在从表中删除数据之前激活。</li>
<li><code>AFTER DELETE</code> - 从表中删除数据后激活。</li>
</ul>
<p>但是，从 MySQL 版本 5.7.2+开始，可以为同一触发事件和操作时间定义多个触发器。</p>
<p>**<code>NEW</code> 和 <code>OLD</code>**：</p>
<ul>
<li>MySQL 中定义了 <code>NEW</code> 和 <code>OLD</code> 关键字，用来表示触发器的所在表中，触发了触发器的那一行数据。</li>
<li>在 <code>INSERT</code> 型触发器中，<code>NEW</code> 用来表示将要（<code>BEFORE</code>）或已经（<code>AFTER</code>）插入的新数据；</li>
<li>在 <code>UPDATE</code> 型触发器中，<code>OLD</code> 用来表示将要或已经被修改的原数据，<code>NEW</code> 用来表示将要或已经修改为的新数据；</li>
<li>在 <code>DELETE</code> 型触发器中，<code>OLD</code> 用来表示将要或已经被删除的原数据；</li>
<li>使用方法：<code>NEW.columnName</code> （columnName 为相应数据表某一列名）</li>
</ul>
<h3 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h3><blockquote>
<p>提示：为了理解触发器的要点，有必要先了解一下创建触发器的指令。</p>
</blockquote>
<p><code>CREATE TRIGGER</code> 指令用于创建触发器。</p>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trigger_name</span><br><span class="line">trigger_time</span><br><span class="line">trigger_event</span><br><span class="line"><span class="keyword">ON</span> table_name</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  trigger_statements</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li><code>trigger_name</code>：触发器名</li>
<li><code>trigger_time</code> : 触发器的触发时机。取值为 <code>BEFORE</code> 或 <code>AFTER</code>。</li>
<li><code>trigger_event</code> : 触发器的监听事件。取值为 <code>INSERT</code>、<code>UPDATE</code> 或 <code>DELETE</code>。</li>
<li><code>table_name</code> : 触发器的监听目标。指定在哪张表上建立触发器。</li>
<li><code>FOR EACH ROW</code>: 行级监视，Mysql 固定写法，其他 DBMS 不同。</li>
<li><code>trigger_statements</code>: 触发器执行动作。是一条或多条 SQL 语句的列表，列表内的每条语句都必须用分号 <code>;</code> 来结尾。</li>
</ul>
<p>当触发器的触发条件满足时，将会执行 <code>BEGIN</code> 和 <code>END</code> 之间的触发器执行动作。</p>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> `trigger_insert_user`</span><br><span class="line">AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> `<span class="keyword">user</span>`</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">INSERT INTO</span> `user_history`(user_id, operate_type, operate_time)</span><br><span class="line">    <span class="keyword">VALUES</span> (NEW.id, <span class="string">&#x27;add a user&#x27;</span>,  now());</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<h3 id="查看触发器"><a href="#查看触发器" class="headerlink" title="查看触发器"></a>查看触发器</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TRIGGERS;</span><br></pre></td></tr></table></figure>

<h3 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> IF <span class="keyword">EXISTS</span> trigger_insert_user;</span><br></pre></td></tr></table></figure>

<h2 id="文章推荐"><a href="#文章推荐" class="headerlink" title="文章推荐"></a>文章推荐</h2><ul>
<li><a href="https://mp.weixin.qq.com/s/I-ZT3zGTNBZ6egS7T09jyQ">后端程序员必备：SQL 高性能优化指南！35+条优化建议立马 GET!</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247486461&idx=1&sn=60a22279196d084cc398936fe3b37772&chksm=cea24436f9d5cd20a4fa0e907590f3e700d7378b3f608d7b33bb52cfb96f503b7ccb65a1deed&token=1987003517&lang=zh_CN#rd">后端程序员必备：书写高质量 SQL 的 30 条建议</a></li>
</ul>
<!-- @include: @article-footer.snippet.md -->

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2024/08/20/10-classical-sorting-algorithms/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/08/20/10-classical-sorting-algorithms/" itemprop="url">十大经典排序算法总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-08-20T19:43:57+08:00">
                2024-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2024/08/20/10-classical-sorting-algorithms/" class="leancloud_visitors" data-flag-title="十大经典排序算法总结">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  6.7k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  27 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本文转自：<a href="http://www.guoyaohua.com/sorting.html">http://www.guoyaohua.com/sorting.html</a>，对其做了补充完善。</p>
</blockquote>
<!-- markdownlint-disable MD024 -->

<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。排序算法，就是如何使得记录按照要求排列的方法。排序算法在很多领域得到相当地重视，尤其是在大量数据的处理方面。一个优秀的算法可以节省大量的资源。在各个领域中考虑到数据的各种限制和规范，要得到一个符合实际的优秀算法，得经过大量的推理和分析。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="排序算法总结"><a href="#排序算法总结" class="headerlink" title="排序算法总结"></a>排序算法总结</h3><p>常见的内部排序算法有：<strong>插入排序</strong>、<strong>希尔排序</strong>、<strong>选择排序</strong>、<strong>冒泡排序</strong>、<strong>归并排序</strong>、<strong>快速排序</strong>、<strong>堆排序</strong>、<strong>基数排序</strong>等，本文只讲解内部排序算法。用一张表格概括：</p>
<table>
<thead>
<tr>
<th>排序算法</th>
<th>时间复杂度（平均）</th>
<th>时间复杂度（最差）</th>
<th>时间复杂度（最好）</th>
<th>空间复杂度</th>
<th>排序方式</th>
<th>稳定性</th>
</tr>
</thead>
<tbody><tr>
<td>冒泡排序</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>内部排序</td>
<td>稳定</td>
</tr>
<tr>
<td>选择排序</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>内部排序</td>
<td>不稳定</td>
</tr>
<tr>
<td>插入排序</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>内部排序</td>
<td>稳定</td>
</tr>
<tr>
<td>希尔排序</td>
<td>O(nlogn)</td>
<td>O(n^2)</td>
<td>O(nlogn)</td>
<td>O(1)</td>
<td>内部排序</td>
<td>不稳定</td>
</tr>
<tr>
<td>归并排序</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(n)</td>
<td>外部排序</td>
<td>稳定</td>
</tr>
<tr>
<td>快速排序</td>
<td>O(nlogn)</td>
<td>O(n^2)</td>
<td>O(nlogn)</td>
<td>O(logn)</td>
<td>内部排序</td>
<td>不稳定</td>
</tr>
<tr>
<td>堆排序</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(1)</td>
<td>内部排序</td>
<td>不稳定</td>
</tr>
<tr>
<td>计数排序</td>
<td>O(n+k)</td>
<td>O(n+k)</td>
<td>O(n+k)</td>
<td>O(k)</td>
<td>外部排序</td>
<td>稳定</td>
</tr>
<tr>
<td>桶排序</td>
<td>O(n+k)</td>
<td>O(n^2)</td>
<td>O(n+k)</td>
<td>O(n+k)</td>
<td>外部排序</td>
<td>稳定</td>
</tr>
<tr>
<td>基数排序</td>
<td>O(n×k)</td>
<td>O(n×k)</td>
<td>O(n×k)</td>
<td>O(n+k)</td>
<td>外部排序</td>
<td>稳定</td>
</tr>
</tbody></table>
<p><strong>术语解释</strong>：</p>
<ul>
<li><strong>n</strong>：数据规模，表示待排序的数据量大小。</li>
<li><strong>k</strong>：“桶” 的个数，在某些特定的排序算法中（如基数排序、桶排序等），表示分割成的独立的排序区间或类别的数量。</li>
<li><strong>内部排序</strong>：所有排序操作都在内存中完成，不需要额外的磁盘或其他存储设备的辅助。这适用于数据量小到足以完全加载到内存中的情况。</li>
<li><strong>外部排序</strong>：当数据量过大，不可能全部加载到内存中时使用。外部排序通常涉及到数据的分区处理，部分数据被暂时存储在外部磁盘等存储设备上。</li>
<li><strong>稳定</strong>：如果 A 原本在 B 前面，而 $A&#x3D;B$，排序之后 A 仍然在 B 的前面。</li>
<li><strong>不稳定</strong>：如果 A 原本在 B 的前面，而 $A&#x3D;B$，排序之后 A 可能会出现在 B 的后面。</li>
<li><strong>时间复杂度</strong>：定性描述一个算法执行所耗费的时间。</li>
<li><strong>空间复杂度</strong>：定性描述一个算法执行所需内存的大小。</li>
</ul>
<h3 id="排序算法分类"><a href="#排序算法分类" class="headerlink" title="排序算法分类"></a>排序算法分类</h3><p>十种常见排序算法可以分类两大类别：<strong>比较类排序</strong>和<strong>非比较类排序</strong>。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/sorting-algorithms/sort2.png" alt="排序算法分类"></p>
<p>常见的<strong>快速排序</strong>、<strong>归并排序</strong>、<strong>堆排序</strong>以及<strong>冒泡排序</strong>等都属于<strong>比较类排序算法</strong>。比较类排序是通过比较来决定元素间的相对次序，由于其时间复杂度不能突破 <code>O(nlogn)</code>，因此也称为非线性时间比较类排序。在冒泡排序之类的排序中，问题规模为 <code>n</code>，又因为需要比较 <code>n</code> 次，所以平均时间复杂度为 <code>O(n²)</code>。在<strong>归并排序</strong>、<strong>快速排序</strong>之类的排序中，问题规模通过<strong>分治法</strong>消减为 <code>logn</code> 次，所以时间复杂度平均 <code>O(nlogn)</code>。</p>
<p>比较类排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，比较排序适用于一切需要排序的情况。</p>
<p>而<strong>计数排序</strong>、<strong>基数排序</strong>、<strong>桶排序</strong>则属于<strong>非比较类排序算法</strong>。非比较排序不通过比较来决定元素间的相对次序，而是通过确定每个元素之前，应该有多少个元素来排序。由于它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。 非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度 $O(n)$。</p>
<p>非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。</p>
<h2 id="冒泡排序-Bubble-Sort"><a href="#冒泡排序-Bubble-Sort" class="headerlink" title="冒泡排序 (Bubble Sort)"></a>冒泡排序 (Bubble Sort)</h2><p>冒泡排序是一种简单的排序算法。它重复地遍历要排序的序列，依次比较两个元素，如果它们的顺序错误就把它们交换过来。遍历序列的工作是重复地进行直到没有再需要交换为止，此时说明该序列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢 “浮” 到数列的顶端。</p>
<h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li>
<li>针对所有的元素重复以上的步骤，除了最后一个；</li>
<li>重复步骤 1~3，直到排序完成。</li>
</ol>
<h3 id="图解算法"><a href="#图解算法" class="headerlink" title="图解算法"></a>图解算法</h3><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/sorting-algorithms/bubble_sort.gif" alt="冒泡排序"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冒泡排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> arr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] bubbleSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">// Set a flag, if true, that means the loop has not been swapped,</span></span><br><span class="line">        <span class="comment">// that is, the sequence has been ordered, the sorting has been completed.</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = tmp;</span><br><span class="line">       <span class="comment">// Change flag</span></span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>此处对代码做了一个小优化，加入了 <code>is_sorted</code> Flag，目的是将算法的最佳时间复杂度优化为 <code>O(n)</code>，即当原输入序列就是排序好的情况下，该算法的时间复杂度就是 <code>O(n)</code>。</strong></p>
<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>稳定性</strong>：稳定</li>
<li><strong>时间复杂度</strong>：最佳：$O(n)$ ，最差：$O(n^2)$， 平均：$O(n^2)$</li>
<li><strong>空间复杂度</strong>：$O(1)$</li>
<li><strong>排序方式</strong>：In-place</li>
</ul>
<h2 id="选择排序-Selection-Sort"><a href="#选择排序-Selection-Sort" class="headerlink" title="选择排序 (Selection Sort)"></a>选择排序 (Selection Sort)</h2><p>选择排序是一种简单直观的排序算法，无论什么数据进去都是 $O(n^2)$ 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<h3 id="算法步骤-1"><a href="#算法步骤-1" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol>
<li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li>
<li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li>
<li>重复第 2 步，直到所有元素均排序完毕。</li>
</ol>
<h3 id="图解算法-1"><a href="#图解算法-1" class="headerlink" title="图解算法"></a>图解算法</h3><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/sorting-algorithms/selection_sort.gif" alt="Selection Sort"></p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选择排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> arr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] selectionSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (minIndex != i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            arr[i] = arr[minIndex];</span><br><span class="line">            arr[minIndex] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>稳定性</strong>：不稳定</li>
<li><strong>时间复杂度</strong>：最佳：$O(n^2)$ ，最差：$O(n^2)$， 平均：$O(n^2)$</li>
<li><strong>空间复杂度</strong>：$O(1)$</li>
<li><strong>排序方式</strong>：In-place</li>
</ul>
<h2 id="插入排序-Insertion-Sort"><a href="#插入排序-Insertion-Sort" class="headerlink" title="插入排序 (Insertion Sort)"></a>插入排序 (Insertion Sort)</h2><p>插入排序是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用 in-place 排序（即只需用到 $O(1)$ 的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>
<p>插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<p>插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。</p>
<h3 id="算法步骤-2"><a href="#算法步骤-2" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol>
<li>从第一个元素开始，该元素可以认为已经被排序；</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>
<li>重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置；</li>
<li>将新元素插入到该位置后；</li>
<li>重复步骤 2~5。</li>
</ol>
<h3 id="图解算法-2"><a href="#图解算法-2" class="headerlink" title="图解算法"></a>图解算法</h3><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/sorting-algorithms/insertion_sort.gif" alt="insertion_sort"></p>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> arr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] insertionSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">preIndex</span> <span class="operator">=</span> i - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        <span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;&amp; current &lt; arr[preIndex]) &#123;</span><br><span class="line">            arr[preIndex + <span class="number">1</span>] = arr[preIndex];</span><br><span class="line">            preIndex -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[preIndex + <span class="number">1</span>] = current;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>稳定性</strong>：稳定</li>
<li><strong>时间复杂度</strong>：最佳：$O(n)$ ，最差：$O(n^2)$， 平均：$O(n2)$</li>
<li><strong>空间复杂度</strong>：O(1)$</li>
<li><strong>排序方式</strong>：In-place</li>
</ul>
<h2 id="希尔排序-Shell-Sort"><a href="#希尔排序-Shell-Sort" class="headerlink" title="希尔排序 (Shell Sort)"></a>希尔排序 (Shell Sort)</h2><p>希尔排序是希尔 (Donald Shell) 于 1959 年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为递减增量排序算法，同时该算法是冲破 $O(n^2)$ 的第一批算法之一。</p>
<p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录 “基本有序” 时，再对全体记录进行依次直接插入排序。</p>
<h3 id="算法步骤-3"><a href="#算法步骤-3" class="headerlink" title="算法步骤"></a>算法步骤</h3><p>我们来看下希尔排序的基本步骤，在此我们选择增量 $gap&#x3D;length&#x2F;2$，缩小增量继续以 $gap &#x3D; gap&#x2F;2$ 的方式，这种增量选择我们可以用一个序列来表示，$\lbrace \frac{n}{2}, \frac{(n&#x2F;2)}{2}, \dots, 1 \rbrace$，称为<strong>增量序列</strong>。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。</p>
<p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p>
<ul>
<li>选择一个增量序列 $\lbrace t_1, t_2, \dots, t_k \rbrace$，其中 $t_i \gt t_j, i \lt j, t_k &#x3D; 1$；</li>
<li>按增量序列个数 k，对序列进行 k 趟排序；</li>
<li>每趟排序，根据对应的增量 $t$，将待排序列分割成若干长度为 $m$ 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>
</ul>
<h3 id="图解算法-3"><a href="#图解算法-3" class="headerlink" title="图解算法"></a>图解算法</h3><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/sorting-algorithms/shell_sort.png" alt="shell_sort"></p>
<h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 希尔排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> arr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] shellSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> n / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (gap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">preIndex</span> <span class="operator">=</span> i - gap;</span><br><span class="line">            <span class="comment">// Insertion sort</span></span><br><span class="line">            <span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;&amp; arr[preIndex] &gt; current) &#123;</span><br><span class="line">                arr[preIndex + gap] = arr[preIndex];</span><br><span class="line">                preIndex -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[preIndex + gap] = current;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        gap /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-3"><a href="#算法分析-3" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>稳定性</strong>：不稳定</li>
<li><strong>时间复杂度</strong>：最佳：$O(nlogn)$， 最差：$O(n^2)$ 平均：$O(nlogn)$</li>
<li><strong>空间复杂度</strong>：$O(1)$</li>
</ul>
<h2 id="归并排序-Merge-Sort"><a href="#归并排序-Merge-Sort" class="headerlink" title="归并排序 (Merge Sort)"></a>归并排序 (Merge Sort)</h2><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法 (Divide and Conquer) 的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为 2 - 路归并。</p>
<p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 $O(nlogn)$ 的时间复杂度。代价是需要额外的内存空间。</p>
<h3 id="算法步骤-4"><a href="#算法步骤-4" class="headerlink" title="算法步骤"></a>算法步骤</h3><p>归并排序算法是一个递归过程，边界条件为当输入序列仅有一个元素时，直接返回，具体过程如下：</p>
<ol>
<li>如果输入内只有一个元素，则直接返回，否则将长度为 $n$ 的输入序列分成两个长度为 $n&#x2F;2$ 的子序列；</li>
<li>分别对这两个子序列进行归并排序，使子序列变为有序状态；</li>
<li>设定两个指针，分别指向两个已经排序子序列的起始位置；</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间（用于存放排序结果），并移动指针到下一位置；</li>
<li>重复步骤 3 ~ 4 直到某一指针达到序列尾；</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾。</li>
</ol>
<h3 id="图解算法-4"><a href="#图解算法-4" class="headerlink" title="图解算法"></a>图解算法</h3><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/sorting-algorithms/merge_sort.gif" alt="MergeSort"></p>
<h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> arr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] mergeSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> arr.length / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span>[] arr_1 = Arrays.copyOfRange(arr, <span class="number">0</span>, middle);</span><br><span class="line">    <span class="type">int</span>[] arr_2 = Arrays.copyOfRange(arr, middle, arr.length);</span><br><span class="line">    <span class="keyword">return</span> merge(mergeSort(arr_1), mergeSort(arr_2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Merge two sorted arrays</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr_1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr_2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> sorted_arr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] merge(<span class="type">int</span>[] arr_1, <span class="type">int</span>[] arr_2) &#123;</span><br><span class="line">    <span class="type">int</span>[] sorted_arr = <span class="keyword">new</span> <span class="title class_">int</span>[arr_1.length + arr_2.length];</span><br><span class="line">    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>, idx_1 = <span class="number">0</span>, idx_2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (idx_1 &lt; arr_1.length &amp;&amp; idx_2 &lt; arr_2.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr_1[idx_1] &lt; arr_2[idx_2]) &#123;</span><br><span class="line">            sorted_arr[idx] = arr_1[idx_1];</span><br><span class="line">            idx_1 += <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sorted_arr[idx] = arr_2[idx_2];</span><br><span class="line">            idx_2 += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        idx += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (idx_1 &lt; arr_1.length) &#123;</span><br><span class="line">        <span class="keyword">while</span> (idx_1 &lt; arr_1.length) &#123;</span><br><span class="line">            sorted_arr[idx] = arr_1[idx_1];</span><br><span class="line">            idx_1 += <span class="number">1</span>;</span><br><span class="line">            idx += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (idx_2 &lt; arr_2.length) &#123;</span><br><span class="line">            sorted_arr[idx] = arr_2[idx_2];</span><br><span class="line">            idx_2 += <span class="number">1</span>;</span><br><span class="line">            idx += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sorted_arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-4"><a href="#算法分析-4" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>稳定性</strong>：稳定</li>
<li><strong>时间复杂度</strong>：最佳：$O(nlogn)$， 最差：$O(nlogn)$， 平均：$O(nlogn)$</li>
<li><strong>空间复杂度</strong>：$O(n)$</li>
</ul>
<h2 id="快速排序-Quick-Sort"><a href="#快速排序-Quick-Sort" class="headerlink" title="快速排序 (Quick Sort)"></a>快速排序 (Quick Sort)</h2><p>快速排序用到了分治思想，同样的还有归并排序。乍看起来快速排序和归并排序非常相似，都是将问题变小，先排序子串，最后合并。不同的是快速排序在划分子问题的时候经过多一步处理，将划分的两组数据划分为一大一小，这样在最后合并的时候就不必像归并排序那样再进行比较。但也正因为如此，划分的不定性使得快速排序的时间复杂度并不稳定。</p>
<p>快速排序的基本思想：通过一趟排序将待排序列分隔成独立的两部分，其中一部分记录的元素均比另一部分的元素小，则可分别对这两部分子序列继续进行排序，以达到整个序列有序。</p>
<h3 id="算法步骤-5"><a href="#算法步骤-5" class="headerlink" title="算法步骤"></a>算法步骤</h3><p>快速排序使用<a href="https://zh.wikipedia.org/wiki/%E5%88%86%E6%B2%BB%E6%B3%95">分治法</a>（Divide and conquer）策略来把一个序列分为较小和较大的 2 个子序列，然后递归地排序两个子序列。具体算法描述如下：</p>
<ol>
<li>从序列中<strong>随机</strong>挑出一个元素，做为 “基准”(<code>pivot</code>)；</li>
<li>重新排列序列，将所有比基准值小的元素摆放在基准前面，所有比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个操作结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
<li>递归地把小于基准值元素的子序列和大于基准值元素的子序列进行快速排序。</li>
</ol>
<h3 id="图解算法-5"><a href="#图解算法-5" class="headerlink" title="图解算法"></a>图解算法</h3><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/sorting-algorithms/random_quick_sort.gif" alt="RandomQuickSort"></p>
<h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3><blockquote>
<p>来源：<a href="https://segmentfault.com/a/1190000040022056">使用 Java 实现快速排序（详解）</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> array[high];</span><br><span class="line">    <span class="type">int</span> <span class="variable">pointer</span> <span class="operator">=</span> low;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> low; i &lt; high; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[i] &lt;= pivot) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array[i];</span><br><span class="line">            array[i] = array[pointer];</span><br><span class="line">            array[pointer] = temp;</span><br><span class="line">            pointer++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array[pointer];</span><br><span class="line">    array[pointer] = array[high];</span><br><span class="line">    array[high] = temp;</span><br><span class="line">    <span class="keyword">return</span> pointer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> partition(array, low, high);</span><br><span class="line">        quickSort(array, low, position - <span class="number">1</span>);</span><br><span class="line">        quickSort(array, position + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-5"><a href="#算法分析-5" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>稳定性</strong>：不稳定</li>
<li><strong>时间复杂度</strong>：最佳：$O(nlogn)$， 最差：$O(n^2)$，平均：$O(nlogn)$</li>
<li><strong>空间复杂度</strong>：$O(logn)$</li>
</ul>
<h2 id="堆排序-Heap-Sort"><a href="#堆排序-Heap-Sort" class="headerlink" title="堆排序 (Heap Sort)"></a>堆排序 (Heap Sort)</h2><p>堆排序是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足<strong>堆的性质</strong>：即<strong>子结点的值总是小于（或者大于）它的父节点</strong>。</p>
<h3 id="算法步骤-6"><a href="#算法步骤-6" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol>
<li>将初始待排序列 $(R_1, R_2, \dots, R_n)$ 构建成大顶堆，此堆为初始的无序区；</li>
<li>将堆顶元素 $R_1$ 与最后一个元素 $R_n$ 交换，此时得到新的无序区 $(R_1, R_2, \dots, R_{n-1})$ 和新的有序区 $R_n$, 且满足 $R_i \leqslant R_n (i \in 1, 2,\dots, n-1)$；</li>
<li>由于交换后新的堆顶 $R_1$ 可能违反堆的性质，因此需要对当前无序区 $(R_1, R_2, \dots, R_{n-1})$ 调整为新堆，然后再次将 $R_1$ 与无序区最后一个元素交换，得到新的无序区 $(R_1, R_2, \dots, R_{n-2})$ 和新的有序区 $(R_{n-1}, R_n)$。不断重复此过程直到有序区的元素个数为 $n-1$，则整个排序过程完成。</li>
</ol>
<h3 id="图解算法-6"><a href="#图解算法-6" class="headerlink" title="图解算法"></a>图解算法</h3><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/sorting-algorithms/heap_sort.gif" alt="HeapSort"></p>
<h3 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Global variable that records the length of an array;</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> heapLen;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Swap the two elements of an array</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Build Max Heap</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">buildMaxHeap</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        heapify(arr, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adjust it to the maximum heap</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">largest</span> <span class="operator">=</span> i;</span><br><span class="line">    <span class="keyword">if</span> (right &lt; heapLen &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; heapLen &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">        swap(arr, largest, i);</span><br><span class="line">        heapify(arr, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Heap Sort</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] heapSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="comment">// index at the end of the heap</span></span><br><span class="line">    heapLen = arr.length;</span><br><span class="line">    <span class="comment">// build MaxHeap</span></span><br><span class="line">    buildMaxHeap(arr);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// Move the top of the heap to the tail of the heap in turn</span></span><br><span class="line">        swap(arr, <span class="number">0</span>, i);</span><br><span class="line">        heapLen -= <span class="number">1</span>;</span><br><span class="line">        heapify(arr, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-6"><a href="#算法分析-6" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>稳定性</strong>：不稳定</li>
<li><strong>时间复杂度</strong>：最佳：$O(nlogn)$， 最差：$O(nlogn)$， 平均：$O(nlogn)$</li>
<li><strong>空间复杂度</strong>：$O(1)$</li>
</ul>
<h2 id="计数排序-Counting-Sort"><a href="#计数排序-Counting-Sort" class="headerlink" title="计数排序 (Counting Sort)"></a>计数排序 (Counting Sort)</h2><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，<strong>计数排序要求输入的数据必须是有确定范围的整数</strong>。</p>
<p>计数排序 (Counting sort) 是一种稳定的排序算法。计数排序使用一个额外的数组 <code>C</code>，其中第 <code>i</code> 个元素是待排序数组 <code>A</code> 中值等于 <code>i</code> 的元素的个数。然后根据数组 <code>C</code> 来将 <code>A</code> 中的元素排到正确的位置。<strong>它只能对整数进行排序</strong>。</p>
<h3 id="算法步骤-7"><a href="#算法步骤-7" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol>
<li>找出数组中的最大值 <code>max</code>、最小值 <code>min</code>；</li>
<li>创建一个新数组 <code>C</code>，其长度是 <code>max-min+1</code>，其元素默认值都为 0；</li>
<li>遍历原数组 <code>A</code> 中的元素 <code>A[i]</code>，以 <code>A[i] - min</code> 作为 <code>C</code> 数组的索引，以 <code>A[i]</code> 的值在 <code>A</code> 中元素出现次数作为 <code>C[A[i] - min]</code> 的值；</li>
<li>对 <code>C</code> 数组变形，<strong>新元素的值是该元素与前一个元素值的和</strong>，即当 <code>i&gt;1</code> 时 <code>C[i] = C[i] + C[i-1]</code>；</li>
<li>创建结果数组 <code>R</code>，长度和原始数组一样。</li>
<li><strong>从后向前</strong>遍历原始数组 <code>A</code> 中的元素 <code>A[i]</code>，使用 <code>A[i]</code> 减去最小值 <code>min</code> 作为索引，在计数数组 <code>C</code> 中找到对应的值 <code>C[A[i] - min]</code>，<code>C[A[i] - min] - 1</code> 就是 <code>A[i]</code> 在结果数组 <code>R</code> 中的位置，做完上述这些操作，将 <code>count[A[i] - min]</code> 减小 1。</li>
</ol>
<h3 id="图解算法-7"><a href="#图解算法-7" class="headerlink" title="图解算法"></a>图解算法</h3><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/sorting-algorithms/counting_sort.gif" alt="CountingSort"></p>
<h3 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Gets the maximum and minimum values in the array</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] getMinAndMax(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">minValue</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; maxValue) &#123;</span><br><span class="line">            maxValue = arr[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &lt; minValue) &#123;</span><br><span class="line">            minValue = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; minValue, maxValue &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Counting Sort</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] countingSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] extremum = getMinAndMax(arr);</span><br><span class="line">    <span class="type">int</span> <span class="variable">minValue</span> <span class="operator">=</span> extremum[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> extremum[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span>[] countArr = <span class="keyword">new</span> <span class="title class_">int</span>[maxValue - minValue + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        countArr[arr[i] - minValue] += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; countArr.length; i++) &#123;</span><br><span class="line">        countArr[i] += countArr[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> countArr[arr[i] - minValue] - <span class="number">1</span>;</span><br><span class="line">        result[idx] = arr[i];</span><br><span class="line">        countArr[arr[i] - minValue] -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-7"><a href="#算法分析-7" class="headerlink" title="算法分析"></a>算法分析</h3><p>当输入的元素是 <code>n</code> 个 <code>0</code> 到 <code>k</code> 之间的整数时，它的运行时间是 $O(n+k)$。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组 <code>C</code> 的长度取决于待排序数组中数据的范围（等于待排序数组的<strong>最大值与最小值的差加上 1</strong>），这使得计数排序对于数据范围很大的数组，需要大量额外内存空间。</p>
<ul>
<li><strong>稳定性</strong>：稳定</li>
<li><strong>时间复杂度</strong>：最佳：$O(n+k)$ 最差：$O(n+k)$ 平均：$O(n+k)$</li>
<li><strong>空间复杂度</strong>：$O(k)$</li>
</ul>
<h2 id="桶排序-Bucket-Sort"><a href="#桶排序-Bucket-Sort" class="headerlink" title="桶排序 (Bucket Sort)"></a>桶排序 (Bucket Sort)</h2><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：</p>
<ol>
<li>在额外空间充足的情况下，尽量增大桶的数量</li>
<li>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中</li>
</ol>
<p>桶排序的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行。</p>
<h3 id="算法步骤-8"><a href="#算法步骤-8" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol>
<li>设置一个 BucketSize，作为每个桶所能放置多少个不同数值；</li>
<li>遍历输入数据，并且把数据依次映射到对应的桶里去；</li>
<li>对每个非空的桶进行排序，可以使用其它排序方法，也可以递归使用桶排序；</li>
<li>从非空桶里把排好序的数据拼接起来。</li>
</ol>
<h3 id="图解算法-8"><a href="#图解算法-8" class="headerlink" title="图解算法"></a>图解算法</h3><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/sorting-algorithms/bucket_sort.gif" alt="BucketSort"></p>
<h3 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Gets the maximum and minimum values in the array</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] getMinAndMax(List&lt;Integer&gt; arr) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> arr.get(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">minValue</span> <span class="operator">=</span> arr.get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; maxValue) &#123;</span><br><span class="line">            maxValue = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; minValue) &#123;</span><br><span class="line">            minValue = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; minValue, maxValue &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Bucket Sort</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">bucketSort</span><span class="params">(List&lt;Integer&gt; arr, <span class="type">int</span> bucket_size)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.size() &lt; <span class="number">2</span> || bucket_size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] extremum = getMinAndMax(arr);</span><br><span class="line">    <span class="type">int</span> <span class="variable">minValue</span> <span class="operator">=</span> extremum[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> extremum[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">bucket_cnt</span> <span class="operator">=</span> (maxValue - minValue) / bucket_size + <span class="number">1</span>;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; buckets = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bucket_cnt; i++) &#123;</span><br><span class="line">        buckets.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> element : arr) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> (element - minValue) / bucket_size;</span><br><span class="line">        buckets.get(idx).add(element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; buckets.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (buckets.get(i).size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            buckets.set(i, sort(buckets.get(i), bucket_size / <span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (List&lt;Integer&gt; bucket : buckets) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> element : bucket) &#123;</span><br><span class="line">            result.add(element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-8"><a href="#算法分析-8" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>稳定性</strong>：稳定</li>
<li><strong>时间复杂度</strong>：最佳：$O(n+k)$ 最差：$O(n^2)$ 平均：$O(n+k)$</li>
<li><strong>空间复杂度</strong>：$O(n+k)$</li>
</ul>
<h2 id="基数排序-Radix-Sort"><a href="#基数排序-Radix-Sort" class="headerlink" title="基数排序 (Radix Sort)"></a>基数排序 (Radix Sort)</h2><p>基数排序也是非比较的排序算法，对元素中的每一位数字进行排序，从最低位开始排序，复杂度为 $O(n×k)$，$n$ 为数组长度，$k$ 为数组中元素的最大的位数；</p>
<p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。</p>
<h3 id="算法步骤-9"><a href="#算法步骤-9" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol>
<li>取得数组中的最大数，并取得位数，即为迭代次数 $N$（例如：数组中最大数值为 1000，则 $N&#x3D;4$）；</li>
<li><code>A</code> 为原始数组，从最低位开始取每个位组成 <code>radix</code> 数组；</li>
<li>对 <code>radix</code> 进行计数排序（利用计数排序适用于小范围数的特点）；</li>
<li>将 <code>radix</code> 依次赋值给原数组；</li>
<li>重复 2~4 步骤 $N$ 次</li>
</ol>
<h3 id="图解算法-9"><a href="#图解算法-9" class="headerlink" title="图解算法"></a>图解算法</h3><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/sorting-algorithms/radix_sort.gif" alt="RadixSort"></p>
<h3 id="代码实现-9"><a href="#代码实现-9" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Radix Sort</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] radixSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> element : arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (element &gt; maxValue) &#123;</span><br><span class="line">            maxValue = element;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (maxValue / <span class="number">10</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        maxValue = maxValue / <span class="number">10</span>;</span><br><span class="line">        N += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; radix = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">10</span>; k++) &#123;</span><br><span class="line">            radix.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> element : arr) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> (element / (<span class="type">int</span>) Math.pow(<span class="number">10</span>, i)) % <span class="number">10</span>;</span><br><span class="line">            radix.get(idx).add(element);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; l : radix) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> n : l) &#123;</span><br><span class="line">                arr[idx++] = n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-9"><a href="#算法分析-9" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>稳定性</strong>：稳定</li>
<li><strong>时间复杂度</strong>：最佳：$O(n×k)$ 最差：$O(n×k)$ 平均：$O(n×k)$</li>
<li><strong>空间复杂度</strong>：$O(n+k)$</li>
</ul>
<p><strong>基数排序 vs 计数排序 vs 桶排序</strong></p>
<p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p>
<ul>
<li>基数排序：根据键值的每位数字来分配桶</li>
<li>计数排序：每个桶只存储单一键值</li>
<li>桶排序：每个桶存储一定范围的数值</li>
</ul>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://www.cnblogs.com/guoyaohua/p/8600214.html">https://www.cnblogs.com/guoyaohua/p/8600214.html</a></li>
<li><a href="https://en.wikipedia.org/wiki/Sorting_algorithm">https://en.wikipedia.org/wiki/Sorting_algorithm</a></li>
<li><a href="https://sort.hust.cc/">https://sort.hust.cc/</a></li>
</ul>
<!-- @include: @article-footer.snippet.md -->

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2024/08/09/redis-questions-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/08/09/redis-questions-01/" itemprop="url">Redis常见面试题总结(上)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-08-09T18:43:28+08:00">
                2024-08-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/redis/" itemprop="url" rel="index">
                    <span itemprop="name">redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2024/08/09/redis-questions-01/" class="leancloud_visitors" data-flag-title="Redis常见面试题总结(上)">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  13.3k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  49 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <!-- @include: @small-advertisement.snippet.md -->

<h2 id="Redis-基础"><a href="#Redis-基础" class="headerlink" title="Redis 基础"></a>Redis 基础</h2><h3 id="什么是-Redis？"><a href="#什么是-Redis？" class="headerlink" title="什么是 Redis？"></a>什么是 Redis？</h3><p><a href="https://redis.io/">Redis</a> （<strong>RE</strong>mote <strong>DI</strong>ctionary <strong>S</strong>erver）是一个基于 C 语言开发的开源 NoSQL 数据库（BSD 许可）。与传统数据库不同的是，Redis 的数据是保存在内存中的（内存数据库，支持持久化），因此读写速度非常快，被广泛应用于分布式缓存方向。并且，Redis 存储的是 KV 键值对数据。</p>
<p>为了满足不同的业务场景，Redis 内置了多种数据类型实现（比如 String、Hash、Sorted Set、Bitmap、HyperLogLog、GEO）。并且，Redis 还支持事务、持久化、Lua 脚本、发布订阅模型、多种开箱即用的集群方案（Redis Sentinel、Redis Cluster）。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/redis-overview-of-data-types-2023-09-28.jpg" alt="Redis 数据类型概览"></p>
<p>Redis 没有外部依赖，Linux 和 OS X 是 Redis 开发和测试最多的两个操作系统，官方推荐生产环境使用 Linux 部署 Redis。</p>
<p>个人学习的话，你可以自己本机安装 Redis 或者通过 Redis 官网提供的<a href="https://try.redis.io/">在线 Redis 环境</a>（少部分命令无法使用）来实际体验 Redis。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/try.redis.io.png" alt="try-redis"></p>
<p>全世界有非常多的网站使用到了 Redis ，<a href="https://techstacks.io/">techstacks.io</a> 专门维护了一个<a href="https://techstacks.io/tech/redis">使用 Redis 的热门站点列表</a> ，感兴趣的话可以看看。</p>
<h3 id="Redis-为什么这么快？"><a href="#Redis-为什么这么快？" class="headerlink" title="Redis 为什么这么快？"></a>Redis 为什么这么快？</h3><p>Redis 内部做了非常多的性能优化，比较重要的有下面 3 点：</p>
<ol>
<li>Redis 基于内存，内存的访问速度比磁盘快很多；</li>
<li>Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型，主要是单线程事件循环和 IO 多路复用（Redis 线程模式后面会详细介绍到）；</li>
<li>Redis 内置了多种优化过后的数据类型&#x2F;结构实现，性能非常高。</li>
<li>Redis 通信协议实现简单且解析高效。</li>
</ol>
<blockquote>
<p>下面这张图片总结的挺不错的，分享一下，出自 <a href="https://twitter.com/alexxubyte/status/1498703822528544770">Why is Redis so fast?</a> 。</p>
</blockquote>
<p><img src="/./images/why-redis-so-fast.png" alt="why-redis-so-fast"></p>
<p>那既然都这么快了，为什么不直接用 Redis 当主数据库呢？主要是因为内存成本太高且 Redis 提供的数据持久化仍然有数据丢失的风险。</p>
<h3 id="除了-Redis，你还知道其他分布式缓存方案吗？"><a href="#除了-Redis，你还知道其他分布式缓存方案吗？" class="headerlink" title="除了 Redis，你还知道其他分布式缓存方案吗？"></a>除了 Redis，你还知道其他分布式缓存方案吗？</h3><p>如果面试中被问到这个问题的话，面试官主要想看看：</p>
<ol>
<li>你在选择 Redis 作为分布式缓存方案时，是否是经过严谨的调研和思考，还是只是因为 Redis 是当前的“热门”技术。</li>
<li>你在分布式缓存方向的技术广度。</li>
</ol>
<p>如果你了解其他方案，并且能解释为什么最终选择了 Redis（更进一步！），这会对你面试表现加分不少！</p>
<p>下面简单聊聊常见的分布式缓存技术选型。</p>
<p>分布式缓存的话，比较老牌同时也是使用的比较多的还是 <strong>Memcached</strong> 和 <strong>Redis</strong>。不过，现在基本没有看过还有项目使用 <strong>Memcached</strong> 来做缓存，都是直接用 <strong>Redis</strong>。</p>
<p>Memcached 是分布式缓存最开始兴起的那会，比较常用的。后来，随着 Redis 的发展，大家慢慢都转而使用更加强大的 Redis 了。</p>
<p>有一些大厂也开源了类似于 Redis 的分布式高性能 KV 存储数据库，例如，腾讯开源的 <a href="https://github.com/Tencent/Tendis"><strong>Tendis</strong></a> 。Tendis 基于知名开源项目 <a href="https://github.com/facebook/rocksdb">RocksDB</a> 作为存储引擎 ，100% 兼容 Redis 协议和 Redis4.0 所有数据模型。关于 Redis 和 Tendis 的对比，腾讯官方曾经发过一篇文章：<a href="https://mp.weixin.qq.com/s/MeYkfOIdnU6LYlsGb24KjQ">Redis vs Tendis：冷热混合存储版架构揭秘</a> ，可以简单参考一下。</p>
<p>不过，从 Tendis 这个项目的 Github 提交记录可以看出，Tendis 开源版几乎已经没有被维护更新了，加上其关注度并不高，使用的公司也比较少。因此，不建议你使用 Tendis 来实现分布式缓存。</p>
<p>目前，比较业界认可的 Redis 替代品还是下面这两个开源分布式缓存（都是通过碰瓷 Redis 火的）：</p>
<ul>
<li><a href="https://github.com/dragonflydb/dragonfly">Dragonfly</a>：一种针对现代应用程序负荷需求而构建的内存数据库，完全兼容 Redis 和 Memcached 的 API，迁移时无需修改任何代码，号称全世界最快的内存数据库。</li>
<li><a href="https://github.com/Snapchat/KeyDB">KeyDB</a>： Redis 的一个高性能分支，专注于多线程、内存效率和高吞吐量。</li>
</ul>
<p>不过，个人还是建议分布式缓存首选 Redis ，毕竟经过这么多年的生考验，生态也这么优秀，资料也很全面！</p>
<p>PS：篇幅问题，我这并没有对上面提到的分布式缓存选型做详细介绍和对比，感兴趣的话，可以自行研究一下。</p>
<h3 id="说一下-Redis-和-Memcached-的区别和共同点"><a href="#说一下-Redis-和-Memcached-的区别和共同点" class="headerlink" title="说一下 Redis 和 Memcached 的区别和共同点"></a>说一下 Redis 和 Memcached 的区别和共同点</h3><p>现在公司一般都是用 Redis 来实现缓存，而且 Redis 自身也越来越强大了！不过，了解 Redis 和 Memcached 的区别和共同点，有助于我们在做相应的技术选型的时候，能够做到有理有据！</p>
<p><strong>共同点</strong>：</p>
<ol>
<li>都是基于内存的数据库，一般都用来当做缓存使用。</li>
<li>都有过期策略。</li>
<li>两者的性能都非常高。</li>
</ol>
<p><strong>区别</strong>：</p>
<ol>
<li><strong>数据类型</strong>：Redis 支持更丰富的数据类型（支持更复杂的应用场景）。Redis 不仅仅支持简单的 k&#x2F;v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。Memcached 只支持最简单的 k&#x2F;v 数据类型。</li>
<li><strong>数据持久化</strong>：Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用，而 Memcached 把数据全部存在内存之中。也就是说，Redis 有灾难恢复机制而 Memcached 没有。</li>
<li><strong>集群模式支持</strong>：Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 自 3.0 版本起是原生支持集群模式的。</li>
<li><strong>线程模型</strong>：Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。 （Redis 6.0 针对网络数据的读写引入了多线程）</li>
<li><strong>特性支持</strong>：Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持。并且，Redis 支持更多的编程语言。</li>
<li><strong>过期数据删除</strong>：Memcached 过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除。</li>
</ol>
<p>相信看了上面的对比之后，我们已经没有什么理由可以选择使用 Memcached 来作为自己项目的分布式缓存了。</p>
<h3 id="为什么要用-Redis？"><a href="#为什么要用-Redis？" class="headerlink" title="为什么要用 Redis？"></a>为什么要用 Redis？</h3><p><strong>1、访问速度更快</strong></p>
<p>传统数据库数据保存在磁盘，而 Redis 基于内存，内存的访问速度比磁盘快很多。引入 Redis 之后，我们可以把一些高频访问的数据放到 Redis 中，这样下次就可以直接从内存中读取，速度可以提升几十倍甚至上百倍。</p>
<p><strong>2、高并发</strong></p>
<p>一般像 MySQL 这类的数据库的 QPS 大概都在 4k 左右（4 核 8g） ，但是使用 Redis 缓存之后很容易达到 5w+，甚至能达到 10w+（就单机 Redis 的情况，Redis 集群的话会更高）。</p>
<blockquote>
<p>QPS（Query Per Second）：服务器每秒可以执行的查询次数；</p>
</blockquote>
<p>由此可见，直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。进而，我们也就提高了系统整体的并发。</p>
<p><strong>3、功能全面</strong></p>
<p>Redis 除了可以用作缓存之外，还可以用于分布式锁、限流、消息队列、延时队列等场景，功能强大！</p>
<h3 id="常见的缓存读写策略有哪些？"><a href="#常见的缓存读写策略有哪些？" class="headerlink" title="常见的缓存读写策略有哪些？"></a>常见的缓存读写策略有哪些？</h3><p>关于常见的缓存读写策略的详细介绍，可以看我写的这篇文章：<a href="https://javaguide.cn/database/redis/3-commonly-used-cache-read-and-write-strategies.html">3 种常用的缓存读写策略详解</a> 。</p>
<h3 id="什么是-Redis-Module？有什么用？"><a href="#什么是-Redis-Module？有什么用？" class="headerlink" title="什么是 Redis Module？有什么用？"></a>什么是 Redis Module？有什么用？</h3><p>Redis 从 4.0 版本开始，支持通过 Module 来扩展其功能以满足特殊的需求。这些 Module 以动态链接库（so 文件）的形式被加载到 Redis 中，这是一种非常灵活的动态扩展功能的实现方式，值得借鉴学习！</p>
<p>我们每个人都可以基于 Redis 去定制化开发自己的 Module，比如实现搜索引擎功能、自定义分布式锁和分布式限流。</p>
<p>目前，被 Redis 官方推荐的 Module 有：</p>
<ul>
<li><a href="https://github.com/RediSearch/RediSearch">RediSearch</a>：用于实现搜索引擎的模块。</li>
<li><a href="https://github.com/RedisJSON/RedisJSON">RedisJSON</a>：用于处理 JSON 数据的模块。</li>
<li><a href="https://github.com/RedisGraph/RedisGraph">RedisGraph</a>：用于实现图形数据库的模块。</li>
<li><a href="https://github.com/RedisTimeSeries/RedisTimeSeries">RedisTimeSeries</a>：用于处理时间序列数据的模块。</li>
<li><a href="https://github.com/RedisBloom/RedisBloom">RedisBloom</a>：用于实现布隆过滤器的模块。</li>
<li><a href="https://github.com/RedisAI/RedisAI">RedisAI</a>：用于执行深度学习&#x2F;机器学习模型并管理其数据的模块。</li>
<li><a href="https://github.com/brandur/redis-cell">RedisCell</a>：用于实现分布式限流的模块。</li>
<li>……</li>
</ul>
<p>关于 Redis 模块的详细介绍，可以查看官方文档：<a href="https://redis.io/modules">https://redis.io/modules</a>。</p>
<h2 id="Redis-应用"><a href="#Redis-应用" class="headerlink" title="Redis 应用"></a>Redis 应用</h2><h3 id="Redis-除了做缓存，还能做什么？"><a href="#Redis-除了做缓存，还能做什么？" class="headerlink" title="Redis 除了做缓存，还能做什么？"></a>Redis 除了做缓存，还能做什么？</h3><ul>
<li><strong>分布式锁</strong>：通过 Redis 来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于 Redisson 来实现分布式锁。关于 Redis 实现分布式锁的详细介绍，可以看我写的这篇文章：<a href="https://javaguide.cn/distributed-system/distributed-lock.html">分布式锁详解</a> 。</li>
<li><strong>限流</strong>：一般是通过 Redis + Lua 脚本的方式来实现限流。如果不想自己写 Lua 脚本的话，也可以直接利用 Redisson 中的 <code>RRateLimiter</code> 来实现分布式限流，其底层实现就是基于 Lua 代码+令牌桶算法。</li>
<li><strong>消息队列</strong>：Redis 自带的 List 数据结构可以作为一个简单的队列使用。Redis 5.0 中增加的 Stream 类型的数据结构更加适合用来做消息队列。它比较类似于 Kafka，有主题和消费组的概念，支持消息持久化以及 ACK 机制。</li>
<li><strong>延时队列</strong>：Redisson 内置了延时队列（基于 Sorted Set 实现的）。</li>
<li><strong>分布式 Session</strong> ：利用 String 或者 Hash 数据类型保存 Session 数据，所有的服务器都可以访问。</li>
<li><strong>复杂业务场景</strong>：通过 Redis 以及 Redis 扩展（比如 Redisson）提供的数据结构，我们可以很方便地完成很多复杂的业务场景比如通过 Bitmap 统计活跃用户、通过 Sorted Set 维护排行榜。</li>
<li>……</li>
</ul>
<h3 id="如何基于-Redis-实现分布式锁？"><a href="#如何基于-Redis-实现分布式锁？" class="headerlink" title="如何基于 Redis 实现分布式锁？"></a>如何基于 Redis 实现分布式锁？</h3><p>关于 Redis 实现分布式锁的详细介绍，可以看我写的这篇文章：<a href="https://javaguide.cn/distributed-system/distributed-lock-implementations.html">分布式锁详解</a> 。</p>
<h3 id="Redis-可以做消息队列么？"><a href="#Redis-可以做消息队列么？" class="headerlink" title="Redis 可以做消息队列么？"></a>Redis 可以做消息队列么？</h3><blockquote>
<p>实际项目中使用 Redis 来做消息队列的非常少，毕竟有更成熟的消息队列中间件可以用。</p>
</blockquote>
<p>先说结论：<strong>可以是可以，但不建议使用 Redis 来做消息队列。和专业的消息队列相比，还是有很多欠缺的地方。</strong></p>
<p><strong>Redis 2.0 之前，如果想要使用 Redis 来做消息队列的话，只能通过 List 来实现。</strong></p>
<p>通过 <code>RPUSH/LPOP</code> 或者 <code>LPUSH/RPOP</code>即可实现简易版消息队列：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生产者生产消息</span></span><br><span class="line">&gt; RPUSH myList msg1 msg2</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">&gt; RPUSH myList msg3</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"><span class="comment"># 消费者消费消息</span></span><br><span class="line">&gt; LPOP myList</span><br><span class="line"><span class="string">&quot;msg1&quot;</span></span><br></pre></td></tr></table></figure>

<p>不过，通过 <code>RPUSH/LPOP</code> 或者 <code>LPUSH/RPOP</code>这样的方式存在性能问题，我们需要不断轮询去调用 <code>RPOP</code> 或 <code>LPOP</code> 来消费消息。当 List 为空时，大部分的轮询的请求都是无效请求，这种方式大量浪费了系统资源。</p>
<p>因此，Redis 还提供了 <code>BLPOP</code>、<code>BRPOP</code> 这种阻塞式读取的命令（带 B-Blocking 的都是阻塞式），并且还支持一个超时参数。如果 List 为空，Redis 服务端不会立刻返回结果，它会等待 List 中有新数据后再返回或者是等待最多一个超时时间后返回空。如果将超时时间设置为 0 时，即可无限等待，直到弹出消息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 超时时间为 10s</span></span><br><span class="line"><span class="comment"># 如果有数据立刻返回，否则最多等待10秒</span></span><br><span class="line">&gt; BRPOP myList 10</span><br><span class="line">null</span><br></pre></td></tr></table></figure>

<p><strong>List 实现消息队列功能太简单，像消息确认机制等功能还需要我们自己实现，最要命的是没有广播机制，消息也只能被消费一次。</strong></p>
<p><strong>Redis 2.0 引入了发布订阅 (pub&#x2F;sub) 功能，解决了 List 实现消息队列没有广播机制的问题。</strong></p>
<p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/redis-pub-sub.png" alt="Redis 发布订阅 (pub/sub) 功能"></p>
<p>pub&#x2F;sub 中引入了一个概念叫 <strong>channel（频道）</strong>，发布订阅机制的实现就是基于这个 channel 来做的。</p>
<p>pub&#x2F;sub 涉及发布者（Publisher）和订阅者（Subscriber，也叫消费者）两个角色：</p>
<ul>
<li>发布者通过 <code>PUBLISH</code> 投递消息给指定 channel。</li>
<li>订阅者通过<code>SUBSCRIBE</code>订阅它关心的 channel。并且，订阅者可以订阅一个或者多个 channel。</li>
</ul>
<p>我们这里启动 3 个 Redis 客户端来简单演示一下：</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/redis-pubsub-message-queue.png" alt="pub/sub 实现消息队列演示"></p>
<p>pub&#x2F;sub 既能单播又能广播，还支持 channel 的简单正则匹配。不过，消息丢失（客户端断开连接或者 Redis 宕机都会导致消息丢失）、消息堆积（发布者发布消息的时候不会管消费者的具体消费能力如何）等问题依然没有一个比较好的解决办法。</p>
<p>为此，Redis 5.0 新增加的一个数据结构 <code>Stream</code> 来做消息队列。<code>Stream</code> 支持：</p>
<ul>
<li>发布 &#x2F; 订阅模式</li>
<li>按照消费者组进行消费（借鉴了 Kafka 消费者组的概念）</li>
<li>消息持久化（ RDB 和 AOF）</li>
<li>ACK 机制（通过确认机制来告知已经成功处理了消息）</li>
<li>阻塞式获取消息</li>
</ul>
<p><code>Stream</code> 的结构如下：</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/redis-stream-structure.png"></p>
<p>这是一个有序的消息链表，每个消息都有一个唯一的 ID 和对应的内容。ID 是一个时间戳和序列号的组合，用来保证消息的唯一性和递增性。内容是一个或多个键值对（类似 Hash 基本数据类型），用来存储消息的数据。</p>
<p>这里再对图中涉及到的一些概念，进行简单解释：</p>
<ul>
<li><code>Consumer Group</code>：消费者组用于组织和管理多个消费者。消费者组本身不处理消息，而是再将消息分发给消费者，由消费者进行真正的消费</li>
<li><code>last_delivered_id</code>：标识消费者组当前消费位置的游标，消费者组中任意一个消费者读取了消息都会使 last_delivered_id 往前移动。</li>
<li><code>pending_ids</code>：记录已经被客户端消费但没有 ack 的消息的 ID。</li>
</ul>
<p>下面是<code>Stream</code> 用作消息队列时常用的命令：</p>
<ul>
<li><code>XADD</code>：向流中添加新的消息。</li>
<li><code>XREAD</code>：从流中读取消息。</li>
<li><code>XREADGROUP</code>：从消费组中读取消息。</li>
<li><code>XRANGE</code>：根据消息 ID 范围读取流中的消息。</li>
<li><code>XREVRANGE</code>：与 <code>XRANGE</code> 类似，但以相反顺序返回结果。</li>
<li><code>XDEL</code>：从流中删除消息。</li>
<li><code>XTRIM</code>：修剪流的长度，可以指定修建策略（<code>MAXLEN</code>&#x2F;<code>MINID</code>）。</li>
<li><code>XLEN</code>：获取流的长度。</li>
<li><code>XGROUP CREATE</code>：创建消费者组。</li>
<li><code>XGROUP DESTROY</code> ： 删除消费者组</li>
<li><code>XGROUP DELCONSUMER</code>：从消费者组中删除一个消费者。</li>
<li><code>XGROUP SETID</code>：为消费者组设置新的最后递送消息 ID</li>
<li><code>XACK</code>：确认消费组中的消息已被处理。</li>
<li><code>XPENDING</code>：查询消费组中挂起（未确认）的消息。</li>
<li><code>XCLAIM</code>：将挂起的消息从一个消费者转移到另一个消费者。</li>
<li><code>XINFO</code>：获取流(<code>XINFO STREAM</code>)、消费组(<code>XINFO GROUPS</code>)或消费者(<code>XINFO CONSUMERS</code>)的详细信息。</li>
</ul>
<p><code>Stream</code> 使用起来相对要麻烦一些，这里就不演示了。</p>
<p>总的来说，<code>Stream</code> 已经可以满足一个消息队列的基本要求了。不过，<code>Stream</code> 在实际使用中依然会有一些小问题不太好解决比如在 Redis 发生故障恢复后不能保证消息至少被消费一次。</p>
<p>综上，和专业的消息队列相比，使用 Redis 来实现消息队列还是有很多欠缺的地方比如消息丢失和堆积问题不好解决。因此，我们通常建议不要使用 Redis 来做消息队列，你完全可以选择市面上比较成熟的一些消息队列比如 RocketMQ、Kafka。不过，如果你就是想要用 Redis 来做消息队列的话，那我建议你优先考虑 <code>Stream</code>，这是目前相对最优的 Redis 消息队列实现。</p>
<p>相关阅读：<a href="https://mp.weixin.qq.com/s/gCUT5TcCQRAxYkTJfTRjJw">Redis 消息队列发展历程 - 阿里开发者 - 2022</a>。</p>
<h3 id="Redis-可以做搜索引擎么？"><a href="#Redis-可以做搜索引擎么？" class="headerlink" title="Redis 可以做搜索引擎么？"></a>Redis 可以做搜索引擎么？</h3><p>Redis 是可以实现全文搜索引擎功能的，需要借助 <strong>RediSearch</strong> ，这是一个基于 Redis 的搜索引擎模块。</p>
<p>RediSearch 支持中文分词、聚合统计、停用词、同义词、拼写检查、标签查询、向量相似度查询、多关键词搜索、分页搜索等功能，算是一个功能比较完善的全文搜索引擎了。</p>
<p>相比较于 Elasticsearch 来说，RediSearch 主要在下面两点上表现更优异一些：</p>
<ol>
<li>性能更优秀：依赖 Redis 自身的高性能，基于内存操作（Elasticsearch 基于磁盘）。</li>
<li>较低内存占用实现快速索引：RediSearch 内部使用压缩的倒排索引，所以可以用较低的内存占用来实现索引的快速构建。</li>
</ol>
<p>对于小型项目的简单搜索场景来说，使用 RediSearch 来作为搜索引擎还是没有问题的（搭配 RedisJSON 使用）。</p>
<p>对于比较复杂或者数据规模较大的搜索场景还是不太建议使用 RediSearch 来作为搜索引擎，主要是因为下面这些限制和问题：</p>
<ol>
<li>数据量限制：Elasticsearch 可以支持 PB 级别的数据量，可以轻松扩展到多个节点，利用分片机制提高可用性和性能。RedisSearch 是基于 Redis 实现的，其能存储的数据量受限于 Redis 的内存容量，不太适合存储大规模的数据（内存昂贵，扩展能力较差）。</li>
<li>分布式能力较差：Elasticsearch 是为分布式环境设计的，可以轻松扩展到多个节点。虽然 RedisSearch 支持分布式部署，但在实际应用中可能会面临一些挑战，如数据分片、节点间通信、数据一致性等问题。</li>
<li>聚合功能较弱：Elasticsearch 提供了丰富的聚合功能，而 RediSearch 的聚合功能相对较弱，只支持简单的聚合操作。</li>
<li>生态较差：Elasticsearch 可以轻松和常见的一些系统&#x2F;软件集成比如 Hadoop、Spark、Kibana，而 RedisSearch 则不具备该优势。</li>
</ol>
<p>Elasticsearch 适用于全文搜索、复杂查询、实时数据分析和聚合的场景，而 RediSearch 适用于快速数据存储、缓存和简单查询的场景。</p>
<h3 id="如何基于-Redis-实现延时任务？"><a href="#如何基于-Redis-实现延时任务？" class="headerlink" title="如何基于 Redis 实现延时任务？"></a>如何基于 Redis 实现延时任务？</h3><blockquote>
<p>类似的问题：</p>
<ul>
<li>订单在 10 分钟后未支付就失效，如何用 Redis 实现？</li>
<li>红包 24 小时未被查收自动退还，如何用 Redis 实现？</li>
</ul>
</blockquote>
<p>基于 Redis 实现延时任务的功能无非就下面两种方案：</p>
<ol>
<li>Redis 过期事件监听</li>
<li>Redisson 内置的延时队列</li>
</ol>
<p>Redis 过期事件监听的存在时效性较差、丢消息、多服务实例下消息重复消费等问题，不被推荐使用。</p>
<p>Redisson 内置的延时队列具备下面这些优势：</p>
<ol>
<li><strong>减少了丢消息的可能</strong>：DelayedQueue 中的消息会被持久化，即使 Redis 宕机了，根据持久化机制，也只可能丢失一点消息，影响不大。当然了，你也可以使用扫描数据库的方法作为补偿机制。</li>
<li><strong>消息不存在重复消费问题</strong>：每个客户端都是从同一个目标队列中获取任务的，不存在重复消费的问题。</li>
</ol>
<p>关于 Redis 实现延时任务的详细介绍，可以看我写的这篇文章：<a href="./redis-delayed-task.md">如何基于 Redis 实现延时任务？</a>。</p>
<h2 id="Redis-数据类型"><a href="#Redis-数据类型" class="headerlink" title="Redis 数据类型"></a>Redis 数据类型</h2><p>关于 Redis 5 种基础数据类型和 3 种特殊数据类型的详细介绍请看下面这两篇文章以及 <a href="https://redis.io/docs/data-types/">Redis 官方文档</a> ：</p>
<ul>
<li><a href="https://javaguide.cn/database/redis/redis-data-structures-01.html">Redis 5 种基本数据类型详解</a></li>
<li><a href="https://javaguide.cn/database/redis/redis-data-structures-02.html">Redis 3 种特殊数据类型详解</a></li>
</ul>
<h3 id="Redis-常用的数据类型有哪些？"><a href="#Redis-常用的数据类型有哪些？" class="headerlink" title="Redis 常用的数据类型有哪些？"></a>Redis 常用的数据类型有哪些？</h3><p>Redis 中比较常见的数据类型有下面这些：</p>
<ul>
<li><strong>5 种基础数据类型</strong>：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。</li>
<li><strong>3 种特殊数据类型</strong>：HyperLogLog（基数统计）、Bitmap （位图）、Geospatial (地理位置)。</li>
</ul>
<p>除了上面提到的之外，还有一些其他的比如 <a href="https://javaguide.cn/cs-basics/data-structure/bloom-filter.html">Bloom filter（布隆过滤器）</a>、Bitfield（位域）。</p>
<h3 id="String-的应用场景有哪些？"><a href="#String-的应用场景有哪些？" class="headerlink" title="String 的应用场景有哪些？"></a>String 的应用场景有哪些？</h3><p>String 是 Redis 中最简单同时也是最常用的一个数据类型。它是一种二进制安全的数据类型，可以用来存储任何类型的数据比如字符串、整数、浮点数、图片（图片的 base64 编码或者解码或者图片的路径）、序列化后的对象。</p>
<p>String 的常见应用场景如下：</p>
<ul>
<li>常规数据（比如 Session、Token、序列化后的对象、图片的路径）的缓存；</li>
<li>计数比如用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数；</li>
<li>分布式锁(利用 <code>SETNX key value</code> 命令可以实现一个最简易的分布式锁)；</li>
<li>……</li>
</ul>
<p>关于 String 的详细介绍请看这篇文章：<a href="https://javaguide.cn/database/redis/redis-data-structures-01.html">Redis 5 种基本数据类型详解</a>。</p>
<h3 id="String-还是-Hash-存储对象数据更好呢？"><a href="#String-还是-Hash-存储对象数据更好呢？" class="headerlink" title="String 还是 Hash 存储对象数据更好呢？"></a>String 还是 Hash 存储对象数据更好呢？</h3><p>简单对比一下二者：</p>
<ul>
<li><strong>对象存储方式</strong>：String 存储的是序列化后的对象数据，存放的是整个对象，操作简单直接。Hash 是对对象的每个字段单独存储，可以获取部分字段的信息，也可以修改或者添加部分字段，节省网络流量。如果对象中某些字段需要经常变动或者经常需要单独查询对象中的个别字段信息，Hash 就非常适合。</li>
<li><strong>内存消耗</strong>：Hash 通常比 String 更节省内存，特别是在字段较多且字段长度较短时。Redis 对小型 Hash 进行优化（如使用 ziplist 存储），进一步降低内存占用。</li>
<li><strong>复杂对象存储</strong>：String 在处理多层嵌套或复杂结构的对象时更方便，因为无需处理每个字段的独立存储和操作。</li>
<li><strong>性能</strong>：String 的操作通常具有 O(1) 的时间复杂度，因为它存储的是整个对象，操作简单直接，整体读写的性能较好。Hash 由于需要处理多个字段的增删改查操作，在字段较多且经常变动的情况下，可能会带来额外的性能开销。</li>
</ul>
<p>总结：</p>
<ul>
<li>在绝大多数情况下，<strong>String</strong> 更适合存储对象数据，尤其是当对象结构简单且整体读写是主要操作时。</li>
<li>如果你需要频繁操作对象的部分字段或节省内存，<strong>Hash</strong> 可能是更好的选择。</li>
</ul>
<h3 id="String-的底层实现是什么？"><a href="#String-的底层实现是什么？" class="headerlink" title="String 的底层实现是什么？"></a>String 的底层实现是什么？</h3><p>Redis 是基于 C 语言编写的，但 Redis 的 String 类型的底层实现并不是 C 语言中的字符串（即以空字符 <code>\0</code> 结尾的字符数组），而是自己编写了 <a href="https://github.com/antirez/sds">SDS</a>（Simple Dynamic String，简单动态字符串） 来作为底层实现。</p>
<p>SDS 最早是 Redis 作者为日常 C 语言开发而设计的 C 字符串，后来被应用到了 Redis 上，并经过了大量的修改完善以适合高性能操作。</p>
<p>Redis7.0 的 SDS 的部分源码如下（<a href="https://github.com/redis/redis/blob/7.0/src/sds.h">https://github.com/redis/redis/blob/7.0/src/sds.h</a>）:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Note: sdshdr5 is never used, we just access the flags byte directly.</span></span><br><span class="line"><span class="comment"> * However is here to document the layout of type 5 SDS strings. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint8_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint16_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint32_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过源码可以看出，SDS 共有五种实现方式 SDS_TYPE_5（并未用到）、SDS_TYPE_8、SDS_TYPE_16、SDS_TYPE_32、SDS_TYPE_64，其中只有后四种实际用到。Redis 会根据初始化的长度决定使用哪种类型，从而减少内存的使用。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>字节</th>
<th>位</th>
</tr>
</thead>
<tbody><tr>
<td>sdshdr5</td>
<td>&lt; 1</td>
<td>&lt;8</td>
</tr>
<tr>
<td>sdshdr8</td>
<td>1</td>
<td>8</td>
</tr>
<tr>
<td>sdshdr16</td>
<td>2</td>
<td>16</td>
</tr>
<tr>
<td>sdshdr32</td>
<td>4</td>
<td>32</td>
</tr>
<tr>
<td>sdshdr64</td>
<td>8</td>
<td>64</td>
</tr>
</tbody></table>
<p>对于后四种实现都包含了下面这 4 个属性：</p>
<ul>
<li><code>len</code>：字符串的长度也就是已经使用的字节数</li>
<li><code>alloc</code>：总共可用的字符空间大小，alloc-len 就是 SDS 剩余的空间大小</li>
<li><code>buf[]</code>：实际存储字符串的数组</li>
<li><code>flags</code>：低三位保存类型标志</li>
</ul>
<p>SDS 相比于 C 语言中的字符串有如下提升：</p>
<ol>
<li><strong>可以避免缓冲区溢出</strong>：C 语言中的字符串被修改（比如拼接）时，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。SDS 被修改时，会先根据 len 属性检查空间大小是否满足要求，如果不满足，则先扩展至所需大小再进行修改操作。</li>
<li><strong>获取字符串长度的复杂度较低</strong>：C 语言中的字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O(n)。SDS 的长度获取直接读取 len 属性即可，时间复杂度为 O(1)。</li>
<li><strong>减少内存分配次数</strong>：为了避免修改（增加&#x2F;减少）字符串时，每次都需要重新分配内存（C 语言的字符串是这样的），SDS 实现了空间预分配和惰性空间释放两种优化策略。当 SDS 需要增加字符串时，Redis 会为 SDS 分配好内存，并且根据特定的算法分配多余的内存，这样可以减少连续执行字符串增长操作所需的内存重分配次数。当 SDS 需要减少字符串时，这部分内存不会立即被回收，会被记录下来，等待后续使用（支持手动释放，有对应的 API）。</li>
<li><strong>二进制安全</strong>：C 语言中的字符串以空字符 <code>\0</code> 作为字符串结束的标识，这存在一些问题，像一些二进制文件（比如图片、视频、音频）就可能包括空字符，C 字符串无法正确保存。SDS 使用 len 属性判断字符串是否结束，不存在这个问题。</li>
</ol>
<p>🤐 多提一嘴，很多文章里 SDS 的定义是下面这样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> len;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">free</span>;</span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个也没错，Redis 3.2 之前就是这样定义的。后来，由于这种方式的定义存在问题，<code>len</code> 和 <code>free</code> 的定义用了 4 个字节，造成了浪费。Redis 3.2 之后，Redis 改进了 SDS 的定义，将其划分为了现在的 5 种类型。</p>
<h3 id="购物车信息用-String-还是-Hash-存储更好呢"><a href="#购物车信息用-String-还是-Hash-存储更好呢" class="headerlink" title="购物车信息用 String 还是 Hash 存储更好呢?"></a>购物车信息用 String 还是 Hash 存储更好呢?</h3><p>由于购物车中的商品频繁修改和变动，购物车信息建议使用 Hash 存储：</p>
<ul>
<li>用户 id 为 key</li>
<li>商品 id 为 field，商品数量为 value</li>
</ul>
<p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/hash-shopping-cart.png" alt="Hash维护简单的购物车信息"></p>
<p>那用户购物车信息的维护具体应该怎么操作呢？</p>
<ul>
<li>用户添加商品就是往 Hash 里面增加新的 field 与 value；</li>
<li>查询购物车信息就是遍历对应的 Hash；</li>
<li>更改商品数量直接修改对应的 value 值（直接 set 或者做运算皆可）；</li>
<li>删除商品就是删除 Hash 中对应的 field；</li>
<li>清空购物车直接删除对应的 key 即可。</li>
</ul>
<p>这里只是以业务比较简单的购物车场景举例，实际电商场景下，field 只保存一个商品 id 是没办法满足需求的。</p>
<h3 id="使用-Redis-实现一个排行榜怎么做？"><a href="#使用-Redis-实现一个排行榜怎么做？" class="headerlink" title="使用 Redis 实现一个排行榜怎么做？"></a>使用 Redis 实现一个排行榜怎么做？</h3><p>Redis 中有一个叫做 <code>Sorted Set</code> （有序集合）的数据类型经常被用在各种排行榜的场景，比如直播间送礼物的排行榜、朋友圈的微信步数排行榜、王者荣耀中的段位排行榜、话题热度排行榜等等。</p>
<p>相关的一些 Redis 命令: <code>ZRANGE</code> (从小到大排序)、 <code>ZREVRANGE</code> （从大到小排序）、<code>ZREVRANK</code> (指定元素排名)。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/2021060714195385.png"></p>
<p><a href="https://javaguide.cn/zhuanlan/java-mian-shi-zhi-bei.html">《Java 面试指北》</a> 的「技术面试题篇」就有一篇文章详细介绍如何使用 Sorted Set 来设计制作一个排行榜，感兴趣的小伙伴可以看看。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/image-20220719071115140.png"></p>
<h3 id="Redis-的有序集合底层为什么要用跳表，而不用平衡树、红黑树或者-B-树？"><a href="#Redis-的有序集合底层为什么要用跳表，而不用平衡树、红黑树或者-B-树？" class="headerlink" title="Redis 的有序集合底层为什么要用跳表，而不用平衡树、红黑树或者 B+树？"></a>Redis 的有序集合底层为什么要用跳表，而不用平衡树、红黑树或者 B+树？</h3><p>这道面试题很多大厂比较喜欢问，难度还是有点大的。</p>
<ul>
<li>平衡树 vs 跳表：平衡树的插入、删除和查询的时间复杂度和跳表一样都是 **O(log n)**。对于范围查询来说，平衡树也可以通过中序遍历的方式达到和跳表一样的效果。但是它的每一次插入或者删除操作都需要保证整颗树左右节点的绝对平衡，只要不平衡就要通过旋转操作来保持平衡，这个过程是比较耗时的。跳表诞生的初衷就是为了克服平衡树的一些缺点。跳表使用概率平衡而不是严格强制的平衡，因此，跳表中的插入和删除算法比平衡树的等效算法简单得多，速度也快得多。</li>
<li>红黑树 vs 跳表：相比较于红黑树来说，跳表的实现也更简单一些，不需要通过旋转和染色（红黑变换）来保证黑平衡。并且，按照区间来查找数据这个操作，红黑树的效率没有跳表高。</li>
<li>B+树 vs 跳表：B+树更适合作为数据库和文件系统中常用的索引结构之一，它的核心思想是通过可能少的 IO 定位到尽可能多的索引来获得查询数据。对于 Redis 这种内存数据库来说，它对这些并不感冒，因为 Redis 作为内存数据库它不可能存储大量的数据，所以对于索引不需要通过 B+树这种方式进行维护，只需按照概率进行随机维护即可，节约内存。而且使用跳表实现 zset 时相较前者来说更简单一些，在进行插入时只需通过索引将数据插入到链表中合适的位置再随机维护一定高度的索引即可，也不需要像 B+树那样插入时发现失衡时还需要对节点分裂与合并。</li>
</ul>
<p>另外，我还单独写了一篇文章从有序集合的基本使用到跳表的源码分析和实现，让你会对 Redis 的有序集合底层实现的跳表有着更深刻的理解和掌握 ：<a href="./redis-skiplist.md">Redis 为什么用跳表实现有序集合</a>。</p>
<h3 id="Set-的应用场景是什么？"><a href="#Set-的应用场景是什么？" class="headerlink" title="Set 的应用场景是什么？"></a>Set 的应用场景是什么？</h3><p>Redis 中 <code>Set</code> 是一种无序集合，集合中的元素没有先后顺序但都唯一，有点类似于 Java 中的 <code>HashSet</code> 。</p>
<p><code>Set</code> 的常见应用场景如下：</p>
<ul>
<li>存放的数据不能重复的场景：网站 UV 统计（数据量巨大的场景还是 <code>HyperLogLog</code>更适合一些）、文章点赞、动态点赞等等。</li>
<li>需要获取多个数据源交集、并集和差集的场景：共同好友(交集)、共同粉丝(交集)、共同关注(交集)、好友推荐（差集）、音乐推荐（差集）、订阅号推荐（差集+交集） 等等。</li>
<li>需要随机获取数据源中的元素的场景：抽奖系统、随机点名等等。</li>
</ul>
<h3 id="使用-Set-实现抽奖系统怎么做？"><a href="#使用-Set-实现抽奖系统怎么做？" class="headerlink" title="使用 Set 实现抽奖系统怎么做？"></a>使用 Set 实现抽奖系统怎么做？</h3><p>如果想要使用 <code>Set</code> 实现一个简单的抽奖系统的话，直接使用下面这几个命令就可以了：</p>
<ul>
<li><code>SADD key member1 member2 ...</code>：向指定集合添加一个或多个元素。</li>
<li><code>SPOP key count</code>：随机移除并获取指定集合中一个或多个元素，适合不允许重复中奖的场景。</li>
<li><code>SRANDMEMBER key count</code> : 随机获取指定集合中指定数量的元素，适合允许重复中奖的场景。</li>
</ul>
<h3 id="使用-Bitmap-统计活跃用户怎么做？"><a href="#使用-Bitmap-统计活跃用户怎么做？" class="headerlink" title="使用 Bitmap 统计活跃用户怎么做？"></a>使用 Bitmap 统计活跃用户怎么做？</h3><p>Bitmap 存储的是连续的二进制数字（0 和 1），通过 Bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 Bitmap 本身会极大的节省储存空间。</p>
<p>你可以将 Bitmap 看作是一个存储二进制数字（0 和 1）的数组，数组中每个元素的下标叫做 offset（偏移量）。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/image-20220720194154133.png" alt="img"></p>
<p>如果想要使用 Bitmap 统计活跃用户的话，可以使用日期（精确到天）作为 key，然后用户 ID 为 offset，如果当日活跃过就设置为 1。</p>
<p>初始化数据：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; SETBIT 20210308 1 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">&gt; SETBIT 20210308 2 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">&gt; SETBIT 20210309 1 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>

<p>统计 20210308~20210309 总活跃用户数:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; BITOP and desk1 20210308 20210309</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; BITCOUNT desk1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>

<p>统计 20210308~20210309 在线活跃用户数:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; BITOP or desk2 20210308 20210309</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; BITCOUNT desk2</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure>

<h3 id="使用-HyperLogLog-统计页面-UV-怎么做？"><a href="#使用-HyperLogLog-统计页面-UV-怎么做？" class="headerlink" title="使用 HyperLogLog 统计页面 UV 怎么做？"></a>使用 HyperLogLog 统计页面 UV 怎么做？</h3><p>使用 HyperLogLog 统计页面 UV 主要需要用到下面这两个命令：</p>
<ul>
<li><code>PFADD key element1 element2 ...</code>：添加一个或多个元素到 HyperLogLog 中。</li>
<li><code>PFCOUNT key1 key2</code>：获取一个或者多个 HyperLogLog 的唯一计数。</li>
</ul>
<p>1、将访问指定页面的每个用户 ID 添加到 <code>HyperLogLog</code> 中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PFADD PAGE_1:UV USER1 USER2 ...... USERn</span><br></pre></td></tr></table></figure>

<p>2、统计指定页面的 UV。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PFCOUNT PAGE_1:UV</span><br></pre></td></tr></table></figure>

<h2 id="Redis-持久化机制（重要）"><a href="#Redis-持久化机制（重要）" class="headerlink" title="Redis 持久化机制（重要）"></a>Redis 持久化机制（重要）</h2><p>Redis 持久化机制（RDB 持久化、AOF 持久化、RDB 和 AOF 的混合持久化） 相关的问题比较多，也比较重要，于是我单独抽了一篇文章来总结 Redis 持久化机制相关的知识点和问题：<a href="https://javaguide.cn/database/redis/redis-persistence.html">Redis 持久化机制详解</a> 。</p>
<h2 id="Redis-线程模型（重要）"><a href="#Redis-线程模型（重要）" class="headerlink" title="Redis 线程模型（重要）"></a>Redis 线程模型（重要）</h2><p>对于读写命令来说，Redis 一直是单线程模型。不过，在 Redis 4.0 版本之后引入了多线程来执行一些大键值对的异步删除操作， Redis 6.0 版本之后引入了多线程来处理网络请求（提高网络 IO 读写性能）。</p>
<h3 id="Redis-单线程模型了解吗？"><a href="#Redis-单线程模型了解吗？" class="headerlink" title="Redis 单线程模型了解吗？"></a>Redis 单线程模型了解吗？</h3><p><strong>Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型</strong> （Netty 的线程模型也基于 Reactor 模式，Reactor 模式不愧是高性能 IO 的基石），这套事件处理模型对应的是 Redis 中的文件事件处理器（file event handler）。由于文件事件处理器（file event handler）是单线程方式运行的，所以我们一般都说 Redis 是单线程模型。</p>
<p>《Redis 设计与实现》有一段话是这样介绍文件事件处理器的，我觉得写得挺不错。</p>
<blockquote>
<p>Redis 基于 Reactor 模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）。</p>
<ul>
<li>文件事件处理器使用 I&#x2F;O 多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li>
<li>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关 闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li>
</ul>
<p><strong>虽然文件事件处理器以单线程方式运行，但通过使用 I&#x2F;O 多路复用程序来监听多个套接字</strong>，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。</p>
</blockquote>
<p><strong>既然是单线程，那怎么监听大量的客户端连接呢？</strong></p>
<p>Redis 通过 <strong>IO 多路复用程序</strong> 来监听来自客户端的大量连接（或者说是监听多个 socket），它会将感兴趣的事件及类型（读、写）注册到内核中并监听每个事件是否发生。</p>
<p>这样的好处非常明显：<strong>I&#x2F;O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗</strong>（和 NIO 中的 <code>Selector</code> 组件很像）。</p>
<p>文件事件处理器（file event handler）主要是包含 4 个部分：</p>
<ul>
<li>多个 socket（客户端连接）</li>
<li>IO 多路复用程序（支持多个客户端连接的关键）</li>
<li>文件事件分派器（将 socket 关联到相应的事件处理器）</li>
<li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li>
</ul>
<p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/redis-event-handler.png" alt="文件事件处理器（file event handler）"></p>
<p>相关阅读：<a href="http://remcarpediem.net/article/1aa2da89/">Redis 事件机制详解</a> 。</p>
<h3 id="Redis6-0-之前为什么不使用多线程？"><a href="#Redis6-0-之前为什么不使用多线程？" class="headerlink" title="Redis6.0 之前为什么不使用多线程？"></a>Redis6.0 之前为什么不使用多线程？</h3><p>虽然说 Redis 是单线程模型，但实际上，<strong>Redis 在 4.0 之后的版本中就已经加入了对多线程的支持。</strong></p>
<p>不过，Redis 4.0 增加的多线程主要是针对一些大键值对的删除操作的命令，使用这些命令就会使用主线程之外的其他线程来“异步处理”，从而减少对主线程的影响。</p>
<p>为此，Redis 4.0 之后新增了几个异步命令：</p>
<ul>
<li><code>UNLINK</code>：可以看作是 <code>DEL</code> 命令的异步版本。</li>
<li><code>FLUSHALL ASYNC</code>：用于清空所有数据库的所有键，不限于当前 <code>SELECT</code> 的数据库。</li>
<li><code>FLUSHDB ASYNC</code>：用于清空当前 <code>SELECT</code> 数据库中的所有键。</li>
</ul>
<p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/redis4.0-more-thread.png" alt="redis4.0 more thread"></p>
<p>总的来说，直到 Redis 6.0 之前，Redis 的主要操作仍然是单线程处理的。</p>
<p><strong>那 Redis6.0 之前为什么不使用多线程？</strong> 我觉得主要原因有 3 点：</p>
<ul>
<li>单线程编程容易并且更容易维护；</li>
<li>Redis 的性能瓶颈不在 CPU ，主要在内存和网络；</li>
<li>多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。</li>
</ul>
<p>相关阅读：<a href="https://draveness.me/whys-the-design-redis-single-thread/">为什么 Redis 选择单线程模型？</a> 。</p>
<h3 id="Redis6-0-之后为何引入了多线程？"><a href="#Redis6-0-之后为何引入了多线程？" class="headerlink" title="Redis6.0 之后为何引入了多线程？"></a>Redis6.0 之后为何引入了多线程？</h3><p><strong>Redis6.0 引入多线程主要是为了提高网络 IO 读写性能</strong>，因为这个算是 Redis 中的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络）。</p>
<p>虽然，Redis6.0 引入了多线程，但是 Redis 的多线程只是在网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程顺序执行。因此，你也不需要担心线程安全问题。</p>
<p>Redis6.0 的多线程默认是禁用的，只使用主线程。如需开启需要设置 IO 线程数 &gt; 1，需要修改 redis 配置文件 <code>redis.conf</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io-threads 4 <span class="comment">#设置1的话只会开启主线程，官网建议4核的机器建议设置为2或3个线程，8核的建议设置为6个线程</span></span><br></pre></td></tr></table></figure>

<p>另外：</p>
<ul>
<li>io-threads 的个数一旦设置，不能通过 config 动态设置。</li>
<li>当设置 ssl 后，io-threads 将不工作。</li>
</ul>
<p>开启多线程后，默认只会使用多线程进行 IO 写入 writes，即发送数据给客户端，如果需要开启多线程 IO 读取 reads，同样需要修改 redis 配置文件 <code>redis.conf</code> :</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io-threads-do-reads <span class="built_in">yes</span></span><br></pre></td></tr></table></figure>

<p>但是官网描述开启多线程读并不能有太大提升，因此一般情况下并不建议开启</p>
<p>相关阅读：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/FZu3acwK6zrCBZQ_3HoUgw">Redis 6.0 新特性-多线程连环 13 问！</a></li>
<li><a href="https://segmentfault.com/a/1190000039223696">Redis 多线程网络模型全面揭秘</a>（推荐）</li>
</ul>
<h3 id="Redis-后台线程了解吗？"><a href="#Redis-后台线程了解吗？" class="headerlink" title="Redis 后台线程了解吗？"></a>Redis 后台线程了解吗？</h3><p>我们虽然经常说 Redis 是单线程模型（主要逻辑是单线程完成的），但实际还有一些后台线程用于执行一些比较耗时的操作：</p>
<ul>
<li>通过 <code>bio_close_file</code> 后台线程来释放 AOF &#x2F; RDB 等过程中产生的临时文件资源。</li>
<li>通过 <code>bio_aof_fsync</code> 后台线程调用 <code>fsync</code> 函数将系统内核缓冲区还未同步到到磁盘的数据强制刷到磁盘（ AOF 文件）。</li>
<li>通过 <code>bio_lazy_free</code>后台线程释放大对象（已删除）占用的内存空间.</li>
</ul>
<p>在<code>bio.h</code> 文件中有定义（Redis 6.0 版本，源码地址：<a href="https://github.com/redis/redis/blob/6.0/src/bio.h">https://github.com/redis/redis/blob/6.0/src/bio.h</a>）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#ifndef __BIO_H</span><br><span class="line">#define __BIO_H</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Exported API */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">bioInit</span><span class="params">(<span class="keyword">void</span>)</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">bioCreateBackgroundJob</span><span class="params">(<span class="type">int</span> type, <span class="keyword">void</span> *arg1, <span class="keyword">void</span> *arg2, <span class="keyword">void</span> *arg3)</span>;</span><br><span class="line">unsigned <span class="type">long</span> <span class="type">long</span> <span class="title function_">bioPendingJobsOfType</span><span class="params">(<span class="type">int</span> type)</span>;</span><br><span class="line">unsigned <span class="type">long</span> <span class="type">long</span> <span class="title function_">bioWaitStepOfType</span><span class="params">(<span class="type">int</span> type)</span>;</span><br><span class="line">time_t <span class="title function_">bioOlderJobOfType</span><span class="params">(<span class="type">int</span> type)</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">bioKillThreads</span><span class="params">(<span class="keyword">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Background job opcodes */</span></span><br><span class="line">#define BIO_CLOSE_FILE    <span class="number">0</span> <span class="comment">/* Deferred close(2) syscall. */</span></span><br><span class="line">#define BIO_AOF_FSYNC     <span class="number">1</span> <span class="comment">/* Deferred AOF fsync. */</span></span><br><span class="line">#define BIO_LAZY_FREE     <span class="number">2</span> <span class="comment">/* Deferred objects freeing. */</span></span><br><span class="line">#define BIO_NUM_OPS       <span class="number">3</span></span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>关于 Redis 后台线程的详细介绍可以查看 <a href="https://juejin.cn/post/7102780434739626014">Redis 6.0 后台线程有哪些？</a> 这篇就文章。</p>
<h2 id="Redis-内存管理"><a href="#Redis-内存管理" class="headerlink" title="Redis 内存管理"></a>Redis 内存管理</h2><h3 id="Redis-给缓存数据设置过期时间有什么用？"><a href="#Redis-给缓存数据设置过期时间有什么用？" class="headerlink" title="Redis 给缓存数据设置过期时间有什么用？"></a>Redis 给缓存数据设置过期时间有什么用？</h3><p>一般情况下，我们设置保存的缓存数据的时候都会设置一个过期时间。为什么呢？</p>
<p>内存是有限且珍贵的，如果不对缓存数据设置过期时间，那内存占用就会一直增长，最终可能会导致 OOM 问题。通过设置合理的过期时间，Redis 会自动删除暂时不需要的数据，为新的缓存数据腾出空间。</p>
<p>Redis 自带了给缓存数据设置过期时间的功能，比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; expire key 60 <span class="comment"># 数据在 60s 后过期</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; setex key 60 value <span class="comment"># 数据在 60s 后过期 (setex:[set] + [ex]pire)</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl key <span class="comment"># 查看数据还有多久过期</span></span><br><span class="line">(<span class="built_in">integer</span>) 56</span><br></pre></td></tr></table></figure>

<p>注意 ⚠️：Redis 中除了字符串类型有自己独有设置过期时间的命令 <code>setex</code> 外，其他方法都需要依靠 <code>expire</code> 命令来设置过期时间 。另外， <code>persist</code> 命令可以移除一个键的过期时间。</p>
<p><strong>过期时间除了有助于缓解内存的消耗，还有什么其他用么？</strong></p>
<p>很多时候，我们的业务场景就是需要某个数据只在某一时间段内存在，比如我们的短信验证码可能只在 1 分钟内有效，用户登录的 Token 可能只在 1 天内有效。</p>
<p>如果使用传统的数据库来处理的话，一般都是自己判断过期，这样更麻烦并且性能要差很多。</p>
<h3 id="Redis-是如何判断数据是否过期的呢？"><a href="#Redis-是如何判断数据是否过期的呢？" class="headerlink" title="Redis 是如何判断数据是否过期的呢？"></a>Redis 是如何判断数据是否过期的呢？</h3><p>Redis 通过一个叫做过期字典（可以看作是 hash 表）来保存数据过期的时间。过期字典的键指向 Redis 数据库中的某个 key(键)，过期字典的值是一个 long long 类型的整数，这个整数保存了 key 所指向的数据库键的过期时间（毫秒精度的 UNIX 时间戳）。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/redis-expired-dictionary.png" alt="Redis 过期字典"></p>
<p>过期字典是存储在 redisDb 这个结构里的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    dict *dict;     <span class="comment">//数据库键空间,保存着数据库中所有键值对</span></span><br><span class="line">    dict *expires   <span class="comment">// 过期字典,保存着键的过期时间</span></span><br><span class="line">    ...</span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>

<p>在查询一个 key 的时候，Redis 首先检查该 key 是否存在于过期字典中（时间复杂度为 O(1)），如果不在就直接返回，在的话需要判断一下这个 key 是否过期，过期直接删除 key 然后返回 null。</p>
<h3 id="Redis-过期-key-删除策略了解么？"><a href="#Redis-过期-key-删除策略了解么？" class="headerlink" title="Redis 过期 key 删除策略了解么？"></a>Redis 过期 key 删除策略了解么？</h3><p>如果假设你设置了一批 key 只能存活 1 分钟，那么 1 分钟后，Redis 是怎么对这批 key 进行删除的呢？</p>
<p>常用的过期数据的删除策略就下面这几种：</p>
<ol>
<li><strong>惰性删除</strong>：只会在取出&#x2F;查询 key 的时候才对数据进行过期检查。这种方式对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。</li>
<li><strong>定期删除</strong>：周期性地随机从设置了过期时间的 key 中抽查一批，然后逐个检查这些 key 是否过期，过期就删除 key。相比于惰性删除，定期删除对内存更友好，对 CPU 不太友好。</li>
<li><strong>延迟队列</strong>：把设置过期时间的 key 放到一个延迟队列里，到期之后就删除 key。这种方式可以保证每个过期 key 都能被删除，但维护延迟队列太麻烦，队列本身也要占用资源。</li>
<li><strong>定时删除</strong>：每个设置了过期时间的 key 都会在设置的时间到达时立即被删除。这种方法可以确保内存中不会有过期的键，但是它对 CPU 的压力最大，因为它需要为每个键都设置一个定时器。</li>
</ol>
<p><strong>Redis 采用的那种删除策略呢？</strong></p>
<p>Redis 采用的是 <strong>定期删除+惰性&#x2F;懒汉式删除</strong> 结合的策略，这也是大部分缓存框架的选择。定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，结合起来使用既能兼顾 CPU 友好，又能兼顾内存友好。</p>
<p>下面是我们详细介绍一下 Redis 中的定期删除具体是如何做的。</p>
<p>Redis 的定期删除过程是随机的（周期性地随机从设置了过期时间的 key 中抽查一批），所以并不保证所有过期键都会被立即删除。这也就解释了为什么有的 key 过期了，并没有被删除。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。</p>
<p>另外，定期删除还会受到执行时间和过期 key 的比例的影响：</p>
<ul>
<li>执行时间已经超过了阈值，那么就中断这一次定期删除循环，以避免使用过多的 CPU 时间。</li>
<li>如果这一批过期的 key 比例超过一个比例，就会重复执行此删除流程，以更积极地清理过期 key。相应地，如果过期的 key 比例低于这个比例，就会中断这一次定期删除循环，避免做过多的工作而获得很少的内存回收。</li>
</ul>
<p>Redis 7.2 版本的执行时间阈值是 <strong>25ms</strong>，过期 key 比例设定值是 **10%**。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define ACTIVE_EXPIRE_CYCLE_FAST_DURATION <span class="number">1000</span> <span class="comment">/* Microseconds. */</span></span><br><span class="line">#define ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC <span class="number">25</span> <span class="comment">/* Max % of CPU to use. */</span></span><br><span class="line">#define ACTIVE_EXPIRE_CYCLE_ACCEPTABLE_STALE <span class="number">10</span> <span class="comment">/* % of stale keys after which</span></span><br><span class="line"><span class="comment">                                                   we do extra efforts. */</span></span><br></pre></td></tr></table></figure>

<p><strong>每次随机抽查数量是多少？</strong></p>
<p><code>expire.c</code>中定义了每次随机抽查的数量，Redis 7.2 版本为 20 ，也就是说每次会随机选择 20 个设置了过期时间的 key 判断是否过期。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ACTIVE_EXPIRE_CYCLE_KEYS_PER_LOOP 20 <span class="comment">/* Keys for each DB loop. */</span></span></span><br></pre></td></tr></table></figure>

<p><strong>如何控制定期删除的执行频率？</strong></p>
<p>在 Redis 中，定期删除的频率是由 <strong>hz</strong> 参数控制的。hz 默认为 10，代表每秒执行 10 次，也就是每秒钟进行 10 次尝试来查找并删除过期的 key。</p>
<p>hz 的取值范围为 1~500。增大 hz 参数的值会提升定期删除的频率。如果你想要更频繁地执行定期删除任务，可以适当增加 hz 的值，但这会加 CPU 的使用率。根据 Redis 官方建议，hz 的值不建议超过 100，对于大部分用户使用默认的 10 就足够了。</p>
<p>下面是 hz 参数的官方注释，我翻译了其中的重要信息（Redis 7.2 版本）。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/redis.conf-hz.png" alt="redis.conf 对于 hz 的注释"></p>
<p>类似的参数还有一个 <strong>dynamic-hz</strong>，这个参数开启之后 Redis 就会在 hz 的基础上动态计算一个值。Redis 提供并默认启用了使用自适应 hz 值的能力，</p>
<p>这两个参数都在 Redis 配置文件 <code>redis.conf</code>中：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认为 10</span></span><br><span class="line"><span class="attr">hz</span> <span class="string">10</span></span><br><span class="line"><span class="comment"># 默认开启</span></span><br><span class="line"><span class="attr">dynamic-hz</span> <span class="string">yes</span></span><br></pre></td></tr></table></figure>

<p>多提一嘴，除了定期删除过期 key 这个定期任务之外，还有一些其他定期任务例如关闭超时的客户端连接、更新统计信息，这些定期任务的执行频率也是通过 hz 参数决定。</p>
<p><strong>为什么定期删除不是把所有过期 key 都删除呢？</strong></p>
<p>这样会对性能造成太大的影响。如果我们 key 数量非常庞大的话，挨个遍历检查是非常耗时的，会严重影响性能。Redis 设计这种策略的目的是为了平衡内存和性能。</p>
<p><strong>为什么 key 过期之后不立马把它删掉呢？这样不是会浪费很多内存空间吗？</strong></p>
<p>因为不太好办到，或者说这种删除方式的成本太高了。假如我们使用延迟队列作为删除策略，这样存在下面这些问题：</p>
<ol>
<li>队列本身的开销可能很大：key 多的情况下，一个延迟队列可能无法容纳。</li>
<li>维护延迟队列太麻烦：修改 key 的过期时间就需要调整期在延迟队列中的位置，并且，还需要引入并发控制。</li>
</ol>
<h3 id="大量-key-集中过期怎么办？"><a href="#大量-key-集中过期怎么办？" class="headerlink" title="大量 key 集中过期怎么办？"></a>大量 key 集中过期怎么办？</h3><p>当 Redis 中存在大量 key 在同一时间点集中过期时，可能会导致以下问题：</p>
<ul>
<li><strong>请求延迟增加：</strong> Redis 在处理过期 key 时需要消耗 CPU 资源，如果过期 key 数量庞大，会导致 Redis 实例的 CPU 占用率升高，进而影响其他请求的处理速度，造成延迟增加。</li>
<li><strong>内存占用过高：</strong> 过期的 key 虽然已经失效，但在 Redis 真正删除它们之前，仍然会占用内存空间。如果过期 key 没有及时清理，可能会导致内存占用过高，甚至引发内存溢出。</li>
</ul>
<p>为了避免这些问题，可以采取以下方案：</p>
<ol>
<li><strong>尽量避免 key 集中过期</strong>: 在设置键的过期时间时尽量随机一点。</li>
<li><strong>开启 lazy free 机制</strong>: 修改 <code>redis.conf</code> 配置文件，将 <code>lazyfree-lazy-expire</code> 参数设置为 <code>yes</code>，即可开启 lazy free 机制。开启 lazy free 机制后，Redis 会在后台异步删除过期的 key，不会阻塞主线程的运行，从而降低对 Redis 性能的影响。</li>
</ol>
<h3 id="Redis-内存淘汰策略了解么？"><a href="#Redis-内存淘汰策略了解么？" class="headerlink" title="Redis 内存淘汰策略了解么？"></a>Redis 内存淘汰策略了解么？</h3><blockquote>
<p>相关问题：MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据?</p>
</blockquote>
<p>Redis 的内存淘汰策略只有在运行内存达到了配置的最大内存阈值时才会触发，这个阈值是通过<code>redis.conf</code>的<code>maxmemory</code>参数来定义的。64 位操作系统下，<code>maxmemory</code> 默认为 0 ，表示不限制内存大小。32 位操作系统下，默认的最大内存值是 3GB。</p>
<p>你可以使用命令 <code>config get maxmemory</code> 来查看 <code>maxmemory</code>的值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; config get maxmemory</span><br><span class="line">maxmemory</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>Redis 提供了 6 种内存淘汰策略：</p>
<ol>
<li><strong>volatile-lru（least recently used）</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选最近最少使用的数据淘汰。</li>
<li><strong>volatile-ttl</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选将要过期的数据淘汰。</li>
<li><strong>volatile-random</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中任意选择数据淘汰。</li>
<li><strong>allkeys-lru（least recently used）</strong>：从数据集（<code>server.db[i].dict</code>）中移除最近最少使用的数据淘汰。</li>
<li><strong>allkeys-random</strong>：从数据集（<code>server.db[i].dict</code>）中任意选择数据淘汰。</li>
<li><strong>no-eviction</strong>（默认内存淘汰策略）：禁止驱逐数据，当内存不足以容纳新写入数据时，新写入操作会报错。</li>
</ol>
<p>4.0 版本后增加以下两种：</p>
<ol start="7">
<li><strong>volatile-lfu（least frequently used）</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选最不经常使用的数据淘汰。</li>
<li><strong>allkeys-lfu（least frequently used）</strong>：从数据集（<code>server.db[i].dict</code>）中移除最不经常使用的数据淘汰。</li>
</ol>
<p><code>allkeys-xxx</code> 表示从所有的键值中淘汰数据，而 <code>volatile-xxx</code> 表示从设置了过期时间的键值中淘汰数据。</p>
<p><code>config.c</code>中定义了内存淘汰策略的枚举数组：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">configEnum maxmemory_policy_enum[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;volatile-lru&quot;</span>, MAXMEMORY_VOLATILE_LRU&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;volatile-lfu&quot;</span>, MAXMEMORY_VOLATILE_LFU&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;volatile-random&quot;</span>,MAXMEMORY_VOLATILE_RANDOM&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;volatile-ttl&quot;</span>,MAXMEMORY_VOLATILE_TTL&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;allkeys-lru&quot;</span>,MAXMEMORY_ALLKEYS_LRU&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;allkeys-lfu&quot;</span>,MAXMEMORY_ALLKEYS_LFU&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;allkeys-random&quot;</span>,MAXMEMORY_ALLKEYS_RANDOM&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;noeviction&quot;</span>,MAXMEMORY_NO_EVICTION&#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="number">0</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>你可以使用 <code>config get maxmemory-policy</code> 命令来查看当前 Redis 的内存淘汰策略。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; config get maxmemory-policy</span><br><span class="line">maxmemory-policy</span><br><span class="line">noeviction</span><br></pre></td></tr></table></figure>

<p>可以通过<code>config set maxmemory-policy 内存淘汰策略</code> 命令修改内存淘汰策略，立即生效，但这种方式重启 Redis 之后就失效了。修改 <code>redis.conf</code> 中的 <code>maxmemory-policy</code> 参数不会因为重启而失效，不过，需要重启之后修改才能生效。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">maxmemory-policy</span> <span class="string">noeviction</span></span><br></pre></td></tr></table></figure>

<p>关于淘汰策略的详细说明可以参考 Redis 官方文档：<a href="https://redis.io/docs/reference/eviction/">https://redis.io/docs/reference/eviction/</a>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《Redis 开发与运维》</li>
<li>《Redis 设计与实现》</li>
<li>《Redis 核心原理与实战》</li>
<li>Redis 命令手册：<a href="https://www.redis.com.cn/commands.html">https://www.redis.com.cn/commands.html</a></li>
<li>RedisSearch 终极使用指南，你值得拥有！：<a href="https://mp.weixin.qq.com/s/FA4XVAXJksTOHUXMsayy2g">https://mp.weixin.qq.com/s/FA4XVAXJksTOHUXMsayy2g</a></li>
<li>WHY Redis choose single thread (vs multi threads): <a href="https://medium.com/@jychen7/sharing-redis-single-thread-vs-multi-threads-5870bd44d153">https:&#x2F;&#x2F;medium.com&#x2F;@jychen7&#x2F;sharing-redis-single-thread-vs-multi-threads-5870bd44d153</a></li>
</ul>
<!-- @include: @article-footer.snippet.md -->

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2024/08/05/kafka-questions-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/08/05/kafka-questions-01/" itemprop="url">Kafka常见问题总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-08-05T20:08:19+08:00">
                2024-08-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" itemprop="url" rel="index">
                    <span itemprop="name">消息队列</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2024/08/05/kafka-questions-01/" class="leancloud_visitors" data-flag-title="Kafka常见问题总结">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  6.5k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  24 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Kafka-基础"><a href="#Kafka-基础" class="headerlink" title="Kafka 基础"></a>Kafka 基础</h2><h3 id="Kafka-是什么？主要应用场景有哪些？"><a href="#Kafka-是什么？主要应用场景有哪些？" class="headerlink" title="Kafka 是什么？主要应用场景有哪些？"></a>Kafka 是什么？主要应用场景有哪些？</h3><p>Kafka 是一个分布式流式处理平台。这到底是什么意思呢？</p>
<p>流平台具有三个关键功能：</p>
<ol>
<li><strong>消息队列</strong>：发布和订阅消息流，这个功能类似于消息队列，这也是 Kafka 也被归类为消息队列的原因。</li>
<li><strong>容错的持久方式存储记录消息流</strong>：Kafka 会把消息持久化到磁盘，有效避免了消息丢失的风险。</li>
<li><strong>流式处理平台：</strong> 在消息发布的时候进行处理，Kafka 提供了一个完整的流式处理类库。</li>
</ol>
<p>Kafka 主要有两大应用场景：</p>
<ol>
<li><strong>消息队列</strong>：建立实时流数据管道，以可靠地在系统或应用程序之间获取数据。</li>
<li><strong>数据处理：</strong> 构建实时的流数据处理程序来转换或处理数据流。</li>
</ol>
<h3 id="和其他消息队列相比-Kafka-的优势在哪里？"><a href="#和其他消息队列相比-Kafka-的优势在哪里？" class="headerlink" title="和其他消息队列相比,Kafka 的优势在哪里？"></a>和其他消息队列相比,Kafka 的优势在哪里？</h3><p>我们现在经常提到 Kafka 的时候就已经默认它是一个非常优秀的消息队列了，我们也会经常拿它跟 RocketMQ、RabbitMQ 对比。我觉得 Kafka 相比其他消息队列主要的优势如下：</p>
<ol>
<li><strong>极致的性能</strong>：基于 Scala 和 Java 语言开发，设计中大量使用了批量处理和异步的思想，最高可以每秒处理千万级别的消息。</li>
<li><strong>生态系统兼容性无可匹敌</strong>：Kafka 与周边生态系统的兼容性是最好的没有之一，尤其在大数据和流计算领域。</li>
</ol>
<p>实际上在早期的时候 Kafka 并不是一个合格的消息队列，早期的 Kafka 在消息队列领域就像是一个衣衫褴褛的孩子一样，功能不完备并且有一些小问题比如丢失消息、不保证消息可靠性等等。当然，这也和 LinkedIn 最早开发 Kafka 用于处理海量的日志有很大关系，哈哈哈，人家本来最开始就不是为了作为消息队列滴，谁知道后面误打误撞在消息队列领域占据了一席之地。</p>
<p>随着后续的发展，这些短板都被 Kafka 逐步修复完善。所以，<strong>Kafka 作为消息队列不可靠这个说法已经过时！</strong></p>
<h3 id="队列模型了解吗？Kafka-的消息模型知道吗？"><a href="#队列模型了解吗？Kafka-的消息模型知道吗？" class="headerlink" title="队列模型了解吗？Kafka 的消息模型知道吗？"></a>队列模型了解吗？Kafka 的消息模型知道吗？</h3><blockquote>
<p>题外话：早期的 JMS 和 AMQP 属于消息服务领域权威组织所做的相关的标准，我在 <a href="https://github.com/Snailclimb/JavaGuide">JavaGuide</a>的 <a href="https://github.com/Snailclimb/JavaGuide#%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E4%B8%AD%E9%97%B4%E4%BB%B6">《消息队列其实很简单》</a>这篇文章中介绍过。但是，这些标准的进化跟不上消息队列的演进速度，这些标准实际上已经属于废弃状态。所以，可能存在的情况是：不同的消息队列都有自己的一套消息模型。</p>
</blockquote>
<h4 id="队列模型：早期的消息模型"><a href="#队列模型：早期的消息模型" class="headerlink" title="队列模型：早期的消息模型"></a>队列模型：早期的消息模型</h4><p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/%E9%98%9F%E5%88%97%E6%A8%A1%E5%9E%8B23.png" alt="队列模型"></p>
<p><strong>使用队列（Queue）作为消息通信载体，满足生产者与消费者模式，一条消息只能被一个消费者使用，未被消费的消息在队列中保留直到被消费或超时。</strong> 比如：我们生产者发送 100 条消息的话，两个消费者来消费一般情况下两个消费者会按照消息发送的顺序各自消费一半（也就是你一个我一个的消费。）</p>
<p><strong>队列模型存在的问题：</strong></p>
<p>假如我们存在这样一种情况：我们需要将生产者产生的消息分发给多个消费者，并且每个消费者都能接收到完整的消息内容。</p>
<p>这种情况，队列模型就不好解决了。很多比较杠精的人就说：我们可以为每个消费者创建一个单独的队列，让生产者发送多份。这是一种非常愚蠢的做法，浪费资源不说，还违背了使用消息队列的目的。</p>
<h4 id="发布-订阅模型-Kafka-消息模型"><a href="#发布-订阅模型-Kafka-消息模型" class="headerlink" title="发布-订阅模型:Kafka 消息模型"></a>发布-订阅模型:Kafka 消息模型</h4><p>发布-订阅模型主要是为了解决队列模型存在的问题。</p>
<p><img src="https://oss.javaguide.cn/java-guide-blog/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%9E%8B.png" alt="发布订阅模型"></p>
<p>发布订阅模型（Pub-Sub） 使用<strong>主题（Topic）</strong> 作为消息通信载体，类似于<strong>广播模式</strong>；发布者发布一条消息，该消息通过主题传递给所有的订阅者，<strong>在一条消息广播之后才订阅的用户则是收不到该条消息的</strong>。</p>
<p><strong>在发布 - 订阅模型中，如果只有一个订阅者，那它和队列模型就基本是一样的了。所以说，发布 - 订阅模型在功能层面上是可以兼容队列模型的。</strong></p>
<p><strong>Kafka 采用的就是发布 - 订阅模型。</strong></p>
<blockquote>
<p><strong>RocketMQ 的消息模型和 Kafka 基本是完全一样的。唯一的区别是 Kafka 中没有队列这个概念，与之对应的是 Partition（分区）。</strong></p>
</blockquote>
<h2 id="Kafka-核心概念"><a href="#Kafka-核心概念" class="headerlink" title="Kafka 核心概念"></a>Kafka 核心概念</h2><h3 id="什么是-Producer、Consumer、Broker、Topic、Partition？"><a href="#什么是-Producer、Consumer、Broker、Topic、Partition？" class="headerlink" title="什么是 Producer、Consumer、Broker、Topic、Partition？"></a>什么是 Producer、Consumer、Broker、Topic、Partition？</h3><p>Kafka 将生产者发布的消息发送到 <strong>Topic（主题）</strong> 中，需要这些消息的消费者可以订阅这些 <strong>Topic（主题）</strong>，如下图所示：</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue20210507200944439.png"></p>
<p>上面这张图也为我们引出了，Kafka 比较重要的几个概念：</p>
<ol>
<li><strong>Producer（生产者）</strong> : 产生消息的一方。</li>
<li><strong>Consumer（消费者）</strong> : 消费消息的一方。</li>
<li><strong>Broker（代理）</strong> : 可以看作是一个独立的 Kafka 实例。多个 Kafka Broker 组成一个 Kafka Cluster。</li>
</ol>
<p>同时，你一定也注意到每个 Broker 中又包含了 Topic 以及 Partition 这两个重要的概念：</p>
<ul>
<li><strong>Topic（主题）</strong> : Producer 将消息发送到特定的主题，Consumer 通过订阅特定的 Topic(主题) 来消费消息。</li>
<li><strong>Partition（分区）</strong> : Partition 属于 Topic 的一部分。一个 Topic 可以有多个 Partition ，并且同一 Topic 下的 Partition 可以分布在不同的 Broker 上，这也就表明一个 Topic 可以横跨多个 Broker 。这正如我上面所画的图一样。</li>
</ul>
<blockquote>
<p>划重点：<strong>Kafka 中的 Partition（分区） 实际上可以对应成为消息队列中的队列。这样是不是更好理解一点？</strong></p>
</blockquote>
<h3 id="Kafka-的多副本机制了解吗？带来了什么好处？"><a href="#Kafka-的多副本机制了解吗？带来了什么好处？" class="headerlink" title="Kafka 的多副本机制了解吗？带来了什么好处？"></a>Kafka 的多副本机制了解吗？带来了什么好处？</h3><p>还有一点我觉得比较重要的是 Kafka 为分区（Partition）引入了多副本（Replica）机制。分区（Partition）中的多个副本之间会有一个叫做 leader 的家伙，其他副本称为 follower。我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。</p>
<blockquote>
<p>生产者和消费者只与 leader 副本交互。你可以理解为其他副本只是 leader 副本的拷贝，它们的存在只是为了保证消息存储的安全性。当 leader 副本发生故障时会从 follower 中选举出一个 leader,但是 follower 中如果有和 leader 同步程度达不到要求的参加不了 leader 的竞选。</p>
</blockquote>
<p><strong>Kafka 的多分区（Partition）以及多副本（Replica）机制有什么好处呢？</strong></p>
<ol>
<li>Kafka 通过给特定 Topic 指定多个 Partition, 而各个 Partition 可以分布在不同的 Broker 上, 这样便能提供比较好的并发能力（负载均衡）。</li>
<li>Partition 可以指定对应的 Replica 数, 这也极大地提高了消息存储的安全性, 提高了容灾能力，不过也相应的增加了所需要的存储空间。</li>
</ol>
<h2 id="Zookeeper-和-Kafka"><a href="#Zookeeper-和-Kafka" class="headerlink" title="Zookeeper 和 Kafka"></a>Zookeeper 和 Kafka</h2><h3 id="Zookeeper-在-Kafka-中的作用是什么？"><a href="#Zookeeper-在-Kafka-中的作用是什么？" class="headerlink" title="Zookeeper 在 Kafka 中的作用是什么？"></a>Zookeeper 在 Kafka 中的作用是什么？</h3><blockquote>
<p>要想搞懂 zookeeper 在 Kafka 中的作用 一定要自己搭建一个 Kafka 环境然后自己进 zookeeper 去看一下有哪些文件夹和 Kafka 有关，每个节点又保存了什么信息。 一定不要光看不实践，这样学来的也终会忘记！这部分内容参考和借鉴了这篇文章：<a href="https://www.jianshu.com/p/a036405f989c">https://www.jianshu.com/p/a036405f989c</a> 。</p>
</blockquote>
<p>下图就是我的本地 Zookeeper ，它成功和我本地的 Kafka 关联上（以下文件夹结构借助 idea 插件 Zookeeper tool 实现）。</p>
<img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/zookeeper-kafka.jpg" style="zoom:50%;" />

<p>ZooKeeper 主要为 Kafka 提供元数据的管理的功能。</p>
<p>从图中我们可以看出，Zookeeper 主要为 Kafka 做了下面这些事情：</p>
<ol>
<li><strong>Broker 注册</strong>：在 Zookeeper 上会有一个专门<strong>用来进行 Broker 服务器列表记录</strong>的节点。每个 Broker 在启动时，都会到 Zookeeper 上进行注册，即到 <code>/brokers/ids</code> 下创建属于自己的节点。每个 Broker 就会将自己的 IP 地址和端口等信息记录到该节点中去</li>
<li><strong>Topic 注册</strong>：在 Kafka 中，同一个<strong>Topic 的消息会被分成多个分区</strong>并将其分布在多个 Broker 上，<strong>这些分区信息及与 Broker 的对应关系</strong>也都是由 Zookeeper 在维护。比如我创建了一个名字为 my-topic 的主题并且它有两个分区，对应到 zookeeper 中会创建这些文件夹：<code>/brokers/topics/my-topic/Partitions/0</code>、<code>/brokers/topics/my-topic/Partitions/1</code></li>
<li><strong>负载均衡</strong>：上面也说过了 Kafka 通过给特定 Topic 指定多个 Partition, 而各个 Partition 可以分布在不同的 Broker 上, 这样便能提供比较好的并发能力。 对于同一个 Topic 的不同 Partition，Kafka 会尽力将这些 Partition 分布到不同的 Broker 服务器上。当生产者产生消息后也会尽量投递到不同 Broker 的 Partition 里面。当 Consumer 消费的时候，Zookeeper 可以根据当前的 Partition 数量以及 Consumer 数量来实现动态负载均衡。</li>
<li>……</li>
</ol>
<h3 id="使用-Kafka-能否不引入-Zookeeper"><a href="#使用-Kafka-能否不引入-Zookeeper" class="headerlink" title="使用 Kafka 能否不引入 Zookeeper?"></a>使用 Kafka 能否不引入 Zookeeper?</h3><p>在 Kafka 2.8 之前，Kafka 最被大家诟病的就是其重度依赖于 Zookeeper。在 Kafka 2.8 之后，引入了基于 Raft 协议的 KRaft 模式，不再依赖 Zookeeper，大大简化了 Kafka 的架构，让你可以以一种轻量级的方式来使用 Kafka。</p>
<p>不过，要提示一下：<strong>如果要使用 KRaft 模式的话，建议选择较高版本的 Kafka，因为这个功能还在持续完善优化中。Kafka 3.3.1 版本是第一个将 KRaft（Kafka Raft）共识协议标记为生产就绪的版本。</strong></p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/kafka3.3.1-kraft-production-ready.png"></p>
<h2 id="Kafka-消费顺序、消息丢失和重复消费"><a href="#Kafka-消费顺序、消息丢失和重复消费" class="headerlink" title="Kafka 消费顺序、消息丢失和重复消费"></a>Kafka 消费顺序、消息丢失和重复消费</h2><h3 id="Kafka-如何保证消息的消费顺序？"><a href="#Kafka-如何保证消息的消费顺序？" class="headerlink" title="Kafka 如何保证消息的消费顺序？"></a>Kafka 如何保证消息的消费顺序？</h3><p>我们在使用消息队列的过程中经常有业务场景需要严格保证消息的消费顺序，比如我们同时发了 2 个消息，这 2 个消息对应的操作分别对应的数据库操作是：</p>
<ol>
<li>更改用户会员等级。</li>
<li>根据会员等级计算订单价格。</li>
</ol>
<p>假如这两条消息的消费顺序不一样造成的最终结果就会截然不同。</p>
<p>我们知道 Kafka 中 Partition(分区)是真正保存消息的地方，我们发送的消息都被放在了这里。而我们的 Partition(分区) 又存在于 Topic(主题) 这个概念中，并且我们可以给特定 Topic 指定多个 Partition。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/KafkaTopicPartionsLayout.png"></p>
<p>每次添加消息到 Partition(分区) 的时候都会采用尾加法，如上图所示。 <strong>Kafka 只能为我们保证 Partition(分区) 中的消息有序。</strong></p>
<blockquote>
<p>消息在被追加到 Partition(分区)的时候都会分配一个特定的偏移量（offset）。Kafka 通过偏移量（offset）来保证消息在分区内的顺序性。</p>
</blockquote>
<p>所以，我们就有一种很简单的保证消息消费顺序的方法：<strong>1 个 Topic 只对应一个 Partition</strong>。这样当然可以解决问题，但是破坏了 Kafka 的设计初衷。</p>
<p>Kafka 中发送 1 条消息的时候，可以指定 topic, partition, key,data（数据） 4 个参数。如果你发送消息的时候指定了 Partition 的话，所有消息都会被发送到指定的 Partition。并且，同一个 key 的消息可以保证只发送到同一个 partition，这个我们可以采用表&#x2F;对象的 id 来作为 key 。</p>
<p>总结一下，对于如何保证 Kafka 中消息消费的顺序，有了下面两种方法：</p>
<ol>
<li>1 个 Topic 只对应一个 Partition。</li>
<li>（推荐）发送消息的时候指定 key&#x2F;Partition。</li>
</ol>
<p>当然不仅仅只有上面两种方法，上面两种方法是我觉得比较好理解的，</p>
<h3 id="Kafka-如何保证消息不丢失？"><a href="#Kafka-如何保证消息不丢失？" class="headerlink" title="Kafka 如何保证消息不丢失？"></a>Kafka 如何保证消息不丢失？</h3><h4 id="生产者丢失消息的情况"><a href="#生产者丢失消息的情况" class="headerlink" title="生产者丢失消息的情况"></a>生产者丢失消息的情况</h4><p>生产者(Producer) 调用<code>send</code>方法发送消息之后，消息可能因为网络问题并没有发送过去。</p>
<p>所以，我们不能默认在调用<code>send</code>方法发送消息之后消息发送成功了。为了确定消息是发送成功，我们要判断消息发送的结果。但是要注意的是 Kafka 生产者(Producer) 使用 <code>send</code> 方法发送消息实际上是异步的操作，我们可以通过 <code>get()</code>方法获取调用结果，但是这样也让它变为了同步操作，示例代码如下：</p>
<blockquote>
<p><strong>详细代码见我的这篇文章：<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247486269&idx=2&sn=ec00417ad641dd8c3d145d74cafa09ce&chksm=cea244f6f9d5cde0c8eb233fcc4cf82e11acd06446719a7af55230649863a3ddd95f78d111de&token=1633957262&lang=zh_CN#rd">Kafka 系列第三篇！10 分钟学会如何在 Spring Boot 程序中使用 Kafka 作为消息队列?</a></strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SendResult&lt;String, Object&gt; sendResult = kafkaTemplate.send(topic, o).get();</span><br><span class="line"><span class="keyword">if</span> (sendResult.getRecordMetadata() != <span class="literal">null</span>) &#123;</span><br><span class="line">  logger.info(<span class="string">&quot;生产者成功发送消息到&quot;</span> + sendResult.getProducerRecord().topic() + <span class="string">&quot;-&gt; &quot;</span> + sendRe</span><br><span class="line">              sult.getProducerRecord().value().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是一般不推荐这么做！可以采用为其添加回调函数的形式，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ListenableFuture&lt;SendResult&lt;String, Object&gt;&gt; future = kafkaTemplate.send(topic, o);</span><br><span class="line">future.addCallback(result -&gt; logger.info(<span class="string">&quot;生产者成功发送消息到topic:&#123;&#125; partition:&#123;&#125;的消息&quot;</span>, result.getRecordMetadata().topic(), result.getRecordMetadata().partition()),</span><br><span class="line">        ex -&gt; logger.error(<span class="string">&quot;生产者发送消失败，原因：&#123;&#125;&quot;</span>, ex.getMessage()));</span><br></pre></td></tr></table></figure>

<p>如果消息发送失败的话，我们检查失败的原因之后重新发送即可！</p>
<p>另外，这里推荐为 Producer 的<code>retries</code>（重试次数）设置一个比较合理的值，一般是 3 ，但是为了保证消息不丢失的话一般会设置比较大一点。设置完成之后，当出现网络问题之后能够自动重试消息发送，避免消息丢失。另外，建议还要设置重试间隔，因为间隔太小的话重试的效果就不明显了，网络波动一次你 3 次一下子就重试完了。</p>
<h4 id="消费者丢失消息的情况"><a href="#消费者丢失消息的情况" class="headerlink" title="消费者丢失消息的情况"></a>消费者丢失消息的情况</h4><p>我们知道消息在被追加到 Partition(分区)的时候都会分配一个特定的偏移量（offset）。偏移量（offset)表示 Consumer 当前消费到的 Partition(分区)的所在的位置。Kafka 通过偏移量（offset）可以保证消息在分区内的顺序性。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/kafka-offset.jpg" alt="kafka offset"></p>
<p>当消费者拉取到了分区的某个消息之后，消费者会自动提交了 offset。自动提交的话会有一个问题，试想一下，当消费者刚拿到这个消息准备进行真正消费的时候，突然挂掉了，消息实际上并没有被消费，但是 offset 却被自动提交了。</p>
<p><strong>解决办法也比较粗暴，我们手动关闭自动提交 offset，每次在真正消费完消息之后再自己手动提交 offset 。</strong> 但是，细心的朋友一定会发现，这样会带来消息被重新消费的问题。比如你刚刚消费完消息之后，还没提交 offset，结果自己挂掉了，那么这个消息理论上就会被消费两次。</p>
<h4 id="Kafka-弄丢了消息"><a href="#Kafka-弄丢了消息" class="headerlink" title="Kafka 弄丢了消息"></a>Kafka 弄丢了消息</h4><p>我们知道 Kafka 为分区（Partition）引入了多副本（Replica）机制。分区（Partition）中的多个副本之间会有一个叫做 leader 的家伙，其他副本称为 follower。我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。生产者和消费者只与 leader 副本交互。你可以理解为其他副本只是 leader 副本的拷贝，它们的存在只是为了保证消息存储的安全性。</p>
<p><strong>试想一种情况：假如 leader 副本所在的 broker 突然挂掉，那么就要从 follower 副本重新选出一个 leader ，但是 leader 的数据还有一些没有被 follower 副本的同步的话，就会造成消息丢失。</strong></p>
<p><strong>设置 acks &#x3D; all</strong></p>
<p>解决办法就是我们设置 <strong>acks &#x3D; all</strong>。acks 是 Kafka 生产者(Producer) 很重要的一个参数。</p>
<p>acks 的默认值即为 1，代表我们的消息被 leader 副本接收之后就算被成功发送。当我们配置 <strong>acks &#x3D; all</strong> 表示只有所有 ISR 列表的副本全部收到消息时，生产者才会接收到来自服务器的响应. 这种模式是最高级别的，也是最安全的，可以确保不止一个 Broker 接收到了消息. 该模式的延迟会很高.</p>
<p><strong>设置 replication.factor &gt;&#x3D; 3</strong></p>
<p>为了保证 leader 副本能有 follower 副本能同步消息，我们一般会为 topic 设置 <strong>replication.factor &gt;&#x3D; 3</strong>。这样就可以保证每个 分区(partition) 至少有 3 个副本。虽然造成了数据冗余，但是带来了数据的安全性。</p>
<p><strong>设置 min.insync.replicas &gt; 1</strong></p>
<p>一般情况下我们还需要设置 <strong>min.insync.replicas&gt; 1</strong> ，这样配置代表消息至少要被写入到 2 个副本才算是被成功发送。<strong>min.insync.replicas</strong> 的默认值为 1 ，在实际生产中应尽量避免默认值 1。</p>
<p>但是，为了保证整个 Kafka 服务的高可用性，你需要确保 <strong>replication.factor &gt; min.insync.replicas</strong> 。为什么呢？设想一下假如两者相等的话，只要是有一个副本挂掉，整个分区就无法正常工作了。这明显违反高可用性！一般推荐设置成 <strong>replication.factor &#x3D; min.insync.replicas + 1</strong>。</p>
<p><strong>设置 unclean.leader.election.enable &#x3D; false</strong></p>
<blockquote>
<p><strong>Kafka 0.11.0.0 版本开始 unclean.leader.election.enable 参数的默认值由原来的 true 改为 false</strong></p>
</blockquote>
<p>我们最开始也说了我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。多个 follower 副本之间的消息同步情况不一样，当我们配置了 <strong>unclean.leader.election.enable &#x3D; false</strong> 的话，当 leader 副本发生故障时就不会从 follower 副本中和 leader 同步程度达不到要求的副本中选择出 leader ，这样降低了消息丢失的可能性。</p>
<h3 id="Kafka-如何保证消息不重复消费？"><a href="#Kafka-如何保证消息不重复消费？" class="headerlink" title="Kafka 如何保证消息不重复消费？"></a>Kafka 如何保证消息不重复消费？</h3><p><strong>kafka 出现消息重复消费的原因：</strong></p>
<ul>
<li>服务端侧已经消费的数据没有成功提交 offset（根本原因）。</li>
<li>Kafka 侧 由于服务端处理业务时间长或者网络链接等等原因让 Kafka 认为服务假死，触发了分区 rebalance。</li>
</ul>
<p><strong>解决方案：</strong></p>
<ul>
<li>消费消息服务做幂等校验，比如 Redis 的 set、MySQL 的主键等天然的幂等功能。这种方法最有效。</li>
<li>将 <strong><code>enable.auto.commit</code></strong> 参数设置为 false，关闭自动提交，开发者在代码中手动提交 offset。那么这里会有个问题：<strong>什么时候提交 offset 合适？</strong><ul>
<li>处理完消息再提交：依旧有消息重复消费的风险，和自动提交一样</li>
<li>拉取到消息即提交：会有消息丢失的风险。允许消息延时的场景，一般会采用这种方式。然后，通过定时任务在业务不繁忙（比如凌晨）的时候做数据兜底。</li>
</ul>
</li>
</ul>
<h2 id="Kafka-重试机制"><a href="#Kafka-重试机制" class="headerlink" title="Kafka 重试机制"></a>Kafka 重试机制</h2><p>在 Kafka 如何保证消息不丢失这里，我们提到了 Kafka 的重试机制。由于这部分内容较为重要，我们这里再来详细介绍一下。</p>
<p>网上关于 Spring Kafka 的默认重试机制文章很多，但大多都是过时的，和实际运行结果完全不一样。以下是根据 <a href="https://mvnrepository.com/artifact/org.springframework.kafka/spring-kafka/2.9.3">spring-kafka-2.9.3</a> 源码重新梳理一下。</p>
<h3 id="消费失败会怎么样？"><a href="#消费失败会怎么样？" class="headerlink" title="消费失败会怎么样？"></a>消费失败会怎么样？</h3><p>在消费过程中，当其中一个消息消费异常时，会不会卡住后续队列消息的消费？这样业务岂不是卡住了？</p>
<p>生产者代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  kafkaTemplate.send(KafkaConst.TEST_TOPIC, String.valueOf(i))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者消代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@KafkaListener(topics = &#123;KafkaConst.TEST_TOPIC&#125;,groupId = &quot;apple&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">customer</span><span class="params">(String message)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    log.info(<span class="string">&quot;kafka customer:&#123;&#125;&quot;</span>,message);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> Integer.parseInt(message);</span><br><span class="line">    <span class="keyword">if</span> (n%<span class="number">5</span>==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span>  <span class="title class_">RuntimeException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在默认配置下，当消费异常会进行重试，重试多次后会跳过当前消息，继续进行后续消息的消费，不会一直卡在当前消息。下面是一段消费的日志，可以看出当 <code>test-0@95</code> 重试多次后会被跳过。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2023</span>-08-<span class="number">10</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">32.918</span> DEBUG <span class="number">9700</span> --- [ntainer#<span class="number">0</span>-<span class="number">0</span>-C-<span class="number">1</span>] o.s.kafka.listener.DefaultErrorHandler   : Skipping seek of: test-<span class="number">0</span>@<span class="number">95</span></span><br><span class="line"><span class="number">2023</span>-08-<span class="number">10</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">32.918</span> TRACE <span class="number">9700</span> --- [ntainer#<span class="number">0</span>-<span class="number">0</span>-C-<span class="number">1</span>] o.s.kafka.listener.DefaultErrorHandler   : Seeking: test-<span class="number">0</span> to: <span class="number">96</span></span><br><span class="line"><span class="number">2023</span>-08-<span class="number">10</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">32.918</span>  INFO <span class="number">9700</span> --- [ntainer#<span class="number">0</span>-<span class="number">0</span>-C-<span class="number">1</span>] o.a.k.clients.consumer.KafkaConsumer     : [Consumer clientId=consumer-apple-<span class="number">1</span>, groupId=apple] Seeking to offset <span class="number">96</span> <span class="keyword">for</span> partition test-<span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因此，即使某个消息消费异常，Kafka 消费者仍然能够继续消费后续的消息，不会一直卡在当前消息，保证了业务的正常进行。</p>
<h3 id="默认会重试多少次？"><a href="#默认会重试多少次？" class="headerlink" title="默认会重试多少次？"></a>默认会重试多少次？</h3><p>默认配置下，消费异常会进行重试，重试次数是多少, 重试是否有时间间隔？</p>
<p>看源码 <code>FailedRecordTracker</code> 类有个 <code>recovered</code> 函数，返回 Boolean 值判断是否要进行重试，下面是这个函数中判断是否重试的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">recovered</span><span class="params">(ConsumerRecord &lt;&lt; ? , ? &gt; record, Exception exception,</span></span><br><span class="line"><span class="params">    <span class="meta">@Nullable</span> MessageListenerContainer container,</span></span><br><span class="line"><span class="params">    <span class="meta">@Nullable</span> Consumer &lt;&lt; ? , ? &gt; consumer)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.noRetries) &#123;</span><br><span class="line">        <span class="comment">// 不支持重试</span></span><br><span class="line">        attemptRecovery(record, exception, <span class="literal">null</span>, consumer);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取已经失败的消费记录集合</span></span><br><span class="line">    Map &lt; TopicPartition, FailedRecord &gt; map = <span class="built_in">this</span>.failures.get();</span><br><span class="line">    <span class="keyword">if</span> (map == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.failures.set(<span class="keyword">new</span> <span class="title class_">HashMap</span> &lt; &gt; ());</span><br><span class="line">        map = <span class="built_in">this</span>.failures.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  获取消费记录所在的Topic和Partition</span></span><br><span class="line">    <span class="type">TopicPartition</span> <span class="variable">topicPartition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TopicPartition</span>(record.topic(), record.partition());</span><br><span class="line">    <span class="type">FailedRecord</span> <span class="variable">failedRecord</span> <span class="operator">=</span> getFailedRecordInstance(record, exception, map, topicPartition);</span><br><span class="line">    <span class="comment">// 通知注册的重试监听器，消息投递失败</span></span><br><span class="line">    <span class="built_in">this</span>.retryListeners.forEach(rl - &gt;</span><br><span class="line">        rl.failedDelivery(record, exception, failedRecord.getDeliveryAttempts().get()));</span><br><span class="line">    <span class="comment">// 获取下一次重试的时间间隔</span></span><br><span class="line">   <span class="type">long</span> <span class="variable">nextBackOff</span> <span class="operator">=</span> failedRecord.getBackOffExecution().nextBackOff();</span><br><span class="line">    <span class="keyword">if</span> (nextBackOff != BackOffExecution.STOP) &#123;</span><br><span class="line">        <span class="built_in">this</span>.backOffHandler.onNextBackOff(container, exception, nextBackOff);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        attemptRecovery(record, exception, topicPartition, consumer);</span><br><span class="line">        map.remove(topicPartition);</span><br><span class="line">        <span class="keyword">if</span> (map.isEmpty()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.failures.remove();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中， <code>BackOffExecution.STOP</code> 的值为 -1。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BackOffExecution</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">long</span> <span class="variable">STOP</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">	<span class="type">long</span> <span class="title function_">nextBackOff</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>nextBackOff</code> 的值调用 <code>BackOff</code> 类的 <code>nextBackOff()</code> 函数。如果当前执行次数大于最大执行次数则返回 <code>STOP</code>，既超过这个最大执行次数后才会停止重试。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">nextBackOff</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.currentAttempts++;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.currentAttempts &lt;= getMaxAttempts()) &#123;</span><br><span class="line">    <span class="keyword">return</span> getInterval();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> STOP;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么这个 <code>getMaxAttempts</code> 的值又是多少呢？回到最开始，当执行出错会进入 <code>DefaultErrorHandler</code> 。<code>DefaultErrorHandler</code> 默认的构造函数是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">DefaultErrorHandler</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>(<span class="literal">null</span>, SeekUtils.DEFAULT_BACK_OFF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SeekUtils.DEFAULT_BACK_OFF</code> 定义的是:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_MAX_FAILURES</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">FixedBackOff</span> <span class="variable">DEFAULT_BACK_OFF</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FixedBackOff</span>(<span class="number">0</span>, DEFAULT_MAX_FAILURES - <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p><code>DEFAULT_MAX_FAILURES</code> 的值是 10，<code>currentAttempts</code> 从 0 到 9，所以总共会执行 10 次，每次重试的时间间隔为 0。</p>
<p>最后，简单总结一下：Kafka 消费者在默认配置下会进行最多 10 次 的重试，每次重试的时间间隔为 0，即立即进行重试。如果在 10 次重试后仍然无法成功消费消息，则不再进行重试，消息将被视为消费失败。</p>
<h3 id="如何自定义重试次数以及时间间隔"><a href="#如何自定义重试次数以及时间间隔" class="headerlink" title="如何自定义重试次数以及时间间隔?"></a>如何自定义重试次数以及时间间隔?</h3><p>从上面的代码可以知道，默认错误处理器的重试次数以及时间间隔是由 <code>FixedBackOff</code> 控制的，<code>FixedBackOff</code> 是 <code>DefaultErrorHandler</code> 初始化时默认的。所以自定义重试次数以及时间间隔，只需要在 <code>DefaultErrorHandler</code> 初始化的时候传入自定义的 <code>FixedBackOff</code> 即可。重新实现一个 <code>KafkaListenerContainerFactory</code> ，调用 <code>setCommonErrorHandler</code> 设置新的自定义的错误处理器就可以实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> KafkaListenerContainerFactory <span class="title function_">kafkaListenerContainerFactory</span><span class="params">(ConsumerFactory&lt;String, String&gt; consumerFactory)</span> &#123;</span><br><span class="line">    <span class="type">ConcurrentKafkaListenerContainerFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcurrentKafkaListenerContainerFactory</span>();</span><br><span class="line">    <span class="comment">// 自定义重试时间间隔以及次数</span></span><br><span class="line">    <span class="type">FixedBackOff</span> <span class="variable">fixedBackOff</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FixedBackOff</span>(<span class="number">1000</span>, <span class="number">5</span>);</span><br><span class="line">    factory.setCommonErrorHandler(<span class="keyword">new</span> <span class="title class_">DefaultErrorHandler</span>(fixedBackOff));</span><br><span class="line">    factory.setConsumerFactory(consumerFactory);</span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="如何在重试失败后进行告警"><a href="#如何在重试失败后进行告警" class="headerlink" title="如何在重试失败后进行告警?"></a>如何在重试失败后进行告警?</h3><p>自定义重试失败后逻辑，需要手动实现，以下是一个简单的例子，重写 <code>DefaultErrorHandler</code> 的 <code>handleRemaining</code> 函数，加上自定义的告警等操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelErrorHandler</span> <span class="keyword">extends</span> <span class="title class_">DefaultErrorHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DelErrorHandler</span><span class="params">(FixedBackOff backOff)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="literal">null</span>,backOff);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRemaining</span><span class="params">(Exception thrownException, List&lt;ConsumerRecord&lt;?, ?&gt;&gt; records, Consumer&lt;?, ?&gt; consumer, MessageListenerContainer container)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.handleRemaining(thrownException, records, consumer, container);</span><br><span class="line">        log.info(<span class="string">&quot;重试多次失败&quot;</span>);</span><br><span class="line">        <span class="comment">// 自定义操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>DefaultErrorHandler</code> 只是默认的一个错误处理器，Spring Kafka 还提供了 <code>CommonErrorHandler</code> 接口。手动实现 <code>CommonErrorHandler</code> 就可以实现更多的自定义操作，有很高的灵活性。例如根据不同的错误类型，实现不同的重试逻辑以及业务逻辑等。</p>
<h3 id="重试失败后的数据如何再次处理"><a href="#重试失败后的数据如何再次处理" class="headerlink" title="重试失败后的数据如何再次处理?"></a>重试失败后的数据如何再次处理?</h3><p>当达到最大重试次数后，数据会直接被跳过，继续向后进行。当代码修复后，如何重新消费这些重试失败的数据呢？</p>
<p><strong>死信队列（Dead Letter Queue，简称 DLQ）</strong> 是消息中间件中的一种特殊队列。它主要用于处理无法被消费者正确处理的消息，通常是因为消息格式错误、处理失败、消费超时等情况导致的消息被”丢弃”或”死亡”的情况。当消息进入队列后，消费者会尝试处理它。如果处理失败，或者超过一定的重试次数仍无法被成功处理，消息可以发送到死信队列中，而不是被永久性地丢弃。在死信队列中，可以进一步分析、处理这些无法正常消费的消息，以便定位问题、修复错误，并采取适当的措施。</p>
<p><code>@RetryableTopic</code> 是 Spring Kafka 中的一个注解,它用于配置某个 Topic 支持消息重试，更推荐使用这个注解来完成重试。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重试 5 次，重试间隔 100 毫秒,最大间隔 1 秒</span></span><br><span class="line"><span class="meta">@RetryableTopic(</span></span><br><span class="line"><span class="meta">        attempts = &quot;5&quot;,</span></span><br><span class="line"><span class="meta">        backoff = @Backoff(delay = 100, maxDelay = 1000)</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@KafkaListener(topics = &#123;KafkaConst.TEST_TOPIC&#125;, groupId = &quot;apple&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">customer</span><span class="params">(String message)</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;kafka customer:&#123;&#125;&quot;</span>, message);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> Integer.parseInt(message);</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当达到最大重试次数后，如果仍然无法成功处理消息，消息会被发送到对应的死信队列中。对于死信队列的处理，既可以用 <code>@DltHandler</code> 处理，也可以使用 <code>@KafkaListener</code> 重新消费。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>Kafka 官方文档：<a href="https://kafka.apache.org/documentation/">https://kafka.apache.org/documentation/</a></li>
<li>极客时间—《Kafka 核心技术与实战》第 11 节：无消息丢失配置怎么实现？</li>
</ul>
<!-- @include: @article-footer.snippet.md -->

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><a class="extend next" rel="next" href="/page/3/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.gif"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">240</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">31</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">38</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/JayVae" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.zhihu.com/people/shi-hai-jie-35" target="_blank" title="Zhihu">
                      
                        <i class="fa fa-fw fa-globe"></i>Zhihu</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="wechat" target="_blank" title="Wechat">
                      
                        <i class="fa fa-fw fa-globe"></i>Wechat</a>
                  </span>
                
            </div>
          

		  <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=554191378&auto=1&height=66"></iframe>
		  
          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">史海杰</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">712.5k</span>
  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  







<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    

    







  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("SWULgkVHBjhFp99nBHCr8oHC-gzGzoHsz", "DQQN5XsGzlq3PIf1OSvGvoRR");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
