<!DOCTYPE html>
<html lang="zh-Hans">


<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>
    LinkedHashMap 源码分析 | Jay&#39;s Blog
  </title>
  <meta name="description" content="持续精进">
  
  <meta name="keywords" content="
  Java集合
  ">
  
  <meta name="author" content="史海杰">

  <meta http-equiv="Cache-Control" content="no-transform"/>
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta name="theme-color" content="#1e2327">
  <link rel="apple-touch-icon" href="https://github.githubassets.com/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="180x180" href="https://github.githubassets.com/apple-touch-icon-180x180.png">

  <link rel="icon" type="image/x-icon" href="https://github.githubassets.com/favicon.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet"
        href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  

  

  <script src="//cdnjs.cloudflare.com/ajax/libs/vue/1.0.25-csp/vue.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.11.2/moment.min.js"></script>
<meta name="generator" content="Hexo 7.3.0"></head>

<body id="replica-app">

<nav class="navbar-wrapper">
  <div class="navbar">
    <div class="container clearfix">
      <a href="/" class="navbar-logo"><i class="fa fa-github"></i></a>

      <div class="navbar-search float-left desktop-only">
        <div class="navbar-search-form">
          <label for="gsc-i-id1">This website</label>
          <div id="google-search">
            <gcse:search></gcse:search>
          </div>
        </div>
      </div>

      <ul class="navbar-nav float-left">
        
        <li><a href="/">Archives</a></li>
        
        
        <li><a href="/">Categories</a></li>
        
        
        <li><a href="/">Tags</a></li>
        
        
        <li class="desktop-only"><a href="/atom.xml" target="_blank">RSS</a></li>
        
      </ul>

      <ul class="navbar-nav user-nav float-right desktop-only">
        <li class="user-nav-notification">
          <a><span class="user-nav-unread"></span><i class="fa fa-bell"></i></a>
        </li>
        <li>
          <a><i class="fa fa-plus"></i> <i class="fa fa-caret-down"></i></a>
        </li>
        <li class="user-nav-logo">
          <a><img src="https://octodex.github.com/images/baracktocat.jpg"> <i class="fa fa-caret-down"></i></i></a>
        </li>
      </ul>
    </div>
  </div>
</nav>

<div class="main-container">
  <header class="header-wrapper desktop-only">
  <div class="container header-site-detail">
    <ul class="header-toolbar">
      <li class="clearfix">
        <a href="/" class="header-toolbar-left"><i
                  class="fa fa-file-text"></i> Posts </a>
        <a href="/"
           class="header-toolbar-right"> 201 </a>
      </li>
      <li>
        <a href="/" class="header-toolbar-left"><i
                  class="fa fa-tags"></i> Tags </a>
        <a href="/"
           class="header-toolbar-right"> 28 </a>
      </li>
      <li>
        <a href="/" class="header-toolbar-left"><i
                  class="fa fa-folder-open"></i> Categories </a>
        <a href="/"
           class="header-toolbar-right"> 26 </a>
      </li>
    </ul>
    <h2 class="header-title">
      <i class="fa fa-book text-muted"></i>
      <a href="/">Jay&#39;s Blog</a>
      
      
    </h2>
  </div>

  <div class="container">
    <div class="header-tab-wrapper clearfix">
      <span class="header-tab header-tab-selected"><i class="fa fa-thumbs-o-up"></i> Like</span>
      <span class="header-tab"><i class="fa fa-share-alt"></i> Share</span>
      <span class="header-tab"><i class="fa fa-comments-o"></i> Discussion</span>
      <span class="header-tab"><i class="fa fa-bookmark-o"></i> Bookmark </span>
      <span class="header-tab"><i class="fa fa-smile-o"></i> Smile <i class="fa fa-caret-down"></i></span>
    </div>
  </div>
</header>


<div class="post-container container">
  <h3>
    <i class="fa fa-user-o"></i>
    史海杰

    <span class="post-date float-right" title="{{moment(1619625530000).format('MMM DD, YYYY, h:mm:ss A')}}">
      
          <i class="fa fa-pencil-square-o"></i>
      
      {{moment(1619625530000).fromNow()}}
    </span>
  </h3>

  <article class="post-content">
    <h1>LinkedHashMap 源码分析</h1>
    <h2 id="LinkedHashMap-简介"><a href="#LinkedHashMap-简介" class="headerlink" title="LinkedHashMap 简介"></a>LinkedHashMap 简介</h2><p><code>LinkedHashMap</code> 是 Java 提供的一个集合类，它继承自 <code>HashMap</code>，并在 <code>HashMap</code> 基础上维护一条双向链表，使得具备如下特性:</p>
<ol>
<li>支持遍历时会按照插入顺序有序进行迭代。</li>
<li>支持按照元素访问顺序排序,适用于封装 LRU 缓存工具。</li>
<li>因为内部使用双向链表维护各个节点，所以遍历时的效率和元素个数成正比，相较于和容量成正比的 HashMap 来说，迭代效率会高很多。</li>
</ol>
<p><code>LinkedHashMap</code> 逻辑结构如下图所示，它是在 <code>HashMap</code> 基础上在各个节点之间维护一条双向链表，使得原本散列在不同 bucket 上的节点、链表、红黑树有序关联起来。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/collection/linkhashmap-structure-overview.png" alt="LinkedHashMap 逻辑结构"></p>
<h2 id="LinkedHashMap-使用示例"><a href="#LinkedHashMap-使用示例" class="headerlink" title="LinkedHashMap 使用示例"></a>LinkedHashMap 使用示例</h2><h3 id="插入顺序遍历"><a href="#插入顺序遍历" class="headerlink" title="插入顺序遍历"></a>插入顺序遍历</h3><p>如下所示，我们按照顺序往 <code>LinkedHashMap</code> 添加元素然后进行遍历。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HashMap &lt; String, String &gt; map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span> &lt; &gt; ();</span><br><span class="line">map.put(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;g&quot;</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;r&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;e&quot;</span>, <span class="string">&quot;23&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Map.Entry &lt; String, String &gt; entry: map.entrySet()) &#123;</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot;:&quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a:<span class="number">2</span></span><br><span class="line">g:<span class="number">3</span></span><br><span class="line">r:<span class="number">1</span></span><br><span class="line">e:<span class="number">23</span></span><br></pre></td></tr></table></figure>

<p>可以看出，<code>LinkedHashMap</code> 的迭代顺序是和插入顺序一致的,这一点是 <code>HashMap</code> 所不具备的。</p>
<h3 id="访问顺序遍历"><a href="#访问顺序遍历" class="headerlink" title="访问顺序遍历"></a>访问顺序遍历</h3><p><code>LinkedHashMap</code> 定义了排序模式 <code>accessOrder</code>(boolean 类型，默认为 false)，访问顺序则为 true，插入顺序则为 false。</p>
<p>为了实现访问顺序遍历，我们可以使用传入 <code>accessOrder</code> 属性的 <code>LinkedHashMap</code> 构造方法，并将 <code>accessOrder</code> 设置为 true，表示其具备访问有序性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">LinkedHashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(<span class="number">16</span>, <span class="number">0.75f</span>, <span class="literal">true</span>);</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">&quot;two&quot;</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line">map.put(<span class="number">4</span>, <span class="string">&quot;four&quot;</span>);</span><br><span class="line">map.put(<span class="number">5</span>, <span class="string">&quot;five&quot;</span>);</span><br><span class="line"><span class="comment">//访问元素2,该元素会被移动至链表末端</span></span><br><span class="line">map.get(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//访问元素3,该元素会被移动至链表末端</span></span><br><span class="line">map.get(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot; : &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> : one</span><br><span class="line"><span class="number">4</span> : four</span><br><span class="line"><span class="number">5</span> : five</span><br><span class="line"><span class="number">2</span> : two</span><br><span class="line"><span class="number">3</span> : three</span><br></pre></td></tr></table></figure>

<p>可以看出，<code>LinkedHashMap</code> 的迭代顺序是和访问顺序一致的。</p>
<h3 id="LRU-缓存"><a href="#LRU-缓存" class="headerlink" title="LRU 缓存"></a>LRU 缓存</h3><p>从上一个我们可以了解到通过 <code>LinkedHashMap</code> 我们可以封装一个简易版的 LRU（<strong>L</strong>east <strong>R</strong>ecently <strong>U</strong>sed，最近最少使用） 缓存，确保当存放的元素超过容器容量时，将最近最少访问的元素移除。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/collection/lru-cache.png"></p>
<p>具体实现思路如下：</p>
<ul>
<li>继承 <code>LinkedHashMap</code>;</li>
<li>构造方法中指定 <code>accessOrder</code> 为 true ，这样在访问元素时就会把该元素移动到链表尾部，链表首元素就是最近最少被访问的元素；</li>
<li>重写<code>removeEldestEntry</code> 方法，该方法会返回一个 boolean 值，告知 <code>LinkedHashMap</code> 是否需要移除链表首元素（缓存容量有限）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LRUCache</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(capacity, <span class="number">0.75f</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断size超过容量时返回true，告知LinkedHashMap移除最老的缓存项(即链表的第一个元素)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; capacity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码如下，笔者初始化缓存容量为 3，然后按照次序先后添加 4 个元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LRUCache&lt;Integer, String&gt; cache = <span class="keyword">new</span> <span class="title class_">LRUCache</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">cache.put(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line">cache.put(<span class="number">2</span>, <span class="string">&quot;two&quot;</span>);</span><br><span class="line">cache.put(<span class="number">3</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line">cache.put(<span class="number">4</span>, <span class="string">&quot;four&quot;</span>);</span><br><span class="line">cache.put(<span class="number">5</span>, <span class="string">&quot;five&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    System.out.println(cache.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span></span><br><span class="line"><span class="literal">null</span></span><br><span class="line">three</span><br><span class="line">four</span><br><span class="line">five</span><br></pre></td></tr></table></figure>

<p>从输出结果来看，由于缓存容量为 3 ，因此，添加第 4 个元素时，第 1 个元素会被删除。添加第 5 个元素时，第 2 个元素会被删除。</p>
<h2 id="LinkedHashMap-源码解析"><a href="#LinkedHashMap-源码解析" class="headerlink" title="LinkedHashMap 源码解析"></a>LinkedHashMap 源码解析</h2><h3 id="Node-的设计"><a href="#Node-的设计" class="headerlink" title="Node 的设计"></a>Node 的设计</h3><p>在正式讨论 <code>LinkedHashMap</code> 前，我们先来聊聊 <code>LinkedHashMap</code> 节点 <code>Entry</code> 的设计,我们都知道 <code>HashMap</code> 的 bucket 上的因为冲突转为链表的节点会在符合以下两个条件时会将链表转为红黑树:</p>
<ol>
<li><del>链表上的节点个数达到树化的阈值 7，即<code>TREEIFY_THRESHOLD - 1</code>。</del></li>
<li>bucket 的容量达到最小的树化容量即<code>MIN_TREEIFY_CAPACITY</code>。</li>
</ol>
<blockquote>
<p><strong>🐛 修正（参见：<a href="https://github.com/Snailclimb/JavaGuide/issues/2147">issue#2147</a>）</strong>：</p>
<p>链表上的节点个数达到树化的阈值是 8 而非 7。因为源码的判断是从链表初始元素开始遍历，下标是从 0 开始的，所以判断条件设置为 8-1&#x3D;7，其实是迭代到尾部元素时再判断整个链表长度大于等于 8 才进行树化操作。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/LinkedHashMap-putval-TREEIFY.png"></p>
</blockquote>
<p>而 <code>LinkedHashMap</code> 是在 <code>HashMap</code> 的基础上为 bucket 上的每一个节点建立一条双向链表，这就使得转为红黑树的树节点也需要具备双向链表节点的特性，即每一个树节点都需要拥有两个引用存储前驱节点和后继节点的地址,所以对于树节点类 <code>TreeNode</code> 的设计就是一个比较棘手的问题。</p>
<p>对此我们不妨来看看两者之间节点类的类图，可以看到:</p>
<ol>
<li><code>LinkedHashMap</code> 的节点内部类 <code>Entry</code> 基于 <code>HashMap</code> 的基础上，增加 <code>before</code> 和 <code>after</code> 指针使节点具备双向链表的特性。</li>
<li><code>HashMap</code> 的树节点 <code>TreeNode</code> 继承了具备双向链表特性的 <code>LinkedHashMap</code> 的 <code>Entry</code>。</li>
</ol>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/collection/map-hashmap-linkedhashmap.png" alt="LinkedHashMap 和 HashMap 之间的关系"></p>
<p>很多读者此时就会有这样一个疑问，为什么 <code>HashMap</code> 的树节点 <code>TreeNode</code> 要通过 <code>LinkedHashMap</code> 获取双向链表的特性呢?为什么不直接在 <code>Node</code> 上实现前驱和后继指针呢?</p>
<p>先来回答第一个问题，我们都知道 <code>LinkedHashMap</code> 是在 <code>HashMap</code> 基础上对节点增加双向指针实现双向链表的特性,所以 <code>LinkedHashMap</code> 内部链表转红黑树时，对应的节点会转为树节点 <code>TreeNode</code>,为了保证使用 <code>LinkedHashMap</code> 时树节点具备双向链表的特性，所以树节点 <code>TreeNode</code> 需要继承 <code>LinkedHashMap</code> 的 <code>Entry</code>。</p>
<p>再来说说第二个问题，我们直接在 <code>HashMap</code> 的节点 <code>Node</code> 上直接实现前驱和后继指针,然后 <code>TreeNode</code> 直接继承 <code>Node</code> 获取双向链表的特性为什么不行呢？其实这样做也是可以的。只不过这种做法会使得使用 <code>HashMap</code> 时存储键值对的节点类 <code>Node</code> 多了两个没有必要的引用，占用没必要的内存空间。</p>
<p>所以，为了保证 <code>HashMap</code> 底层的节点类 <code>Node</code> 没有多余的引用，又要保证 <code>LinkedHashMap</code> 的节点类 <code>Entry</code> 拥有存储链表的引用，设计者就让 <code>LinkedHashMap</code> 的节点 <code>Entry</code> 去继承 Node 并增加存储前驱后继节点的引用 <code>before</code>、<code>after</code>，让需要用到链表特性的节点去实现需要的逻辑。然后树节点 <code>TreeNode</code> 再通过继承 <code>Entry</code> 获取 <code>before</code>、<code>after</code> 两个指针。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">HashMap</span>.Node&lt;K,V&gt; &#123;</span><br><span class="line">        Entry&lt;K,V&gt; before, after;</span><br><span class="line">        Entry(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="built_in">super</span>(hash, key, value, next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>但是这样做，不也使得使用 <code>HashMap</code> 时的 <code>TreeNode</code> 多了两个没有必要的引用吗?这不也是一种空间的浪费吗？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">  <span class="comment">//略</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于这个问题,引用作者的一段注释，作者们认为在良好的 <code>hashCode</code> 算法时，<code>HashMap</code> 转红黑树的概率不大。就算转为红黑树变为树节点，也可能会因为移除或者扩容将 <code>TreeNode</code> 变为 <code>Node</code>，所以 <code>TreeNode</code> 的使用概率不算很大，对于这一点资源空间的浪费是可以接受的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Because TreeNodes are about twice the size of regular nodes, we</span><br><span class="line">use them only when bins contain enough nodes to warrant use</span><br><span class="line">(see TREEIFY_THRESHOLD). And when they become too small (due to</span><br><span class="line">removal or resizing) they are converted back to plain bins.  In</span><br><span class="line">usages with well-distributed user hashCodes, tree bins are</span><br><span class="line">rarely used.  Ideally, under random hashCodes, the frequency of</span><br><span class="line">nodes <span class="keyword">in</span> bins follows a Poisson distribution</span><br></pre></td></tr></table></figure>

<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p><code>LinkedHashMap</code> 构造方法有 4 个实现也比较简单，直接调用父类即 <code>HashMap</code> 的构造方法完成初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    accessOrder = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(initialCapacity);</span><br><span class="line">    accessOrder = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    accessOrder = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(<span class="type">int</span> initialCapacity,</span></span><br><span class="line"><span class="params">    <span class="type">float</span> loadFactor,</span></span><br><span class="line"><span class="params">    <span class="type">boolean</span> accessOrder)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    <span class="built_in">this</span>.accessOrder = accessOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们上面也提到了，默认情况下 <code>accessOrder</code> 为 false，如果我们要让 <code>LinkedHashMap</code> 实现键值对按照访问顺序排序(即将最近未访问的元素排在链表首部、最近访问的元素移动到链表尾部)，需要调用第 4 个构造方法将 <code>accessOrder</code> 设置为 true。</p>
<h3 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h3><p><code>get</code> 方法是 <code>LinkedHashMap</code> 增删改查操作中唯一一个重写的方法， <code>accessOrder</code> 为 true 的情况下， 它会在元素查询完成之后，将当前访问的元素移到链表的末尾。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">     Node &lt; K, V &gt; e;</span><br><span class="line">     <span class="comment">//获取key的键值对,若为空直接返回</span></span><br><span class="line">     <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="literal">null</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">     <span class="comment">//若accessOrder为true，则调用afterNodeAccess将当前元素移到链表末尾</span></span><br><span class="line">     <span class="keyword">if</span> (accessOrder)</span><br><span class="line">         afterNodeAccess(e);</span><br><span class="line">     <span class="comment">//返回键值对的值</span></span><br><span class="line">     <span class="keyword">return</span> e.value;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>从源码可以看出，<code>get</code> 的执行步骤非常简单:</p>
<ol>
<li>调用父类即 <code>HashMap</code> 的 <code>getNode</code> 获取键值对，若为空则直接返回。</li>
<li>判断 <code>accessOrder</code> 是否为 true，若为 true 则说明需要保证 <code>LinkedHashMap</code> 的链表访问有序性，执行步骤 3。</li>
<li>调用 <code>LinkedHashMap</code> 重写的 <code>afterNodeAccess</code> 将当前元素添加到链表末尾。</li>
</ol>
<p>关键点在于 <code>afterNodeAccess</code> 方法的实现，这个方法负责将元素移动到链表末尾。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeAccess</span><span class="params">(Node &lt; K, V &gt; e)</span> &#123; <span class="comment">// move node to last</span></span><br><span class="line">    LinkedHashMap.Entry &lt; K, V &gt; last;</span><br><span class="line">    <span class="comment">//如果accessOrder 且当前节点不为链表尾节点</span></span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取当前节点、以及前驱节点和后继节点</span></span><br><span class="line">        LinkedHashMap.Entry &lt; K, V &gt; p =</span><br><span class="line">            (LinkedHashMap.Entry &lt; K, V &gt; ) e, b = p.before, a = p.after;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将当前节点的后继节点指针指向空，使其和后继节点断开联系</span></span><br><span class="line">        p.after = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果前驱节点为空，则说明当前节点是链表的首节点，故将后继节点设置为首节点</span></span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//如果前驱节点不为空，则让前驱节点指向后继节点</span></span><br><span class="line">            b.after = a;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果后继节点不为空，则让后继节点指向前驱节点</span></span><br><span class="line">        <span class="keyword">if</span> (a != <span class="literal">null</span>)</span><br><span class="line">            a.before = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//如果后继节点为空，则说明当前节点在链表最末尾，直接让last 指向前驱节点,这个 else其实 没有意义，因为最开头if已经确保了p不是尾结点了，自然after不会是null</span></span><br><span class="line">            last = b;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果last为空，则说明当前链表只有一个节点p，则将head指向p</span></span><br><span class="line">        <span class="keyword">if</span> (last == <span class="literal">null</span>)</span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//反之让p的前驱指针指向尾节点，再让尾节点的前驱指针指向p</span></span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//tail指向p，自此将节点p移动到链表末尾</span></span><br><span class="line">        tail = p;</span><br><span class="line"></span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码可以看出， <code>afterNodeAccess</code> 方法完成了下面这些操作:</p>
<ol>
<li>如果 <code>accessOrder</code> 为 true 且链表尾部不为当前节点 p，我们则需要将当前节点移到链表尾部。</li>
<li>获取当前节点 p、以及它的前驱节点 b 和后继节点 a。</li>
<li>将当前节点 p 的后继指针设置为 null，使其和后继节点 p 断开联系。</li>
<li>尝试将前驱节点指向后继节点，若前驱节点为空，则说明当前节点 p 就是链表首节点，故直接将后继节点 a 设置为首节点，随后我们再将 p 追加到 a 的末尾。</li>
<li>再尝试让后继节点 a 指向前驱节点 b。</li>
<li>上述操作让前驱节点和后继节点完成关联，并将当前节点 p 独立出来，这一步则是将当前节点 p 追加到链表末端，如果链表末端为空，则说明当前链表只有一个节点 p，所以直接让 head 指向 p 即可。</li>
<li>上述操作已经将 p 成功到达链表末端，最后我们将 tail 指针即指向链表末端的指针指向 p 即可。</li>
</ol>
<p>可以结合这张图理解，展示了 key 为 13 的元素被移动到了链表尾部。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/collection/linkedhashmap-get.png" alt="LinkedHashMap 移动元素 13 到链表尾部"></p>
<p>看不太懂也没关系，知道这个方法的作用就够了，后续有时间再慢慢消化。</p>
<h3 id="remove-方法后置操作——afterNodeRemoval"><a href="#remove-方法后置操作——afterNodeRemoval" class="headerlink" title="remove 方法后置操作——afterNodeRemoval"></a>remove 方法后置操作——afterNodeRemoval</h3><p><code>LinkedHashMap</code> 并没有对 <code>remove</code> 方法进行重写，而是直接继承 <code>HashMap</code> 的 <code>remove</code> 方法，为了保证键值对移除后双向链表中的节点也会同步被移除，<code>LinkedHashMap</code> 重写了 <code>HashMap</code> 的空实现方法 <code>afterNodeRemoval</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">removeNode</span><span class="params">(<span class="type">int</span> hash, Object key, Object value,</span></span><br><span class="line"><span class="params">                               <span class="type">boolean</span> matchValue, <span class="type">boolean</span> movable)</span> &#123;</span><br><span class="line">        <span class="comment">//略</span></span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                                 (value != <span class="literal">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="built_in">this</span>, tab, movable);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                    tab[index] = node.next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p.next = node.next;</span><br><span class="line">                ++modCount;</span><br><span class="line">                --size;</span><br><span class="line">                <span class="comment">//HashMap的removeNode完成元素移除后会调用afterNodeRemoval进行移除后置操作</span></span><br><span class="line">                afterNodeRemoval(node);</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//空实现</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; p)</span> &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到从 <code>HashMap</code> 继承来的 <code>remove</code> 方法内部调用的 <code>removeNode</code> 方法将节点从 bucket 删除后，调用了 <code>afterNodeRemoval</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> &#123; <span class="comment">// unlink</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取当前节点p、以及e的前驱节点b和后继节点a</span></span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">    <span class="comment">//将p的前驱和后继指针都设置为null，使其和前驱、后继节点断开联系</span></span><br><span class="line">        p.before = p.after = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果前驱节点为空，则说明当前节点p是链表首节点，让head指针指向后继节点a即可</span></span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//如果前驱节点b不为空，则让b直接指向后继节点a</span></span><br><span class="line">            b.after = a;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果后继节点为空，则说明当前节点p在链表末端，所以直接让tail指针指向前驱节点a即可</span></span><br><span class="line">        <span class="keyword">if</span> (a == <span class="literal">null</span>)</span><br><span class="line">            tail = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//反之后继节点的前驱指针直接指向前驱节点</span></span><br><span class="line">            a.before = b;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>从源码可以看出， <code>afterNodeRemoval</code> 方法的整体操作就是让当前节点 p 和前驱节点、后继节点断开联系，等待 gc 回收，整体步骤为:</p>
<ol>
<li>获取当前节点 p、以及 p 的前驱节点 b 和后继节点 a。</li>
<li>让当前节点 p 和其前驱、后继节点断开联系。</li>
<li>尝试让前驱节点 b 指向后继节点 a，若 b 为空则说明当前节点 p 在链表首部，我们直接将 head 指向后继节点 a 即可。</li>
<li>尝试让后继节点 a 指向前驱节点 b，若 a 为空则说明当前节点 p 在链表末端，所以直接让 tail 指针指向前驱节点 b 即可。</li>
</ol>
<p>可以结合这张图理解，展示了 key 为 13 的元素被删除，也就是从链表中移除了这个元素。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/collection/linkedhashmap-remove.png" alt="LinkedHashMap 删除元素 13"></p>
<p>看不太懂也没关系，知道这个方法的作用就够了，后续有时间再慢慢消化。</p>
<h3 id="put-方法后置操作——afterNodeInsertion"><a href="#put-方法后置操作——afterNodeInsertion" class="headerlink" title="put 方法后置操作——afterNodeInsertion"></a>put 方法后置操作——afterNodeInsertion</h3><p>同样的 <code>LinkedHashMap</code> 并没有实现插入方法，而是直接继承 <code>HashMap</code> 的所有插入方法交由用户使用，但为了维护双向链表访问的有序性，它做了这样两件事:</p>
<ol>
<li>重写 <code>afterNodeAccess</code>(上文提到过),如果当前被插入的 key 已存在与 <code>map</code> 中，因为 <code>LinkedHashMap</code> 的插入操作会将新节点追加至链表末尾，所以对于存在的 key 则调用 <code>afterNodeAccess</code> 将其放到链表末端。</li>
<li>重写了 <code>HashMap</code> 的 <code>afterNodeInsertion</code> 方法，当 <code>removeEldestEntry</code> 返回 true 时，会将链表首节点移除。</li>
</ol>
<p>这一点我们可以在 <code>HashMap</code> 的插入操作核心方法 <code>putVal</code> 中看到。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                   <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">          <span class="comment">//略</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                 <span class="comment">//如果当前的key在map中存在，则调用afterNodeAccess</span></span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">         <span class="comment">//调用插入后置方法，该方法被LinkedHashMap重写</span></span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上述步骤的源码上文已经解释过了，所以这里我们着重了解一下 <code>afterNodeInsertion</code> 的工作流程，假设我们的重写了 <code>removeEldestEntry</code>，当链表 <code>size</code> 超过 <code>capacity</code> 时，就返回 true。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断size超过容量时返回true，告知LinkedHashMap移除最老的缓存项(即链表的第一个元素)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry &lt; K, V &gt; eldest)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> size() &gt; capacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下图为例，假设笔者最后新插入了一个不存在的节点 19,假设 <code>capacity</code> 为 4，所以 <code>removeEldestEntry</code> 返回 true，我们要将链表首节点移除。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/collection/linkedhashmap-after-insert-1.png" alt="LinkedHashMap 中插入新元素 19"></p>
<p>移除的步骤很简单，查看链表首节点是否存在，若存在则断开首节点和后继节点的关系，并让首节点指针指向下一节点，所以 head 指针指向了 12，节点 10 成为没有任何引用指向的空对象，等待 GC。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/collection/linkedhashmap-after-insert-2.png" alt="LinkedHashMap 中插入新元素 19"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeInsertion</span><span class="params">(<span class="type">boolean</span> evict)</span> &#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">        <span class="comment">//如果evict为true且队首元素不为空以及removeEldestEntry返回true，则说明我们需要最老的元素(即在链表首部的元素)移除。</span></span><br><span class="line">        <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="literal">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">          <span class="comment">//获取链表首部的键值对的key</span></span><br><span class="line">            <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> first.key;</span><br><span class="line">            <span class="comment">//调用removeNode将元素从HashMap的bucket中移除，并和LinkedHashMap的双向链表断开，等待gc回收</span></span><br><span class="line">            removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>从源码可以看出， <code>afterNodeInsertion</code> 方法完成了下面这些操作:</p>
<ol>
<li>判断 <code>eldest</code> 是否为 true，只有为 true 才能说明可能需要将最年长的键值对(即链表首部的元素)进行移除，具体是否具体要进行移除，还得确定链表是否为空<code>((first = head) != null)</code>，以及 <code>removeEldestEntry</code> 方法是否返回 true，只有这两个方法返回 true 才能确定当前链表不为空，且链表需要进行移除操作了。</li>
<li>获取链表第一个元素的 key。</li>
<li>调用 <code>HashMap</code> 的 <code>removeNode</code> 方法，该方法我们上文提到过，它会将节点从 <code>HashMap</code> 的 bucket 中移除，并且 <code>LinkedHashMap</code> 还重写了 <code>removeNode</code> 中的 <code>afterNodeRemoval</code> 方法，所以这一步将通过调用 <code>removeNode</code> 将元素从 <code>HashMap</code> 的 bucket 中移除，并和 <code>LinkedHashMap</code> 的双向链表断开，等待 gc 回收。</li>
</ol>
<h2 id="LinkedHashMap-和-HashMap-遍历性能比较"><a href="#LinkedHashMap-和-HashMap-遍历性能比较" class="headerlink" title="LinkedHashMap 和 HashMap 遍历性能比较"></a>LinkedHashMap 和 HashMap 遍历性能比较</h2><p><code>LinkedHashMap</code> 维护了一个双向链表来记录数据插入的顺序，因此在迭代遍历生成的迭代器的时候，是按照双向链表的路径进行遍历的。这一点相比于 <code>HashMap</code> 那种遍历整个 bucket 的方式来说，高效许多。</p>
<p>这一点我们可以从两者的迭代器中得以印证，先来看看 <code>HashMap</code> 的迭代器，可以看到 <code>HashMap</code> 迭代键值对时会用到一个 <code>nextNode</code> 方法，该方法会返回 next 指向的下一个元素，并会从 next 开始遍历 bucket 找到下一个 bucket 中不为空的元素 Node。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">EntryIterator</span> <span class="keyword">extends</span> <span class="title class_">HashIterator</span></span><br><span class="line"><span class="keyword">implements</span> <span class="title class_">Iterator</span> &lt; Map.Entry &lt; K, V &gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Map.Entry &lt; K,</span><br><span class="line">    V &gt; next() &#123;</span><br><span class="line">        <span class="keyword">return</span> nextNode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取下一个Node</span></span><br><span class="line"><span class="keyword">final</span> Node &lt; K, V &gt; nextNode() &#123;</span><br><span class="line">    Node &lt; K, V &gt; [] t;</span><br><span class="line">    <span class="comment">//获取下一个元素next</span></span><br><span class="line">    Node &lt; K, V &gt; e = next;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="comment">//将next指向bucket中下一个不为空的Node</span></span><br><span class="line">    <span class="keyword">if</span> ((next = (current = e).next) == <span class="literal">null</span> &amp;&amp; (t = table) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比之下 <code>LinkedHashMap</code> 的迭代器则是直接使用通过 <code>after</code> 指针快速定位到当前节点的后继节点，简洁高效许多。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">LinkedEntryIterator</span> <span class="keyword">extends</span> <span class="title class_">LinkedHashIterator</span></span><br><span class="line"><span class="keyword">implements</span> <span class="title class_">Iterator</span> &lt; Map.Entry &lt; K, V &gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Map.Entry &lt; K,</span><br><span class="line">    V &gt; next() &#123;</span><br><span class="line">        <span class="keyword">return</span> nextNode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取下一个Node</span></span><br><span class="line"><span class="keyword">final</span> LinkedHashMap.Entry &lt; K, V &gt; nextNode() &#123;</span><br><span class="line">    <span class="comment">//获取下一个节点next</span></span><br><span class="line">    LinkedHashMap.Entry &lt; K, V &gt; e = next;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="comment">//current 指针指向当前节点</span></span><br><span class="line">    current = e;</span><br><span class="line">    <span class="comment">//next直接当前节点的after指针快速定位到下一个节点</span></span><br><span class="line">    next = e.after;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了验证笔者所说的观点，笔者对这两个容器进行了压测，测试插入 1000w 和迭代 1000w 条数据的耗时，代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1000_0000</span>;</span><br><span class="line">Map&lt;Integer, Integer&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">Map&lt;Integer, Integer&gt; linkedHashMap = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> start, end;</span><br><span class="line"></span><br><span class="line">start = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">    hashMap.put(ThreadLocalRandom.current().nextInt(<span class="number">1</span>, count), ThreadLocalRandom.current().nextInt(<span class="number">0</span>, count));</span><br><span class="line">&#125;</span><br><span class="line">end = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;map time putVal: &quot;</span> + (end - start));</span><br><span class="line"></span><br><span class="line">start = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">    linkedHashMap.put(ThreadLocalRandom.current().nextInt(<span class="number">1</span>, count), ThreadLocalRandom.current().nextInt(<span class="number">0</span>, count));</span><br><span class="line">&#125;</span><br><span class="line">end = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;linkedHashMap putVal time: &quot;</span> + (end - start));</span><br><span class="line"></span><br><span class="line">start = System.currentTimeMillis();</span><br><span class="line"><span class="type">long</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (Integer v : hashMap.values()) &#123;</span><br><span class="line">    num = num + v;</span><br><span class="line">&#125;</span><br><span class="line">end = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;map get time: &quot;</span> + (end - start));</span><br><span class="line"></span><br><span class="line">start = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (Integer v : linkedHashMap.values()) &#123;</span><br><span class="line">    num = num + v;</span><br><span class="line">&#125;</span><br><span class="line">end = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;linkedHashMap get time: &quot;</span> + (end - start));</span><br><span class="line">System.out.println(num);</span><br></pre></td></tr></table></figure>

<p>从输出结果来看，因为 <code>LinkedHashMap</code> 需要维护双向链表的缘故，插入元素相较于 <code>HashMap</code> 会更耗时，但是有了双向链表明确的前后节点关系，迭代效率相对于前者高效了许多。不过，总体来说却别不大，毕竟数据量这么庞大。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map <span class="keyword">time</span> putVal: 5880</span><br><span class="line">linkedHashMap putVal <span class="keyword">time</span>: 7567</span><br><span class="line">map get <span class="keyword">time</span>: 143</span><br><span class="line">linkedHashMap get <span class="keyword">time</span>: 67</span><br><span class="line">63208969074998</span><br></pre></td></tr></table></figure>

<h2 id="LinkedHashMap-常见面试题"><a href="#LinkedHashMap-常见面试题" class="headerlink" title="LinkedHashMap 常见面试题"></a>LinkedHashMap 常见面试题</h2><h3 id="什么是-LinkedHashMap？"><a href="#什么是-LinkedHashMap？" class="headerlink" title="什么是 LinkedHashMap？"></a>什么是 LinkedHashMap？</h3><p><code>LinkedHashMap</code> 是 Java 集合框架中 <code>HashMap</code> 的一个子类，它继承了 <code>HashMap</code> 的所有属性和方法，并且在 <code>HashMap</code> 的基础重写了 <code>afterNodeRemoval</code>、<code>afterNodeInsertion</code>、<code>afterNodeAccess</code> 方法。使之拥有顺序插入和访问有序的特性。</p>
<h3 id="LinkedHashMap-如何按照插入顺序迭代元素？"><a href="#LinkedHashMap-如何按照插入顺序迭代元素？" class="headerlink" title="LinkedHashMap 如何按照插入顺序迭代元素？"></a>LinkedHashMap 如何按照插入顺序迭代元素？</h3><p><code>LinkedHashMap</code> 按照插入顺序迭代元素是它的默认行为。<code>LinkedHashMap</code> 内部维护了一个双向链表，用于记录元素的插入顺序。因此，当使用迭代器迭代元素时，元素的顺序与它们最初插入的顺序相同。</p>
<h3 id="LinkedHashMap-如何按照访问顺序迭代元素？"><a href="#LinkedHashMap-如何按照访问顺序迭代元素？" class="headerlink" title="LinkedHashMap 如何按照访问顺序迭代元素？"></a>LinkedHashMap 如何按照访问顺序迭代元素？</h3><p><code>LinkedHashMap</code> 可以通过构造函数中的 <code>accessOrder</code> 参数指定按照访问顺序迭代元素。当 <code>accessOrder</code> 为 true 时，每次访问一个元素时，该元素会被移动到链表的末尾，因此下次访问该元素时，它就会成为链表中的最后一个元素，从而实现按照访问顺序迭代元素。</p>
<h3 id="LinkedHashMap-如何实现-LRU-缓存？"><a href="#LinkedHashMap-如何实现-LRU-缓存？" class="headerlink" title="LinkedHashMap 如何实现 LRU 缓存？"></a>LinkedHashMap 如何实现 LRU 缓存？</h3><p>将 <code>accessOrder</code> 设置为 true 并重写 <code>removeEldestEntry</code> 方法当链表大小超过容量时返回 true，使得每次访问一个元素时，该元素会被移动到链表的末尾。一旦插入操作让 <code>removeEldestEntry</code> 返回 true 时，视为缓存已满，<code>LinkedHashMap</code> 就会将链表首元素移除，由此我们就能实现一个 LRU 缓存。</p>
<h3 id="LinkedHashMap-和-HashMap-有什么区别？"><a href="#LinkedHashMap-和-HashMap-有什么区别？" class="headerlink" title="LinkedHashMap 和 HashMap 有什么区别？"></a>LinkedHashMap 和 HashMap 有什么区别？</h3><p><code>LinkedHashMap</code> 和 <code>HashMap</code> 都是 Java 集合框架中的 Map 接口的实现类。它们的最大区别在于迭代元素的顺序。<code>HashMap</code> 迭代元素的顺序是不确定的，而 <code>LinkedHashMap</code> 提供了按照插入顺序或访问顺序迭代元素的功能。此外，<code>LinkedHashMap</code> 内部维护了一个双向链表，用于记录元素的插入顺序或访问顺序，而 <code>HashMap</code> 则没有这个链表。因此，<code>LinkedHashMap</code> 的插入性能可能会比 <code>HashMap</code> 略低，但它提供了更多的功能并且迭代效率相较于 <code>HashMap</code> 更加高效。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li>LinkedHashMap 源码详细分析（JDK1.8）:<a href="https://www.imooc.com/article/22931">https://www.imooc.com/article/22931</a></li>
<li>HashMap 与 LinkedHashMap:<a href="https://www.cnblogs.com/Spground/p/8536148.html">https://www.cnblogs.com/Spground/p/8536148.html</a></li>
<li>源于 LinkedHashMap 源码: <a href="https://leetcode.cn/problems/lru-cache/solution/yuan-yu-linkedhashmapyuan-ma-by-jeromememory/">https://leetcode.cn/problems/lru-cache/solution/yuan-yu-linkedhashmapyuan-ma-by-jeromememory/</a><!-- @include: @article-footer.snippet.md --></li>
</ul>

  </article>
</div>


    




</div>

<div class="footer-wrapper container">
  <footer class="footer clearfix">
    <div class="clearfix">
    <a href="http://yoursite.com" class="footer-logo">
      <i class="fa fa-github"></i>
    </a>
    <ul class="footer-social-link">
      <li>© 2019 史海杰</li>
      <li><a href="http://yoursite.com">Home</a></li>
      
    </ul>
    <div class="footer-theme-info">
      Theme <a href="//github.com/sabrinaluo/hexo-theme-replica">Replica</a>
      by <a href="//github.com/sabrinaluo">Hiitea</a> ❤ Powered by Hexo
    </div>
    </div>
    
  </footer>
</div>




<script src="/js/main.js"></script>

</body>
</html>
