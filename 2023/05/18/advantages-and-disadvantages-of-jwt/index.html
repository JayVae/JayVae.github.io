<!DOCTYPE html>
<html lang="zh-Hans">


<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>
    JWT 身份认证优缺点分析 | Jay&#39;s Blog
  </title>
  <meta name="description" content="持续精进">
  
  <meta name="keywords" content="
  安全
  ">
  
  <meta name="author" content="史海杰">

  <meta http-equiv="Cache-Control" content="no-transform"/>
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta name="theme-color" content="#1e2327">
  <link rel="apple-touch-icon" href="https://github.githubassets.com/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="180x180" href="https://github.githubassets.com/apple-touch-icon-180x180.png">

  <link rel="icon" type="image/x-icon" href="https://github.githubassets.com/favicon.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet"
        href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  

  

  <script src="//cdnjs.cloudflare.com/ajax/libs/vue/1.0.25-csp/vue.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.11.2/moment.min.js"></script>
<meta name="generator" content="Hexo 7.3.0"></head>

<body id="replica-app">

<nav class="navbar-wrapper">
  <div class="navbar">
    <div class="container clearfix">
      <a href="/" class="navbar-logo"><i class="fa fa-github"></i></a>

      <div class="navbar-search float-left desktop-only">
        <div class="navbar-search-form">
          <label for="gsc-i-id1">This website</label>
          <div id="google-search">
            <gcse:search></gcse:search>
          </div>
        </div>
      </div>

      <ul class="navbar-nav float-left">
        
        <li><a href="/">Archives</a></li>
        
        
        <li><a href="/">Categories</a></li>
        
        
        <li><a href="/">Tags</a></li>
        
        
        <li class="desktop-only"><a href="/atom.xml" target="_blank">RSS</a></li>
        
      </ul>

      <ul class="navbar-nav user-nav float-right desktop-only">
        <li class="user-nav-notification">
          <a><span class="user-nav-unread"></span><i class="fa fa-bell"></i></a>
        </li>
        <li>
          <a><i class="fa fa-plus"></i> <i class="fa fa-caret-down"></i></a>
        </li>
        <li class="user-nav-logo">
          <a><img src="https://octodex.github.com/images/baracktocat.jpg"> <i class="fa fa-caret-down"></i></i></a>
        </li>
      </ul>
    </div>
  </div>
</nav>

<div class="main-container">
  <header class="header-wrapper desktop-only">
  <div class="container header-site-detail">
    <ul class="header-toolbar">
      <li class="clearfix">
        <a href="/" class="header-toolbar-left"><i
                  class="fa fa-file-text"></i> Posts </a>
        <a href="/"
           class="header-toolbar-right"> 201 </a>
      </li>
      <li>
        <a href="/" class="header-toolbar-left"><i
                  class="fa fa-tags"></i> Tags </a>
        <a href="/"
           class="header-toolbar-right"> 28 </a>
      </li>
      <li>
        <a href="/" class="header-toolbar-left"><i
                  class="fa fa-folder-open"></i> Categories </a>
        <a href="/"
           class="header-toolbar-right"> 26 </a>
      </li>
    </ul>
    <h2 class="header-title">
      <i class="fa fa-book text-muted"></i>
      <a href="/">Jay&#39;s Blog</a>
      
      
    </h2>
  </div>

  <div class="container">
    <div class="header-tab-wrapper clearfix">
      <span class="header-tab header-tab-selected"><i class="fa fa-thumbs-o-up"></i> Like</span>
      <span class="header-tab"><i class="fa fa-share-alt"></i> Share</span>
      <span class="header-tab"><i class="fa fa-comments-o"></i> Discussion</span>
      <span class="header-tab"><i class="fa fa-bookmark-o"></i> Bookmark </span>
      <span class="header-tab"><i class="fa fa-smile-o"></i> Smile <i class="fa fa-caret-down"></i></span>
    </div>
  </div>
</header>


<div class="post-container container">
  <h3>
    <i class="fa fa-user-o"></i>
    史海杰

    <span class="post-date float-right" title="{{moment(1684411662000).format('MMM DD, YYYY, h:mm:ss A')}}">
      
          <i class="fa fa-pencil-square-o"></i>
      
      {{moment(1684411662000).fromNow()}}
    </span>
  </h3>

  <article class="post-content">
    <h1>JWT 身份认证优缺点分析</h1>
    <p>校招面试中，遇到大部分的候选者认证登录这块用的都是 JWT。提问 JWT 的概念性问题以及使用 JWT 的原因，基本都能回答一些，但当问到 JWT 存在的一些问题和解决方案时，只有一小部分候选者回答的还可以。</p>
<p>JWT 不是银弹，也有很多缺陷，很多时候并不是最优的选择。这篇文章，我们一起探讨一下 JWT 身份认证的优缺点以及常见问题的解决办法，来看看为什么很多人不再推荐使用 JWT 了。</p>
<p>关于 JWT 的基本概念介绍请看我写的这篇文章： <a href="https://javaguide.cn/system-design/security/jwt-intro.html">JWT 基本概念详解</a>。</p>
<h2 id="JWT-的优势"><a href="#JWT-的优势" class="headerlink" title="JWT 的优势"></a>JWT 的优势</h2><p>相比于 Session 认证的方式来说，使用 JWT 进行身份认证主要有下面 4 个优势。</p>
<h3 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h3><p>JWT 自身包含了身份验证所需要的所有信息，因此，我们的服务器不需要存储 JWT 信息。这显然增加了系统的可用性和伸缩性，大大减轻了服务端的压力。</p>
<p>不过，也正是由于 JWT 的无状态，也导致了它最大的缺点：<strong>不可控！</strong></p>
<p>就比如说，我们想要在 JWT 有效期内废弃一个 JWT 或者更改它的权限的话，并不会立即生效，通常需要等到有效期过后才可以。再比如说，当用户 Logout 的话，JWT 也还有效。除非，我们在后端增加额外的处理逻辑比如将失效的 JWT 存储起来，后端先验证 JWT 是否有效再进行处理。具体的解决办法，我们会在后面的内容中详细介绍到，这里只是简单提一下。</p>
<h3 id="有效避免了-CSRF-攻击"><a href="#有效避免了-CSRF-攻击" class="headerlink" title="有效避免了 CSRF 攻击"></a>有效避免了 CSRF 攻击</h3><p><strong>CSRF（Cross Site Request Forgery）</strong> 一般被翻译为 <strong>跨站请求伪造</strong>，属于网络攻击领域范围。相比于 SQL 脚本注入、XSS 等安全攻击方式，CSRF 的知名度并没有它们高。但是，它的确是我们开发系统时必须要考虑的安全隐患。就连业内技术标杆 Google 的产品 Gmail 也曾在 2007 年的时候爆出过 CSRF 漏洞，这给 Gmail 的用户造成了很大的损失。</p>
<p><strong>那么究竟什么是跨站请求伪造呢？</strong> 简单来说就是用你的身份去做一些不好的事情（发送一些对你不友好的请求比如恶意转账）。</p>
<p>举个简单的例子：小壮登录了某网上银行，他来到了网上银行的帖子区，看到一个帖子下面有一个链接写着“科学理财，年盈利率过万”，小壮好奇的点开了这个链接，结果发现自己的账户少了 10000 元。这是这么回事呢？原来黑客在链接中藏了一个请求，这个请求直接利用小壮的身份给银行发送了一个转账请求，也就是通过你的 Cookie 向银行发出请求。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">src</span>=<span class="string">&quot;http://www.mybank.com/Transfer?bankId=11&amp;money=10000&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span>科学理财，年盈利率过万&lt;/a</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<p>CSRF 攻击需要依赖 Cookie ，Session 认证中 Cookie 中的 <code>SessionID</code> 是由浏览器发送到服务端的，只要发出请求，Cookie 就会被携带。借助这个特性，即使黑客无法获取你的 <code>SessionID</code>，只要让你误点攻击链接，就可以达到攻击效果。</p>
<p>另外，并不是必须点击链接才可以达到攻击效果，很多时候，只要你打开了某个页面，CSRF 攻击就会发生。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://www.mybank.com/Transfer?bankId=11&amp;money=10000&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>那为什么 JWT 不会存在这种问题呢？</strong></p>
<p>一般情况下我们使用 JWT 的话，在我们登录成功获得 JWT 之后，一般会选择存放在 localStorage 中。前端的每一个请求后续都会附带上这个 JWT，整个过程压根不会涉及到 Cookie。因此，即使你点击了非法链接发送了请求到服务端，这个非法请求也是不会携带 JWT 的，所以这个请求将是非法的。</p>
<p>总结来说就一句话：<strong>使用 JWT 进行身份验证不需要依赖 Cookie ，因此可以避免 CSRF 攻击。</strong></p>
<p>不过，这样也会存在 XSS 攻击的风险。为了避免 XSS 攻击，你可以选择将 JWT 存储在标记为<code>httpOnly</code> 的 Cookie 中。但是，这样又导致了你必须自己提供 CSRF 保护，因此，实际项目中我们通常也不会这么做。</p>
<p>常见的避免 XSS 攻击的方式是过滤掉请求中存在 XSS 攻击风险的可疑字符串。</p>
<p>在 Spring 项目中，我们一般是通过创建 XSS 过滤器来实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(Ordered.HIGHEST_PRECEDENCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XSSFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response,</span></span><br><span class="line"><span class="params">      FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="type">XSSRequestWrapper</span> <span class="variable">wrappedRequest</span> <span class="operator">=</span></span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">XSSRequestWrapper</span>((HttpServletRequest) request);</span><br><span class="line">        chain.doFilter(wrappedRequest, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// other methods</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="适合移动端应用"><a href="#适合移动端应用" class="headerlink" title="适合移动端应用"></a>适合移动端应用</h3><p>使用 Session 进行身份认证的话，需要保存一份信息在服务器端，而且这种方式会依赖到 Cookie（需要 Cookie 保存 <code>SessionId</code>），所以不适合移动端。</p>
<p>但是，使用 JWT 进行身份认证就不会存在这种问题，因为只要 JWT 可以被客户端存储就能够使用，而且 JWT 还可以跨语言使用。</p>
<blockquote>
<p>为什么使用 Session 进行身份认证的话不适合移动端 ？</p>
<ol>
<li>状态管理: Session 基于服务器端的状态管理，而移动端应用通常是无状态的。移动设备的连接可能不稳定或中断，因此难以维护长期的会话状态。如果使用 Session 进行身份认证，移动应用需要频繁地与服务器进行会话维护，增加了网络开销和复杂性;</li>
<li>兼容性: 移动端应用通常会面向多个平台，如 iOS、Android 和 Web。每个平台对于 Session 的管理和存储方式可能不同，可能导致跨平台兼容性的问题;</li>
<li>安全性: 移动设备通常处于不受信任的网络环境，存在数据泄露和攻击的风险。将敏感的会话信息存储在移动设备上增加了被攻击的潜在风险。</li>
</ol>
</blockquote>
<h3 id="单点登录友好"><a href="#单点登录友好" class="headerlink" title="单点登录友好"></a>单点登录友好</h3><p>使用 Session 进行身份认证的话，实现单点登录，需要我们把用户的 Session 信息保存在一台电脑上，并且还会遇到常见的 Cookie 跨域的问题。但是，使用 JWT 进行认证的话， JWT 被保存在客户端，不会存在这些问题。</p>
<h2 id="JWT-身份认证常见问题及解决办法"><a href="#JWT-身份认证常见问题及解决办法" class="headerlink" title="JWT 身份认证常见问题及解决办法"></a>JWT 身份认证常见问题及解决办法</h2><h3 id="注销登录等场景下-JWT-还有效"><a href="#注销登录等场景下-JWT-还有效" class="headerlink" title="注销登录等场景下 JWT 还有效"></a>注销登录等场景下 JWT 还有效</h3><p>与之类似的具体相关场景有：</p>
<ul>
<li>退出登录;</li>
<li>修改密码;</li>
<li>服务端修改了某个用户具有的权限或者角色；</li>
<li>用户的帐户被封禁&#x2F;删除；</li>
<li>用户被服务端强制注销；</li>
<li>用户被踢下线；</li>
<li>……</li>
</ul>
<p>这个问题不存在于 Session 认证方式中，因为在 Session 认证方式中，遇到这种情况的话服务端删除对应的 Session 记录即可。但是，使用 JWT 认证的方式就不好解决了。我们也说过了，JWT 一旦派发出去，如果后端不增加其他逻辑的话，它在失效之前都是有效的。</p>
<p>那我们如何解决这个问题呢？查阅了很多资料，我简单总结了下面 4 种方案：</p>
<p><strong>1、将 JWT 存入数据库</strong></p>
<p>将有效的 JWT 存入数据库中，更建议使用内存数据库比如 Redis。如果需要让某个 JWT 失效就直接从 Redis 中删除这个 JWT 即可。但是，这样会导致每次使用 JWT 都要先从 Redis 中查询 JWT 是否存在的步骤，而且违背了 JWT 的无状态原则。</p>
<p><strong>2、黑名单机制</strong></p>
<p>和上面的方式类似，使用内存数据库比如 Redis 维护一个黑名单，如果想让某个 JWT 失效的话就直接将这个 JWT 加入到 <strong>黑名单</strong> 即可。然后，每次使用 JWT 进行请求的话都会先判断这个 JWT 是否存在于黑名单中。</p>
<p>前两种方案的核心在于将有效的 JWT 存储起来或者将指定的 JWT 拉入黑名单。</p>
<p>虽然这两种方案都违背了 JWT 的无状态原则，但是一般实际项目中我们通常还是会使用这两种方案。</p>
<p><strong>3、修改密钥 (Secret)</strong> :</p>
<p>我们为每个用户都创建一个专属密钥，如果我们想让某个 JWT 失效，我们直接修改对应用户的密钥即可。但是，这样相比于前两种引入内存数据库带来了危害更大：</p>
<ul>
<li>如果服务是分布式的，则每次发出新的 JWT 时都必须在多台机器同步密钥。为此，你需要将密钥存储在数据库或其他外部服务中，这样和 Session 认证就没太大区别了。</li>
<li>如果用户同时在两个浏览器打开系统，或者在手机端也打开了系统，如果它从一个地方将账号退出，那么其他地方都要重新进行登录，这是不可取的。</li>
</ul>
<p><strong>4、保持令牌的有效期限短并经常轮换</strong></p>
<p>很简单的一种方式。但是，会导致用户登录状态不会被持久记录，而且需要用户经常登录。</p>
<p>另外，对于修改密码后 JWT 还有效问题的解决还是比较容易的。说一种我觉得比较好的方式：<strong>使用用户的密码的哈希值对 JWT 进行签名。因此，如果密码更改，则任何先前的令牌将自动无法验证。</strong></p>
<h3 id="JWT-的续签问题"><a href="#JWT-的续签问题" class="headerlink" title="JWT 的续签问题"></a>JWT 的续签问题</h3><p>JWT 有效期一般都建议设置的不太长，那么 JWT 过期后如何认证，如何实现动态刷新 JWT，避免用户经常需要重新登录？</p>
<p>我们先来看看在 Session 认证中一般的做法：<strong>假如 Session 的有效期 30 分钟，如果 30 分钟内用户有访问，就把 Session 有效期延长 30 分钟。</strong></p>
<p>JWT 认证的话，我们应该如何解决续签问题呢？查阅了很多资料，我简单总结了下面 4 种方案：</p>
<p><strong>1、类似于 Session 认证中的做法（不推荐）</strong></p>
<p>这种方案满足于大部分场景。假设服务端给的 JWT 有效期设置为 30 分钟，服务端每次进行校验时，如果发现 JWT 的有效期马上快过期了，服务端就重新生成 JWT 给客户端。客户端每次请求都检查新旧 JWT，如果不一致，则更新本地的 JWT。这种做法的问题是仅仅在快过期的时候请求才会更新 JWT ，对客户端不是很友好。</p>
<p><strong>2、每次请求都返回新 JWT（不推荐）</strong></p>
<p>这种方案的的思路很简单，但是，开销会比较大，尤其是在服务端要存储维护 JWT 的情况下。</p>
<p><strong>3、JWT 有效期设置到半夜（不推荐）</strong></p>
<p>这种方案是一种折衷的方案，保证了大部分用户白天可以正常登录，适用于对安全性要求不高的系统。</p>
<p><strong>4、用户登录返回两个 JWT（推荐）</strong></p>
<p>第一个是 accessJWT ，它的过期时间 JWT 本身的过期时间比如半个小时，另外一个是 refreshJWT 它的过期时间更长一点比如为 1 天。refreshJWT 只用来获取 accessJWT，不容易被泄露。</p>
<p>客户端登录后，将 accessJWT 和 refreshJWT 保存在本地，每次访问将 accessJWT 传给服务端。服务端校验 accessJWT 的有效性，如果过期的话，就将 refreshJWT 传给服务端。如果有效，服务端就生成新的 accessJWT 给客户端。否则，客户端就重新登录即可。</p>
<p>这种方案的不足是：</p>
<ul>
<li>需要客户端来配合；</li>
<li>用户注销的时候需要同时保证两个 JWT 都无效；</li>
<li>重新请求获取 JWT 的过程中会有短暂 JWT 不可用的情况（可以通过在客户端设置定时器，当 accessJWT 快过期的时候，提前去通过 refreshJWT 获取新的 accessJWT）;</li>
<li>存在安全问题，只要拿到了未过期的 refreshJWT 就一直可以获取到 accessJWT。不过，由于 refreshJWT 只用来获取 accessJWT，不容易被泄露。</li>
</ul>
<h3 id="JWT-体积太大"><a href="#JWT-体积太大" class="headerlink" title="JWT 体积太大"></a>JWT 体积太大</h3><p>JWT 结构复杂（Header、Payload 和 Signature），包含了更多额外的信息，还需要进行 Base64Url 编码，这会使得 JWT 体积较大，增加了网络传输的开销。</p>
<p>JWT 组成:</p>
<p><img src="https://oss.javaguide.cn/javaguide/system-design/jwt/jwt-composition.png" alt="JWT 组成"></p>
<p>JWT 示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.</span><br><span class="line">eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.</span><br><span class="line">SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</span><br></pre></td></tr></table></figure>

<p>解决办法：</p>
<ul>
<li>尽量减少 JWT Payload（载荷）中的信息，只保留必要的用户和权限信息。</li>
<li>在传输 JWT 之前，使用压缩算法（如 GZIP）对 JWT 进行压缩以减少体积。</li>
<li>在某些情况下，使用传统的 Token 可能更合适。传统的 Token 通常只是一个唯一标识符，对应的信息（例如用户 ID、Token 过期时间、权限信息）存储在服务端，通常会通过 Redis 保存。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>JWT 其中一个很重要的优势是无状态，但实际上，我们想要在实际项目中合理使用 JWT 做认证登录的话，也还是需要保存 JWT 信息。</p>
<p>JWT 也不是银弹，也有很多缺陷，具体是选择 JWT 还是 Session 方案还是要看项目的具体需求。万万不可尬吹 JWT，而看不起其他身份认证方案。</p>
<p>另外，不用 JWT 直接使用普通的 Token(随机生成的 ID，不包含具体的信息) 结合 Redis 来做身份认证也是可以的。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>JWT 超详细分析：<a href="https://learnku.com/articles/17883">https://learnku.com/articles/17883</a></li>
<li>How to log out when using JWT：<a href="https://medium.com/devgorilla/how-to-log-out-when-using-jwt-a8c7823e8a6">https://medium.com/devgorilla/how-to-log-out-when-using-jwt-a8c7823e8a6</a></li>
<li>CSRF protection with JSON Web JWTs：<a href="https://medium.com/@agungsantoso/csrf-protection-with-json-web-JWTs-83e0f2fcbcc">https://medium.com/@agungsantoso/csrf-protection-with-json-web-JWTs-83e0f2fcbcc</a></li>
<li>Invalidating JSON Web JWTs：<a href="https://stackoverflow.com/questions/21978658/invalidating-json-web-JWTs">https://stackoverflow.com/questions/21978658/invalidating-json-web-JWTs</a></li>
</ul>
<!-- @include: @article-footer.snippet.md -->

  </article>
</div>


    




</div>

<div class="footer-wrapper container">
  <footer class="footer clearfix">
    <div class="clearfix">
    <a href="http://yoursite.com" class="footer-logo">
      <i class="fa fa-github"></i>
    </a>
    <ul class="footer-social-link">
      <li>© 2019 史海杰</li>
      <li><a href="http://yoursite.com">Home</a></li>
      
    </ul>
    <div class="footer-theme-info">
      Theme <a href="//github.com/sabrinaluo/hexo-theme-replica">Replica</a>
      by <a href="//github.com/sabrinaluo">Hiitea</a> ❤ Powered by Hexo
    </div>
    </div>
    
  </footer>
</div>




<script src="/js/main.js"></script>

</body>
</html>
