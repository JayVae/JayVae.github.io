<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="持续精进">
<meta property="og:type" content="website">
<meta property="og:title" content="Jay&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Jay&#39;s Blog">
<meta property="og:description" content="持续精进">
<meta property="og:locale">
<meta property="article:author" content="史海杰">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Jay's Blog</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?1dc984dfc86062a60470cc7297fb0653";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




<meta name="generator" content="Hexo 7.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jay's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">知而不行为不知</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-guestbook">
          <a href="/guestbook" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            留言
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2024/11/28/rocketmq-questions/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/11/28/rocketmq-questions/" itemprop="url">RocketMQ常见问题总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-11-28T21:47:35+08:00">
                2024-11-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" itemprop="url" rel="index">
                    <span itemprop="name">消息队列</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2024/11/28/rocketmq-questions/" class="leancloud_visitors" data-flag-title="RocketMQ常见问题总结">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  17.3k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  61 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="消息队列扫盲"><a href="#消息队列扫盲" class="headerlink" title="消息队列扫盲"></a>消息队列扫盲</h2><p>消息队列顾名思义就是存放消息的队列，队列我就不解释了，别告诉我你连队列都不知道是啥吧？</p>
<p>所以问题并不是消息队列是什么，而是 <strong>消息队列为什么会出现？消息队列能用来干什么？用它来干这些事会带来什么好处？消息队列会带来副作用吗？</strong></p>
<h3 id="消息队列为什么会出现？"><a href="#消息队列为什么会出现？" class="headerlink" title="消息队列为什么会出现？"></a>消息队列为什么会出现？</h3><p>消息队&#96;&#96;列算是作为后端程序员的一个必备技能吧，因为<strong>分布式应用必定涉及到各个系统之间的通信问题</strong>，这个时候消息队列也应运而生了。可以说分布式的产生是消息队列的基础，而分布式怕是一个很古老的概念了吧，所以消息队列也是一个很古老的中间件了。</p>
<h3 id="消息队列能用来干什么？"><a href="#消息队列能用来干什么？" class="headerlink" title="消息队列能用来干什么？"></a>消息队列能用来干什么？</h3><h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><p>你可能会反驳我，应用之间的通信又不是只能由消息队列解决，好好的通信为什么中间非要插一个消息队列呢？我不能直接进行通信吗？</p>
<p>很好 👍，你又提出了一个概念，<strong>同步通信</strong>。就比如现在业界使用比较多的 <code>Dubbo</code> 就是一个适用于各个系统之间同步通信的 <code>RPC</code> 框架。</p>
<p>我来举个 🌰 吧，比如我们有一个购票系统，需求是用户在购买完之后能接收到购买完成的短信。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/16ef37fee7e09230.jpg"></p>
<p>我们省略中间的网络通信时间消耗，假如购票系统处理需要 150ms ，短信系统处理需要 200ms ，那么整个处理流程的时间消耗就是 150ms + 200ms &#x3D; 350ms。</p>
<p>当然，乍看没什么问题。可是仔细一想你就感觉有点问题，我用户购票在购票系统的时候其实就已经完成了购买，而我现在通过同步调用非要让整个请求拉长时间，而短信系统这玩意又不是很有必要，它仅仅是一个辅助功能增强用户体验感而已。我现在整个调用流程就有点 <strong>头重脚轻</strong> 的感觉了，购票是一个不太耗时的流程，而我现在因为同步调用，非要等待发送短信这个比较耗时的操作才返回结果。那我如果再加一个发送邮件呢？</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/16ef380429cf373e.jpg"></p>
<p>这样整个系统的调用链又变长了，整个时间就变成了 550ms。</p>
<p>当我们在学生时代需要在食堂排队的时候，我们和食堂大妈就是一个同步的模型。</p>
<p>我们需要告诉食堂大妈：“姐姐，给我加个鸡腿，再加个酸辣土豆丝，帮我浇点汁上去，多打点饭哦 😋😋😋” 咦~~~ 为了多吃点，真恶心。</p>
<p>然后大妈帮我们打饭配菜，我们看着大妈那颤抖的手和掉落的土豆丝不禁咽了咽口水。</p>
<p>最终我们从大妈手中接过饭菜然后去寻找座位了…</p>
<p>回想一下，我们在给大妈发送需要的信息之后我们是 <strong>同步等待大妈给我配好饭菜</strong> 的，上面我们只是加了鸡腿和土豆丝，万一我再加一个番茄牛腩，韭菜鸡蛋，这样是不是大妈打饭配菜的流程就会变长，我们等待的时间也会相应的变长。</p>
<p>那后来，我们工作赚钱了有钱去饭店吃饭了，我们告诉服务员来一碗牛肉面加个荷包蛋 <strong>(传达一个消息)</strong> ，然后我们就可以在饭桌上安心的玩手机了 <strong>(干自己其他事情)</strong> ，等到我们的牛肉面上了我们就可以吃了。这其中我们也就传达了一个消息，然后我们又转过头干其他事情了。这其中虽然做面的时间没有变短，但是我们只需要传达一个消息就可以干其他事情了，这是一个 <strong>异步</strong> 的概念。</p>
<p>所以，为了解决这一个问题，聪明的程序员在中间也加了个类似于服务员的中间件——消息队列。这个时候我们就可以把模型给改造了。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/16ef38124f55eaea.jpg"></p>
<p>这样，我们在将消息存入消息队列之后我们就可以直接返回了(我们告诉服务员我们要吃什么然后玩手机)，所以整个耗时只是 150ms + 10ms &#x3D; 160ms。</p>
<blockquote>
<p>但是你需要注意的是，整个流程的时长是没变的，就像你仅仅告诉服务员要吃什么是不会影响到做面的速度的。</p>
</blockquote>
<h4 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h4><p>回到最初同步调用的过程，我们写个伪代码简单概括一下。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/16ef381a505d3e1f.jpg"></p>
<p>那么第二步，我们又添加了一个发送邮件，我们就得重新去修改代码，如果我们又加一个需求：用户购买完还需要给他加积分，这个时候我们是不是又得改代码？</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/16ef381c4e1b1ac7.jpg"></p>
<p>如果你觉得还行，那么我这个时候不要发邮件这个服务了呢，我是不是又得改代码，又得重启应用？</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/16ef381f273a66bd.jpg"></p>
<p>这样改来改去是不是很麻烦，那么 <strong>此时我们就用一个消息队列在中间进行解耦</strong> 。你需要注意的是，我们后面的发送短信、发送邮件、添加积分等一些操作都依赖于上面的 <code>result</code> ，这东西抽象出来就是购票的处理结果呀，比如订单号，用户账号等等，也就是说我们后面的一系列服务都是需要同样的消息来进行处理。既然这样，我们是不是可以通过 <strong>“广播消息”</strong> 来实现。</p>
<p>我上面所讲的“广播”并不是真正的广播，而是接下来的系统作为消费者去 <strong>订阅</strong> 特定的主题。比如我们这里的主题就可以叫做 <code>订票</code> ，我们购买系统作为一个生产者去生产这条消息放入消息队列，然后消费者订阅了这个主题，会从消息队列中拉取消息并消费。就比如我们刚刚画的那张图，你会发现，在生产者这边我们只需要关注 <strong>生产消息到指定主题中</strong> ，而 <strong>消费者只需要关注从指定主题中拉取消息</strong> 就行了。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/16ef382674b66892.jpg"></p>
<blockquote>
<p>如果没有消息队列，每当一个新的业务接入，我们都要在主系统调用新接口、或者当我们取消某些业务，我们也得在主系统删除某些接口调用。有了消息队列，我们只需要关心消息是否送达了队列，至于谁希望订阅，接下来收到消息如何处理，是下游的事情，无疑极大地减少了开发和联调的工作量。</p>
</blockquote>
<h4 id="削峰"><a href="#削峰" class="headerlink" title="削峰"></a>削峰</h4><p>我们再次回到一开始我们使用同步调用系统的情况，并且思考一下，如果此时有大量用户请求购票整个系统会变成什么样？</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/16ef382a9756bb1c.jpg"></p>
<p>如果，此时有一万的请求进入购票系统，我们知道运行我们主业务的服务器配置一般会比较好，所以这里我们假设购票系统能承受这一万的用户请求，那么也就意味着我们同时也会出现一万调用发短信服务的请求。而对于短信系统来说并不是我们的主要业务，所以我们配备的硬件资源并不会太高，那么你觉得现在这个短信系统能承受这一万的峰值么，且不说能不能承受，系统会不会 <strong>直接崩溃</strong> 了？</p>
<p>短信业务又不是我们的主业务，我们能不能 <strong>折中处理</strong> 呢？如果我们把购买完成的信息发送到消息队列中，而短信系统 <strong>尽自己所能地去消息队列中取消息和消费消息</strong> ，即使处理速度慢一点也无所谓，只要我们的系统没有崩溃就行了。</p>
<p>留得江山在，还怕没柴烧？你敢说每次发送验证码的时候是一发你就收到了的么？</p>
<h4 id="消息队列能带来什么好处？"><a href="#消息队列能带来什么好处？" class="headerlink" title="消息队列能带来什么好处？"></a>消息队列能带来什么好处？</h4><p>其实上面我已经说了。<strong>异步、解耦、削峰。</strong> 哪怕你上面的都没看懂也千万要记住这六个字，因为他不仅是消息队列的精华，更是编程和架构的精华。</p>
<h4 id="消息队列会带来副作用吗？"><a href="#消息队列会带来副作用吗？" class="headerlink" title="消息队列会带来副作用吗？"></a>消息队列会带来副作用吗？</h4><p>没有哪一门技术是“银弹”，消息队列也有它的副作用。</p>
<p>比如，本来好好的两个系统之间的调用，我中间加了个消息队列，如果消息队列挂了怎么办呢？是不是 <strong>降低了系统的可用性</strong> ？</p>
<p>那这样是不是要保证 HA(高可用)？是不是要搞集群？那么我 <strong>整个系统的复杂度是不是上升了</strong> ？</p>
<p>抛开上面的问题不讲，万一我发送方发送失败了，然后执行重试，这样就可能产生重复的消息。</p>
<p>或者我消费端处理失败了，请求重发，这样也会产生重复的消息。</p>
<p>对于一些微服务来说，消费重复消息会带来更大的麻烦，比如增加积分，这个时候我加了多次是不是对其他用户不公平？</p>
<p>那么，又 <strong>如何解决重复消费消息的问题</strong> 呢？</p>
<p>如果我们此时的消息需要保证严格的顺序性怎么办呢？比如生产者生产了一系列的有序消息(对一个 id 为 1 的记录进行删除增加修改)，但是我们知道在发布订阅模型中，对于主题是无顺序的，那么这个时候就会导致对于消费者消费消息的时候没有按照生产者的发送顺序消费，比如这个时候我们消费的顺序为修改删除增加，如果该记录涉及到金额的话是不是会出大事情？</p>
<p>那么，又 <strong>如何解决消息的顺序消费问题</strong> 呢？</p>
<p>就拿我们上面所讲的分布式系统来说，用户购票完成之后是不是需要增加账户积分？在同一个系统中我们一般会使用事务来进行解决，如果用 <code>Spring</code> 的话我们在上面伪代码中加入 <code>@Transactional</code> 注解就好了。但是在不同系统中如何保证事务呢？总不能这个系统我扣钱成功了你那积分系统积分没加吧？或者说我这扣钱明明失败了，你那积分系统给我加了积分。</p>
<p>那么，又如何 <strong>解决分布式事务问题</strong> 呢？</p>
<p>我们刚刚说了，消息队列可以进行削峰操作，那如果我的消费者如果消费很慢或者生产者生产消息很快，这样是不是会将消息堆积在消息队列中？</p>
<p>那么，又如何 <strong>解决消息堆积的问题</strong> 呢？</p>
<p>可用性降低，复杂度上升，又带来一系列的重复消费，顺序消费，分布式事务，消息堆积的问题，这消息队列还怎么用啊 😵？</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/16ef382d709abc9d.png"></p>
<p>别急，办法总是有的。</p>
<h2 id="RocketMQ-是什么？"><a href="#RocketMQ-是什么？" class="headerlink" title="RocketMQ 是什么？"></a>RocketMQ 是什么？</h2><p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/16ef383014430799.jpg"></p>
<p>哇，你个混蛋！上面给我抛出那么多问题，你现在又讲 <code>RocketMQ</code> ，还让不让人活了？！🤬</p>
<p>别急别急，话说你现在清楚 <code>MQ</code> 的构造吗，我还没讲呢，我们先搞明白 <code>MQ</code> 的内部构造，再来看看如何解决上面的一系列问题吧，不过你最好带着问题去阅读和了解喔。</p>
<p><code>RocketMQ</code> 是一个 <strong>队列模型</strong> 的消息中间件，具有<strong>高性能、高可靠、高实时、分布式</strong> 的特点。它是一个采用 <code>Java</code> 语言开发的分布式的消息系统，由阿里巴巴团队开发，在 2016 年底贡献给 <code>Apache</code>，成为了 <code>Apache</code> 的一个顶级项目。 在阿里内部，<code>RocketMQ</code> 很好地服务了集团大大小小上千个应用，在每年的双十一当天，更有不可思议的万亿级消息通过 <code>RocketMQ</code> 流转。</p>
<p>废话不多说，想要了解 <code>RocketMQ</code> 历史的同学可以自己去搜寻资料。听完上面的介绍，你只要知道 <code>RocketMQ</code> 很快、很牛、而且经历过双十一的实践就行了！</p>
<h2 id="队列模型和主题模型是什么？"><a href="#队列模型和主题模型是什么？" class="headerlink" title="队列模型和主题模型是什么？"></a>队列模型和主题模型是什么？</h2><p>在谈 <code>RocketMQ</code> 的技术架构之前，我们先来了解一下两个名词概念——<strong>队列模型</strong> 和 <strong>主题模型</strong> 。</p>
<p>首先我问一个问题，消息队列为什么要叫消息队列？</p>
<p>你可能觉得很弱智，这玩意不就是存放消息的队列嘛？不叫消息队列叫什么？</p>
<p>的确，早期的消息中间件是通过 <strong>队列</strong> 这一模型来实现的，可能是历史原因，我们都习惯把消息中间件成为消息队列。</p>
<p>但是，如今例如 <code>RocketMQ</code>、<code>Kafka</code> 这些优秀的消息中间件不仅仅是通过一个 <strong>队列</strong> 来实现消息存储的。</p>
<h3 id="队列模型"><a href="#队列模型" class="headerlink" title="队列模型"></a>队列模型</h3><p>就像我们理解队列一样，消息中间件的队列模型就真的只是一个队列。。。我画一张图给大家理解。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/16ef3834ae653469.jpg"></p>
<p>在一开始我跟你提到了一个 <strong>“广播”</strong> 的概念，也就是说如果我们此时我们需要将一个消息发送给多个消费者(比如此时我需要将信息发送给短信系统和邮件系统)，这个时候单个队列即不能满足需求了。</p>
<p>当然你可以让 <code>Producer</code> 生产消息放入多个队列中，然后每个队列去对应每一个消费者。问题是可以解决，创建多个队列并且复制多份消息是会很影响资源和性能的。而且，这样子就会导致生产者需要知道具体消费者个数然后去复制对应数量的消息队列，这就违背我们消息中间件的 <strong>解耦</strong> 这一原则。</p>
<h3 id="主题模型"><a href="#主题模型" class="headerlink" title="主题模型"></a>主题模型</h3><p>那么有没有好的方法去解决这一个问题呢？有，那就是 <strong>主题模型</strong> 或者可以称为 <strong>发布订阅模型</strong> 。</p>
<blockquote>
<p>感兴趣的同学可以去了解一下设计模式里面的观察者模式并且手动实现一下，我相信你会有所收获的。</p>
</blockquote>
<p>在主题模型中，消息的生产者称为 <strong>发布者(Publisher)</strong> ，消息的消费者称为 <strong>订阅者(Subscriber)</strong> ，存放消息的容器称为 <strong>主题(Topic)</strong> 。</p>
<p>其中，发布者将消息发送到指定主题中，订阅者需要 <strong>提前订阅主题</strong> 才能接受特定主题的消息。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/16ef3837887d9a54sds.jpg"></p>
<h3 id="RocketMQ-中的消息模型"><a href="#RocketMQ-中的消息模型" class="headerlink" title="RocketMQ 中的消息模型"></a>RocketMQ 中的消息模型</h3><p><code>RocketMQ</code> 中的消息模型就是按照 <strong>主题模型</strong> 所实现的。你可能会好奇这个 <strong>主题</strong> 到底是怎么实现的呢？你上面也没有讲到呀！</p>
<p>其实对于主题模型的实现来说每个消息中间件的底层设计都是不一样的，就比如 <code>Kafka</code> 中的 <strong>分区</strong> ，<code>RocketMQ</code> 中的 <strong>队列</strong> ，<code>RabbitMQ</code> 中的 <code>Exchange</code> 。我们可以理解为 <strong>主题模型&#x2F;发布订阅模型</strong> 就是一个标准，那些中间件只不过照着这个标准去实现而已。</p>
<p>所以，<code>RocketMQ</code> 中的 <strong>主题模型</strong> 到底是如何实现的呢？首先我画一张图，大家尝试着去理解一下。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/16ef383d3e8c9788.jpg"></p>
<p>我们可以看到在整个图中有 <code>Producer Group</code>、<code>Topic</code>、<code>Consumer Group</code> 三个角色，我来分别介绍一下他们。</p>
<ul>
<li><code>Producer Group</code> 生产者组：代表某一类的生产者，比如我们有多个秒杀系统作为生产者，这多个合在一起就是一个 <code>Producer Group</code> 生产者组，它们一般生产相同的消息。</li>
<li><code>Consumer Group</code> 消费者组：代表某一类的消费者，比如我们有多个短信系统作为消费者，这多个合在一起就是一个 <code>Consumer Group</code> 消费者组，它们一般消费相同的消息。</li>
<li><code>Topic</code> 主题：代表一类消息，比如订单消息，物流消息等等。</li>
</ul>
<p>你可以看到图中生产者组中的生产者会向主题发送消息，而 <strong>主题中存在多个队列</strong>，生产者每次生产消息之后是指定主题中的某个队列发送消息的。</p>
<p>每个主题中都有多个队列(分布在不同的 <code>Broker</code>中，如果是集群的话，<code>Broker</code>又分布在不同的服务器中)，集群消费模式下，一个消费者集群多台机器共同消费一个 <code>topic</code> 的多个队列，<strong>一个队列只会被一个消费者消费</strong>。如果某个消费者挂掉，分组内其它消费者会接替挂掉的消费者继续消费。就像上图中 <code>Consumer1</code> 和 <code>Consumer2</code> 分别对应着两个队列，而 <code>Consumer3</code> 是没有队列对应的，所以一般来讲要控制 <strong>消费者组中的消费者个数和主题中队列个数相同</strong> 。</p>
<p>当然也可以消费者个数小于队列个数，只不过不太建议。如下图。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/16ef3850c808d707.jpg"></p>
<p><strong>每个消费组在每个队列上维护一个消费位置</strong> ，为什么呢？</p>
<p>因为我们刚刚画的仅仅是一个消费者组，我们知道在发布订阅模式中一般会涉及到多个消费者组，而每个消费者组在每个队列中的消费位置都是不同的。如果此时有多个消费者组，那么消息被一个消费者组消费完之后是不会删除的(因为其它消费者组也需要呀)，它仅仅是为每个消费者组维护一个 <strong>消费位移(offset)</strong> ，每次消费者组消费完会返回一个成功的响应，然后队列再把维护的消费位移加一，这样就不会出现刚刚消费过的消息再一次被消费了。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/16ef3857fefaa079.jpg"></p>
<p>可能你还有一个问题，<strong>为什么一个主题中需要维护多个队列</strong> ？</p>
<p>答案是 <strong>提高并发能力</strong> 。的确，每个主题中只存在一个队列也是可行的。你想一下，如果每个主题中只存在一个队列，这个队列中也维护着每个消费者组的消费位置，这样也可以做到 <strong>发布订阅模式</strong> 。如下图。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/16ef38600cdb6d4b.jpg"></p>
<p>但是，这样我生产者是不是只能向一个队列发送消息？又因为需要维护消费位置所以一个队列只能对应一个消费者组中的消费者，这样是不是其他的 <code>Consumer</code> 就没有用武之地了？从这两个角度来讲，并发度一下子就小了很多。</p>
<p>所以总结来说，<code>RocketMQ</code> 通过<strong>使用在一个 <code>Topic</code> 中配置多个队列并且每个队列维护每个消费者组的消费位置</strong> 实现了 <strong>主题模式&#x2F;发布订阅模式</strong> 。</p>
<h2 id="RocketMQ-的架构图"><a href="#RocketMQ-的架构图" class="headerlink" title="RocketMQ 的架构图"></a>RocketMQ 的架构图</h2><p>讲完了消息模型，我们理解起 <code>RocketMQ</code> 的技术架构起来就容易多了。</p>
<p><code>RocketMQ</code> 技术架构中有四大角色 <code>NameServer</code>、<code>Broker</code>、<code>Producer</code>、<code>Consumer</code> 。我来向大家分别解释一下这四个角色是干啥的。</p>
<ul>
<li><p><code>Broker</code>：主要负责消息的存储、投递和查询以及服务高可用保证。说白了就是消息队列服务器嘛，生产者生产消息到 <code>Broker</code> ，消费者从 <code>Broker</code> 拉取消息并消费。</p>
<p>这里，我还得普及一下关于 <code>Broker</code>、<code>Topic</code> 和 队列的关系。上面我讲解了 <code>Topic</code> 和队列的关系——一个 <code>Topic</code> 中存在多个队列，那么这个 <code>Topic</code> 和队列存放在哪呢？</p>
<p><strong>一个 <code>Topic</code> 分布在多个 <code>Broker</code>上，一个 <code>Broker</code> 可以配置多个 <code>Topic</code> ，它们是多对多的关系</strong>。</p>
<p>如果某个 <code>Topic</code> 消息量很大，应该给它多配置几个队列(上文中提到了提高并发能力)，并且 <strong>尽量多分布在不同 <code>Broker</code> 上，以减轻某个 <code>Broker</code> 的压力</strong> 。</p>
<p><code>Topic</code> 消息量都比较均匀的情况下，如果某个 <code>broker</code> 上的队列越多，则该 <code>broker</code> 压力越大。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/16ef38687488a5a4.jpg"></p>
<blockquote>
<p>所以说我们需要配置多个 Broker。</p>
</blockquote>
</li>
<li><p><code>NameServer</code>：不知道你们有没有接触过 <code>ZooKeeper</code> 和 <code>Spring Cloud</code> 中的 <code>Eureka</code> ，它其实也是一个 <strong>注册中心</strong> ，主要提供两个功能：<strong>Broker 管理</strong> 和 <strong>路由信息管理</strong> 。说白了就是 <code>Broker</code> 会将自己的信息注册到 <code>NameServer</code> 中，此时 <code>NameServer</code> 就存放了很多 <code>Broker</code> 的信息(Broker 的路由表)，消费者和生产者就从 <code>NameServer</code> 中获取路由表然后照着路由表的信息和对应的 <code>Broker</code> 进行通信(生产者和消费者定期会向 <code>NameServer</code> 去查询相关的 <code>Broker</code> 的信息)。</p>
</li>
<li><p><code>Producer</code>：消息发布的角色，支持分布式集群方式部署。说白了就是生产者。</p>
</li>
<li><p><code>Consumer</code>：消息消费的角色，支持分布式集群方式部署。支持以 push 推，pull 拉两种模式对消息进行消费。同时也支持集群方式和广播方式的消费，它提供实时消息订阅机制。说白了就是消费者。</p>
</li>
</ul>
<p>听完了上面的解释你可能会觉得，这玩意好简单。不就是这样的么？</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/16ef386c6d1e8bdb.jpg"></p>
<p>嗯？你可能会发现一个问题，这老家伙 <code>NameServer</code> 干啥用的，这不多余吗？直接 <code>Producer</code>、<code>Consumer</code> 和 <code>Broker</code> 直接进行生产消息，消费消息不就好了么？</p>
<p>但是，我们上文提到过 <code>Broker</code> 是需要保证高可用的，如果整个系统仅仅靠着一个 <code>Broker</code> 来维持的话，那么这个 <code>Broker</code> 的压力会不会很大？所以我们需要使用多个 <code>Broker</code> 来保证 <strong>负载均衡</strong> 。</p>
<p>如果说，我们的消费者和生产者直接和多个 <code>Broker</code> 相连，那么当 <code>Broker</code> 修改的时候必定会牵连着每个生产者和消费者，这样就会产生耦合问题，而 <code>NameServer</code> 注册中心就是用来解决这个问题的。</p>
<blockquote>
<p>如果还不是很理解的话，可以去看我介绍 <code>Spring Cloud</code> 的那篇文章，其中介绍了 <code>Eureka</code> 注册中心。</p>
</blockquote>
<p>当然，<code>RocketMQ</code> 中的技术架构肯定不止前面那么简单，因为上面图中的四个角色都是需要做集群的。我给出一张官网的架构图，大家尝试理解一下。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/16ef386fa3be1e53.jpg"></p>
<p>其实和我们最开始画的那张乞丐版的架构图也没什么区别，主要是一些细节上的差别。听我细细道来 🤨。</p>
<p>第一、我们的 <code>Broker</code> <strong>做了集群并且还进行了主从部署</strong> ，由于消息分布在各个 <code>Broker</code> 上，一旦某个 <code>Broker</code> 宕机，则该<code>Broker</code> 上的消息读写都会受到影响。所以 <code>Rocketmq</code> 提供了 <code>master/slave</code> 的结构，<code>salve</code> 定时从 <code>master</code> 同步数据(同步刷盘或者异步刷盘)，如果 <code>master</code> 宕机，<strong>则 <code>slave</code> 提供消费服务，但是不能写入消息</strong> (后面我还会提到哦)。</p>
<p>第二、为了保证 <code>HA</code> ，我们的 <code>NameServer</code> 也做了集群部署，但是请注意它是 <strong>去中心化</strong> 的。也就意味着它没有主节点，你可以很明显地看出 <code>NameServer</code> 的所有节点是没有进行 <code>Info Replicate</code> 的，在 <code>RocketMQ</code> 中是通过 <strong>单个 Broker 和所有 NameServer 保持长连接</strong> ，并且在每隔 30 秒 <code>Broker</code> 会向所有 <code>Nameserver</code> 发送心跳，心跳包含了自身的 <code>Topic</code> 配置信息，这个步骤就对应这上面的 <code>Routing Info</code> 。</p>
<p>第三、在生产者需要向 <code>Broker</code> 发送消息的时候，<strong>需要先从 <code>NameServer</code> 获取关于 <code>Broker</code> 的路由信息</strong>，然后通过 <strong>轮询</strong> 的方法去向每个队列中生产数据以达到 <strong>负载均衡</strong> 的效果。</p>
<p>第四、消费者通过 <code>NameServer</code> 获取所有 <code>Broker</code> 的路由信息后，向 <code>Broker</code> 发送 <code>Pull</code> 请求来获取消息数据。<code>Consumer</code> 可以以两种模式启动—— <strong>广播（Broadcast）和集群（Cluster）</strong>。广播模式下，一条消息会发送给 <strong>同一个消费组中的所有消费者</strong> ，集群模式下消息只会发送给一个消费者。</p>
<h2 id="RocketMQ-功能特性"><a href="#RocketMQ-功能特性" class="headerlink" title="RocketMQ 功能特性"></a>RocketMQ 功能特性</h2><h3 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h3><h4 id="普通消息"><a href="#普通消息" class="headerlink" title="普通消息"></a>普通消息</h4><p>普通消息一般应用于微服务解耦、事件驱动、数据集成等场景，这些场景大多数要求数据传输通道具有可靠传输的能力，且对消息的处理时机、处理顺序没有特别要求。以在线的电商交易场景为例，上游订单系统将用户下单支付这一业务事件封装成独立的普通消息并发送至 RocketMQ 服务端，下游按需从服务端订阅消息并按照本地消费逻辑处理下游任务。每个消息之间都是相互独立的，且不需要产生关联。另外还有日志系统，以离线的日志收集场景为例，通过埋点组件收集前端应用的相关操作日志，并转发到 RocketMQ 。</p>
<p><img src="https://rocketmq.apache.org/zh/assets/images/lifecyclefornormal-e8a2a7e42a0722f681eb129b51e1bd66.png"></p>
<p><strong>普通消息生命周期</strong></p>
<ul>
<li>初始化：消息被生产者构建并完成初始化，待发送到服务端的状态。</li>
<li>待消费：消息被发送到服务端，对消费者可见，等待消费者消费的状态。</li>
<li>消费中：消息被消费者获取，并按照消费者本地的业务逻辑进行处理的过程。 此时服务端会等待消费者完成消费并提交消费结果，如果一定时间后没有收到消费者的响应，RocketMQ 会对消息进行重试处理。</li>
<li>消费提交：消费者完成消费处理，并向服务端提交消费结果，服务端标记当前消息已经被处理（包括消费成功和失败）。RocketMQ 默认支持保留所有消息，此时消息数据并不会立即被删除，只是逻辑标记已消费。消息在保存时间到期或存储空间不足被删除前，消费者仍然可以回溯消息重新消费。</li>
<li>消息删除：RocketMQ 按照消息保存机制滚动清理最早的消息数据，将消息从物理文件中删除。</li>
</ul>
<h4 id="定时消息"><a href="#定时消息" class="headerlink" title="定时消息"></a>定时消息</h4><p>在分布式定时调度触发、任务超时处理等场景，需要实现精准、可靠的定时事件触发。使用 RocketMQ 的定时消息可以简化定时调度任务的开发逻辑，实现高性能、可扩展、高可靠的定时触发能力。定时消息仅支持在 MessageType 为 Delay 的主题内使用，即定时消息只能发送至类型为定时消息的主题中，发送的消息的类型必须和主题的类型一致。在 4.x 版本中，只支持延时消息，默认分为 18 个等级分别为：1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h，也可以在配置文件中增加自定义的延时等级和时长。在 5.x 版本中，开始支持定时消息，在构造消息时提供了 3 个 API 来指定延迟时间或定时时间。</p>
<p>基于定时消息的超时任务处理具备如下优势：</p>
<ul>
<li><strong>精度高、开发门槛低</strong>：基于消息通知方式不存在定时阶梯间隔。可以轻松实现任意精度事件触发，无需业务去重。</li>
<li><strong>高性能可扩展</strong>：传统的数据库扫描方式较为复杂，需要频繁调用接口扫描，容易产生性能瓶颈。RocketMQ 的定时消息具有高并发和水平扩展的能力。</li>
</ul>
<p><img src="https://rocketmq.apache.org/zh/assets/images/lifecyclefordelay-2ce8278df69cd026dd11ffd27ab09a17.png"></p>
<p><strong>定时消息生命周期</strong></p>
<ul>
<li>初始化：消息被生产者构建并完成初始化，待发送到服务端的状态。</li>
<li>定时中：消息被发送到服务端，和普通消息不同的是，服务端不会直接构建消息索引，而是会将定时消息<strong>单独存储在定时存储系统中</strong>，等待定时时刻到达。</li>
<li>待消费：定时时刻到达后，服务端将消息重新写入普通存储引擎，对下游消费者可见，等待消费者消费的状态。</li>
<li>消费中：消息被消费者获取，并按照消费者本地的业务逻辑进行处理的过程。 此时服务端会等待消费者完成消费并提交消费结果，如果一定时间后没有收到消费者的响应，RocketMQ 会对消息进行重试处理。</li>
<li>消费提交：消费者完成消费处理，并向服务端提交消费结果，服务端标记当前消息已经被处理（包括消费成功和失败）。RocketMQ 默认支持保留所有消息，此时消息数据并不会立即被删除，只是逻辑标记已消费。消息在保存时间到期或存储空间不足被删除前，消费者仍然可以回溯消息重新消费。</li>
<li>消息删除：Apache RocketMQ 按照消息保存机制滚动清理最早的消息数据，将消息从物理文件中删除。</li>
</ul>
<p>定时消息的实现逻辑需要先经过定时存储等待触发，定时时间到达后才会被投递给消费者。因此，如果将大量定时消息的定时时间设置为同一时刻，则到达该时刻后会有大量消息同时需要被处理，会造成系统压力过大，导致消息分发延迟，影响定时精度。</p>
<h4 id="顺序消息"><a href="#顺序消息" class="headerlink" title="顺序消息"></a>顺序消息</h4><p>顺序消息仅支持使用 MessageType 为 FIFO 的主题，即顺序消息只能发送至类型为顺序消息的主题中，发送的消息的类型必须和主题的类型一致。和普通消息发送相比，顺序消息发送必须要设置消息组。（推荐实现 MessageQueueSelector 的方式，见下文）。要保证消息的顺序性需要单一生产者串行发送。</p>
<p>单线程使用 MessageListenerConcurrently 可以顺序消费，多线程环境下使用 MessageListenerOrderly 才能顺序消费。</p>
<h4 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h4><p>事务消息是 Apache RocketMQ 提供的一种高级消息类型，支持在分布式场景下保障消息生产和本地事务的最终一致性。简单来讲，就是将本地事务（数据库的 DML 操作）与发送消息合并在同一个事务中。例如，新增一个订单。在事务未提交之前，不发送订阅的消息。发送消息的动作随着事务的成功提交而发送，随着事务的回滚而取消。当然真正地处理过程不止这么简单，包含了半消息、事务监听和事务回查等概念，下面有更详细的说明。</p>
<h2 id="关于发送消息"><a href="#关于发送消息" class="headerlink" title="关于发送消息"></a>关于发送消息</h2><h3 id="不建议单一进程创建大量生产者"><a href="#不建议单一进程创建大量生产者" class="headerlink" title="不建议单一进程创建大量生产者"></a><strong>不建议单一进程创建大量生产者</strong></h3><p>Apache RocketMQ 的生产者和主题是多对多的关系，支持同一个生产者向多个主题发送消息。对于生产者的创建和初始化，建议遵循够用即可、最大化复用原则，如果有需要发送消息到多个主题的场景，无需为每个主题都创建一个生产者。</p>
<h3 id="不建议频繁创建和销毁生产者"><a href="#不建议频繁创建和销毁生产者" class="headerlink" title="不建议频繁创建和销毁生产者"></a><strong>不建议频繁创建和销毁生产者</strong></h3><p>Apache RocketMQ 的生产者是可以重复利用的底层资源，类似数据库的连接池。因此不需要在每次发送消息时动态创建生产者，且在发送结束后销毁生产者。这样频繁的创建销毁会在服务端产生大量短连接请求，严重影响系统性能。</p>
<p>正确示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Producer</span> <span class="variable">p</span> <span class="operator">=</span> ProducerBuilder.build();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    Message m= MessageBuilder.build();</span><br><span class="line">    p.send(m);</span><br><span class="line"> &#125;</span><br><span class="line">p.shutdown();</span><br></pre></td></tr></table></figure>

<h2 id="消费者分类"><a href="#消费者分类" class="headerlink" title="消费者分类"></a>消费者分类</h2><h3 id="PushConsumer"><a href="#PushConsumer" class="headerlink" title="PushConsumer"></a>PushConsumer</h3><p>高度封装的消费者类型，消费消息仅仅通过消费监听器监听并返回结果。消息的获取、消费状态提交以及消费重试都通过 RocketMQ 的客户端 SDK 完成。</p>
<p>PushConsumer 的消费监听器执行结果分为以下三种情况：</p>
<ul>
<li>返回消费成功：以 Java SDK 为例，返回<code>ConsumeResult.SUCCESS</code>，表示该消息处理成功，服务端按照消费结果更新消费进度。</li>
<li>返回消费失败：以 Java SDK 为例，返回<code>ConsumeResult.FAILURE</code>，表示该消息处理失败，需要根据消费重试逻辑判断是否进行重试消费。</li>
<li>出现非预期失败：例如抛异常等行为，该结果按照消费失败处理，需要根据消费重试逻辑判断是否进行重试消费。</li>
</ul>
<p>具体实现可以参见这篇文章<a href="http://devedmc.com/archives/1691854198138">RocketMQ 对 pull 和 push 的实现</a>。</p>
<p>使用 PushConsumer 消费者消费时，不允许使用以下方式处理消息，否则 RocketMQ 无法保证消息的可靠性。</p>
<ul>
<li>错误方式一：消息还未处理完成，就提前返回消费成功结果。此时如果消息消费失败，RocketMQ 服务端是无法感知的，因此不会进行消费重试。</li>
<li>错误方式二：在消费监听器内将消息再次分发到自定义的其他线程，消费监听器提前返回消费结果。此时如果消息消费失败，RocketMQ 服务端同样无法感知，因此也不会进行消费重试。</li>
<li>PushConsumer 严格限制了消息同步处理及每条消息的处理超时时间，适用于以下场景：<ul>
<li>消息处理时间可预估：如果不确定消息处理耗时，经常有预期之外的长时间耗时的消息，PushConsumer 的可靠性保证会频繁触发消息重试机制造成大量重复消息。</li>
<li>无异步化、高级定制场景：PushConsumer 限制了消费逻辑的线程模型，由客户端 SDK 内部按最大吞吐量触发消息处理。该模型开发逻辑简单，但是不允许使用异步化和自定义处理流程。</li>
</ul>
</li>
</ul>
<h3 id="SimpleConsumer"><a href="#SimpleConsumer" class="headerlink" title="SimpleConsumer"></a>SimpleConsumer</h3><p>SimpleConsumer 是一种接口原子型的消费者类型，消息的获取、消费状态提交以及消费重试都是通过消费者业务逻辑主动发起调用完成。</p>
<p>一个来自官网的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消费示例：使用 SimpleConsumer 消费普通消息，主动获取消息处理并提交。</span></span><br><span class="line"><span class="type">ClientServiceProvider</span> <span class="variable">provider</span> <span class="operator">=</span> ClientServiceProvider.loadService();</span><br><span class="line"><span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> <span class="string">&quot;YourTopic&quot;</span>;</span><br><span class="line"><span class="type">FilterExpression</span> <span class="variable">filterExpression</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterExpression</span>(<span class="string">&quot;YourFilterTag&quot;</span>, FilterExpressionType.TAG);</span><br><span class="line"><span class="type">SimpleConsumer</span> <span class="variable">simpleConsumer</span> <span class="operator">=</span> provider.newSimpleConsumerBuilder()</span><br><span class="line">        <span class="comment">// 设置消费者分组。</span></span><br><span class="line">        .setConsumerGroup(<span class="string">&quot;YourConsumerGroup&quot;</span>)</span><br><span class="line">        <span class="comment">// 设置接入点。</span></span><br><span class="line">        .setClientConfiguration(ClientConfiguration.newBuilder().setEndpoints(<span class="string">&quot;YourEndpoint&quot;</span>).build())</span><br><span class="line">        <span class="comment">// 设置预绑定的订阅关系。</span></span><br><span class="line">        .setSubscriptionExpressions(Collections.singletonMap(topic, filterExpression))</span><br><span class="line">        <span class="comment">// 设置从服务端接受消息的最大等待时间</span></span><br><span class="line">        .setAwaitDuration(Duration.ofSeconds(<span class="number">1</span>))</span><br><span class="line">        .build();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// SimpleConsumer 需要主动获取消息，并处理。</span></span><br><span class="line">    List&lt;MessageView&gt; messageViewList = simpleConsumer.receive(<span class="number">10</span>, Duration.ofSeconds(<span class="number">30</span>));</span><br><span class="line">    messageViewList.forEach(messageView -&gt; &#123;</span><br><span class="line">        System.out.println(messageView);</span><br><span class="line">        <span class="comment">// 消费处理完成后，需要主动调用 ACK 提交消费结果。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            simpleConsumer.ack(messageView);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClientException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;Failed to ack message, messageId=&#123;&#125;&quot;</span>, messageView.getMessageId(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClientException e) &#123;</span><br><span class="line">    <span class="comment">// 如果遇到系统流控等原因造成拉取失败，需要重新发起获取消息请求。</span></span><br><span class="line">    logger.error(<span class="string">&quot;Failed to receive message&quot;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SimpleConsumer 适用于以下场景：</p>
<ul>
<li>消息处理时长不可控：如果消息处理时长无法预估，经常有长时间耗时的消息处理情况。建议使用 SimpleConsumer 消费类型，可以在消费时自定义消息的预估处理时长，若实际业务中预估的消息处理时长不符合预期，也可以通过接口提前修改。</li>
<li>需要异步化、批量消费等高级定制场景：SimpleConsumer 在 SDK 内部没有复杂的线程封装，完全由业务逻辑自由定制，可以实现异步分发、批量消费等高级定制场景。</li>
<li>需要自定义消费速率：SimpleConsumer 是由业务逻辑主动调用接口获取消息，因此可以自由调整获取消息的频率，自定义控制消费速率。</li>
</ul>
<h3 id="PullConsumer"><a href="#PullConsumer" class="headerlink" title="PullConsumer"></a>PullConsumer</h3><p>施工中。。。</p>
<h2 id="消费者分组和生产者分组"><a href="#消费者分组和生产者分组" class="headerlink" title="消费者分组和生产者分组"></a>消费者分组和生产者分组</h2><h3 id="生产者分组"><a href="#生产者分组" class="headerlink" title="生产者分组"></a>生产者分组</h3><p>RocketMQ 服务端 5.x 版本开始，<strong>生产者是匿名的</strong>，无需管理生产者分组（ProducerGroup）；对于历史版本服务端 3.x 和 4.x 版本，已经使用的生产者分组可以废弃无需再设置，且不会对当前业务产生影响。</p>
<h3 id="消费者分组"><a href="#消费者分组" class="headerlink" title="消费者分组"></a>消费者分组</h3><p>消费者分组是多个消费行为一致的消费者的负载均衡分组。消费者分组不是具体实体而是一个逻辑资源。通过消费者分组实现消费性能的水平扩展以及高可用容灾。</p>
<p>消费者分组中的订阅关系、投递顺序性、消费重试策略是一致的。</p>
<ul>
<li>订阅关系：Apache RocketMQ 以消费者分组的粒度管理订阅关系，实现订阅关系的管理和追溯。</li>
<li>投递顺序性：Apache RocketMQ 的服务端将消息投递给消费者消费时，支持顺序投递和并发投递，投递方式在消费者分组中统一配置。</li>
<li>消费重试策略： 消费者消费消息失败时的重试策略，包括重试次数、死信队列设置等。</li>
</ul>
<p>RocketMQ 服务端 5.x 版本：上述消费者的消费行为从关联的消费者分组中统一获取，因此，同一分组内所有消费者的消费行为必然是一致的，客户端无需关注。</p>
<p>RocketMQ 服务端 3.x&#x2F;4.x 历史版本：上述消费逻辑由消费者客户端接口定义，因此，您需要自己在消费者客户端设置时保证同一分组下的消费者的消费行为一致。(来自官方网站)</p>
<h2 id="如何解决顺序消费和重复消费？"><a href="#如何解决顺序消费和重复消费？" class="headerlink" title="如何解决顺序消费和重复消费？"></a>如何解决顺序消费和重复消费？</h2><p>其实，这些东西都是我在介绍消息队列带来的一些副作用的时候提到的，也就是说，这些问题不仅仅挂钩于 <code>RocketMQ</code> ，而是应该每个消息中间件都需要去解决的。</p>
<p>在上面我介绍 <code>RocketMQ</code> 的技术架构的时候我已经向你展示了 <strong>它是如何保证高可用的</strong> ，这里不涉及运维方面的搭建，如果你感兴趣可以自己去官网上照着例子搭建属于你自己的 <code>RocketMQ</code> 集群。</p>
<blockquote>
<p>其实 <code>Kafka</code> 的架构基本和 <code>RocketMQ</code> 类似，只是它注册中心使用了 <code>Zookeeper</code>、它的 <strong>分区</strong> 就相当于 <code>RocketMQ</code> 中的 <strong>队列</strong> 。还有一些小细节不同会在后面提到。</p>
</blockquote>
<h3 id="顺序消费"><a href="#顺序消费" class="headerlink" title="顺序消费"></a>顺序消费</h3><p>在上面的技术架构介绍中，我们已经知道了 <strong><code>RocketMQ</code> 在主题上是无序的、它只有在队列层面才是保证有序</strong> 的。</p>
<p>这又扯到两个概念——<strong>普通顺序</strong> 和 <strong>严格顺序</strong> 。</p>
<p>所谓普通顺序是指 消费者通过 <strong>同一个消费队列收到的消息是有顺序的</strong> ，不同消息队列收到的消息则可能是无顺序的。普通顺序消息在 <code>Broker</code> <strong>重启情况下不会保证消息顺序性</strong> (短暂时间) 。</p>
<p>所谓严格顺序是指 消费者收到的 <strong>所有消息</strong> 均是有顺序的。严格顺序消息 <strong>即使在异常情况下也会保证消息的顺序性</strong> 。</p>
<p>但是，严格顺序看起来虽好，实现它可会付出巨大的代价。如果你使用严格顺序模式，<code>Broker</code> 集群中只要有一台机器不可用，则整个集群都不可用。你还用啥？现在主要场景也就在 <code>binlog</code> 同步。</p>
<p>一般而言，我们的 <code>MQ</code> 都是能容忍短暂的乱序，所以推荐使用普通顺序模式。</p>
<p>那么，我们现在使用了 <strong>普通顺序模式</strong> ，我们从上面学习知道了在 <code>Producer</code> 生产消息的时候会进行轮询(取决你的负载均衡策略)来向同一主题的不同消息队列发送消息。那么如果此时我有几个消息分别是同一个订单的创建、支付、发货，在轮询的策略下这 <strong>三个消息会被发送到不同队列</strong> ，因为在不同的队列此时就无法使用 <code>RocketMQ</code> 带来的队列有序特性来保证消息有序性了。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/16ef3874585e096e.jpg"></p>
<p>那么，怎么解决呢？</p>
<p>其实很简单，我们需要处理的仅仅是将同一语义下的消息放入同一个队列(比如这里是同一个订单)，那我们就可以使用 <strong>Hash 取模法</strong> 来保证同一个订单在同一个队列中就行了。</p>
<p>RocketMQ 实现了两种队列选择算法，也可以自己实现</p>
<ul>
<li><p>轮询算法</p>
<ul>
<li>轮询算法就是向消息指定的 topic 所在队列中依次发送消息，保证消息均匀分布</li>
<li>是 RocketMQ 默认队列选择算法</li>
</ul>
</li>
<li><p>最小投递延迟算法</p>
<ul>
<li><p>每次消息投递的时候统计消息投递的延迟，选择队列时优先选择消息延时小的队列，导致消息分布不均匀,按照如下设置即可。</p>
</li>
<li><pre><code class="java">producer.setSendLatencyFaultEnable(true);
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 继承 MessageQueueSelector 实现</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    SendResult sendResult = producer.send(msg, new MessageQueueSelector() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public MessageQueue select(List&lt;MessageQueue&gt; mqs, Message msg, Object arg) &#123;</span><br><span class="line">            //从mqs中选择一个队列,可以根据msg特点选择</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, new Object());</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="特殊情况处理"><a href="#特殊情况处理" class="headerlink" title="特殊情况处理"></a>特殊情况处理</h3><h4 id="发送异常"><a href="#发送异常" class="headerlink" title="发送异常"></a>发送异常</h4><p>选择队列后会与 Broker 建立连接，通过网络请求将消息发送到 Broker 上，如果 Broker 挂了或者网络波动发送消息超时此时 RocketMQ 会进行重试。</p>
<p>重新选择其他 Broker 中的消息队列进行发送，默认重试两次，可以手动设置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">producer.setRetryTimesWhenSendFailed(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<h4 id="消息过大"><a href="#消息过大" class="headerlink" title="消息过大"></a>消息过大</h4><p>消息超过 4k 时 RocketMQ 会将消息压缩后在发送到 Broker 上，减少网络资源的占用。</p>
<h3 id="重复消费"><a href="#重复消费" class="headerlink" title="重复消费"></a>重复消费</h3><p>emmm，就两个字—— <strong>幂等</strong> 。在编程中一个<em>幂等</em> 操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。比如说，这个时候我们有一个订单的处理积分的系统，每当来一个消息的时候它就负责为创建这个订单的用户的积分加上相应的数值。可是有一次，消息队列发送给订单系统 FrancisQ 的订单信息，其要求是给 FrancisQ 的积分加上 500。但是积分系统在收到 FrancisQ 的订单信息处理完成之后返回给消息队列处理成功的信息的时候出现了网络波动(当然还有很多种情况，比如 Broker 意外重启等等)，这条回应没有发送成功。</p>
<p>那么，消息队列没收到积分系统的回应会不会尝试重发这个消息？问题就来了，我再发这个消息，万一它又给 FrancisQ 的账户加上 500 积分怎么办呢？</p>
<p>所以我们需要给我们的消费者实现 <strong>幂等</strong> ，也就是对同一个消息的处理结果，执行多少次都不变。</p>
<p>那么如何给业务实现幂等呢？这个还是需要结合具体的业务的。你可以使用 <strong>写入 <code>Redis</code></strong> 来保证，因为 <code>Redis</code> 的 <code>key</code> 和 <code>value</code> 就是天然支持幂等的。当然还有使用 <strong>数据库插入法</strong> ，基于数据库的唯一键来保证重复数据不会被插入多条。</p>
<p>不过最主要的还是需要 <strong>根据特定场景使用特定的解决方案</strong> ，你要知道你的消息消费是否是完全不可重复消费还是可以忍受重复消费的，然后再选择强校验和弱校验的方式。毕竟在 CS 领域还是很少有技术银弹的说法。</p>
<p>而在整个互联网领域，幂等不仅仅适用于消息队列的重复消费问题，这些实现幂等的方法，也同样适用于，<strong>在其他场景中来解决重复请求或者重复调用的问题</strong> 。比如将 HTTP 服务设计成幂等的，<strong>解决前端或者 APP 重复提交表单数据的问题</strong> ，也可以将一个微服务设计成幂等的，解决 <code>RPC</code> 框架自动重试导致的 <strong>重复调用问题</strong> 。</p>
<h2 id="RocketMQ-如何实现分布式事务？"><a href="#RocketMQ-如何实现分布式事务？" class="headerlink" title="RocketMQ 如何实现分布式事务？"></a>RocketMQ 如何实现分布式事务？</h2><p>如何解释分布式事务呢？事务大家都知道吧？<strong>要么都执行要么都不执行</strong> 。在同一个系统中我们可以轻松地实现事务，但是在分布式架构中，我们有很多服务是部署在不同系统之间的，而不同服务之间又需要进行调用。比如此时我下订单然后增加积分，如果保证不了分布式事务的话，就会出现 A 系统下了订单，但是 B 系统增加积分失败或者 A 系统没有下订单，B 系统却增加了积分。前者对用户不友好，后者对运营商不利，这是我们都不愿意见到的。</p>
<p>那么，如何去解决这个问题呢？</p>
<p>如今比较常见的分布式事务实现有 2PC、TCC 和事务消息(half 半消息机制)。每一种实现都有其特定的使用场景，但是也有各自的问题，<strong>都不是完美的解决方案</strong>。</p>
<p>在 <code>RocketMQ</code> 中使用的是 <strong>事务消息加上事务反查机制</strong> 来解决分布式事务问题的。我画了张图，大家可以对照着图进行理解。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/16ef38798d7a987f.png"></p>
<p>在第一步发送的 half 消息 ，它的意思是 <strong>在事务提交之前，对于消费者来说，这个消息是不可见的</strong> 。</p>
<blockquote>
<p>那么，如何做到写入消息但是对用户不可见呢？RocketMQ 事务消息的做法是：如果消息是 half 消息，将备份原消息的主题与消息消费队列，然后 <strong>改变主题</strong> 为 RMQ_SYS_TRANS_HALF_TOPIC。由于消费组未订阅该主题，故消费端无法消费 half 类型的消息，<strong>然后 RocketMQ 会开启一个定时任务，从 Topic 为 RMQ_SYS_TRANS_HALF_TOPIC 中拉取消息进行消费</strong>，根据生产者组获取一个服务提供者发送回查事务状态请求，根据事务状态来决定是提交或回滚消息。</p>
</blockquote>
<p>你可以试想一下，如果没有从第 5 步开始的 <strong>事务反查机制</strong> ，如果出现网路波动第 4 步没有发送成功，这样就会产生 MQ 不知道是不是需要给消费者消费的问题，他就像一个无头苍蝇一样。在 <code>RocketMQ</code> 中就是使用的上述的事务反查来解决的，而在 <code>Kafka</code> 中通常是直接抛出一个异常让用户来自行解决。</p>
<p>你还需要注意的是，在 <code>MQ Server</code> 指向系统 B 的操作已经和系统 A 不相关了，也就是说在消息队列中的分布式事务是——<strong>本地事务和存储消息到消息队列才是同一个事务</strong>。这样也就产生了事务的<strong>最终一致性</strong>，因为整个过程是异步的，<strong>每个系统只要保证它自己那一部分的事务就行了</strong>。</p>
<p>实践中会遇到的问题：事务消息需要一个事务监听器来监听本地事务是否成功，并且事务监听器接口只允许被实现一次。那就意味着需要把各种事务消息的本地事务都写在一个接口方法里面，必将会产生大量的耦合和类型判断。采用函数 Function 接口来包装整个业务过程，作为一个参数传递到监听器的接口方法中。再调用 Function 的 apply() 方法来执行业务，事务也会在 apply() 方法中执行。让监听器与业务之间实现解耦，使之具备了真实生产环境中的可行性。</p>
<p>1.模拟一个添加用户浏览记录的需求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/add&quot;)</span></span><br><span class="line"><span class="meta">@ApiOperation(&quot;添加用户浏览记录&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;TransactionSendResult&gt; <span class="title function_">add</span><span class="params">(Long userId, Long forecastLogId)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 函数式编程:浏览记录入库</span></span><br><span class="line">        Function&lt;String, Boolean&gt; function = transactionId -&gt; viewHistoryHandler.addViewHistory(transactionId, userId, forecastLogId);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Long&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        hashMap.put(<span class="string">&quot;userId&quot;</span>, userId);</span><br><span class="line">        hashMap.put(<span class="string">&quot;forecastLogId&quot;</span>, forecastLogId);</span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonString</span> <span class="operator">=</span> JSON.toJSONString(hashMap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送事务消息;将本地的事务操作,用函数Function接口接收,作为一个参数传入到方法中</span></span><br><span class="line">        <span class="type">TransactionSendResult</span> <span class="variable">transactionSendResult</span> <span class="operator">=</span> mqProducerService.sendTransactionMessage(jsonString, MQDestination.TAG_ADD_VIEW_HISTORY, function);</span><br><span class="line">        <span class="keyword">return</span> Result.success(transactionSendResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.发送事务消息的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送事务消息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> msgBody</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tag</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> function</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> TransactionSendResult <span class="title function_">sendTransactionMessage</span><span class="params">(String msgBody, String tag, Function&lt;String, Boolean&gt; function)</span> &#123;</span><br><span class="line">    <span class="comment">// 构建消息体</span></span><br><span class="line">    Message&lt;String&gt; message = buildMessage(msgBody);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建消息投递信息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">destination</span> <span class="operator">=</span> buildDestination(tag);</span><br><span class="line"></span><br><span class="line">    <span class="type">TransactionSendResult</span> <span class="variable">result</span> <span class="operator">=</span> rocketMQTemplate.sendMessageInTransaction(destination, message, function);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.生产者消息监听器,只允许一个类去实现该监听器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RocketMQTransactionListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionMsgListener</span> <span class="keyword">implements</span> <span class="title class_">RocketMQLocalTransactionListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisService redisService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行本地事务（在发送消息成功时执行）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> commit or rollback or unknown</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> RocketMQLocalTransactionState <span class="title function_">executeLocalTransaction</span><span class="params">(Message message, Object o)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、获取事务ID</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">transactionId</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            transactionId = message.getHeaders().get(<span class="string">&quot;rocketmq_TRANSACTION_ID&quot;</span>).toString();</span><br><span class="line">            <span class="comment">// 2、判断传入函数对象是否为空，如果为空代表没有要执行的业务直接抛弃消息</span></span><br><span class="line">            <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//返回ROLLBACK状态的消息会被丢弃</span></span><br><span class="line">                log.info(<span class="string">&quot;事务消息回滚，没有需要处理的业务 transactionId=&#123;&#125;&quot;</span>, transactionId);</span><br><span class="line">                <span class="keyword">return</span> RocketMQLocalTransactionState.ROLLBACK;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将Object o转换成Function对象</span></span><br><span class="line">            Function&lt;String, Boolean&gt; function = (Function&lt;String, Boolean&gt;) o;</span><br><span class="line">            <span class="comment">// 执行业务 事务也会在function.apply中执行</span></span><br><span class="line">            <span class="type">Boolean</span> <span class="variable">apply</span> <span class="operator">=</span> function.apply(transactionId);</span><br><span class="line">            <span class="keyword">if</span> (apply) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;事务提交，消息正常处理 transactionId=&#123;&#125;&quot;</span>, transactionId);</span><br><span class="line">                <span class="comment">//返回COMMIT状态的消息会立即被消费者消费到</span></span><br><span class="line">                <span class="keyword">return</span> RocketMQLocalTransactionState.COMMIT;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;出现异常 返回ROLLBACK transactionId=&#123;&#125;&quot;</span>, transactionId);</span><br><span class="line">            <span class="keyword">return</span> RocketMQLocalTransactionState.ROLLBACK;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> RocketMQLocalTransactionState.ROLLBACK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 事务回查机制，检查本地事务的状态</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> RocketMQLocalTransactionState <span class="title function_">checkLocalTransaction</span><span class="params">(Message message)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">transactionId</span> <span class="operator">=</span> message.getHeaders().get(<span class="string">&quot;rocketmq_TRANSACTION_ID&quot;</span>).toString();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查redis</span></span><br><span class="line">        <span class="type">MqTransaction</span> <span class="variable">mqTransaction</span> <span class="operator">=</span> redisService.getCacheObject(<span class="string">&quot;mqTransaction:&quot;</span> + transactionId);</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(mqTransaction)) &#123;</span><br><span class="line">            <span class="keyword">return</span> RocketMQLocalTransactionState.ROLLBACK;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> RocketMQLocalTransactionState.COMMIT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.模拟的业务场景,这里的方法必须提取出来,放在别的类里面.如果调用方与被调用方在同一个类中,会发生事务失效的问题.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ViewHistoryHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IViewHistoryService viewHistoryService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IMqTransactionService mqTransactionService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisService redisService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 浏览记录入库</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> transactionId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> forecastLogId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">addViewHistory</span><span class="params">(String transactionId, Long userId, Long forecastLogId)</span> &#123;</span><br><span class="line">        <span class="comment">// 构建浏览记录</span></span><br><span class="line">        <span class="type">ViewHistory</span> <span class="variable">viewHistory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ViewHistory</span>();</span><br><span class="line">        viewHistory.setUserId(userId);</span><br><span class="line">        viewHistory.setForecastLogId(forecastLogId);</span><br><span class="line">        viewHistory.setCreateTime(LocalDateTime.now());</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">save</span> <span class="operator">=</span> viewHistoryService.save(viewHistory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 本地事务信息</span></span><br><span class="line">        <span class="type">MqTransaction</span> <span class="variable">mqTransaction</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MqTransaction</span>();</span><br><span class="line">        mqTransaction.setTransactionId(transactionId);</span><br><span class="line">        mqTransaction.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        mqTransaction.setStatus(MqTransaction.StatusEnum.VALID.getStatus());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.可以把事务信息存数据库</span></span><br><span class="line">        mqTransactionService.save(mqTransaction);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.也可以选择存redis,4个小时有效期,&#x27;4个小时&#x27;是RocketMQ内置的最大回查超时时长,过期未确认将强制回滚</span></span><br><span class="line">        redisService.setCacheObject(<span class="string">&quot;mqTransaction:&quot;</span> + transactionId, mqTransaction, <span class="number">4L</span>, TimeUnit.HOURS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 放开注释,模拟异常,事务回滚</span></span><br><span class="line">        <span class="comment">// int i = 10 / 0;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> save;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.消费消息,以及幂等处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RocketMQMessageListener(topic = MQDestination.TOPIC, selectorExpression = MQDestination.TAG_ADD_VIEW_HISTORY, consumerGroup = MQDestination.TAG_ADD_VIEW_HISTORY)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerAddViewHistory</span> <span class="keyword">implements</span> <span class="title class_">RocketMQListener</span>&lt;Message&gt; &#123;</span><br><span class="line">    <span class="comment">// 监听到消息就会执行此方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="comment">// 幂等校验</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">transactionId</span> <span class="operator">=</span> message.getTransactionId();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查redis</span></span><br><span class="line">        <span class="type">MqTransaction</span> <span class="variable">mqTransaction</span> <span class="operator">=</span> redisService.getCacheObject(<span class="string">&quot;mqTransaction:&quot;</span> + transactionId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不存在事务记录</span></span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(mqTransaction)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 已消费</span></span><br><span class="line">        <span class="keyword">if</span> (Objects.equals(mqTransaction.getStatus(), MqTransaction.StatusEnum.CONSUMED.getStatus())) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">        Map&lt;String, Long&gt; map = JSON.parseObject(msg, <span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;HashMap&lt;String, Long&gt;&gt;() &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> map.get(<span class="string">&quot;userId&quot;</span>);</span><br><span class="line">        <span class="type">Long</span> <span class="variable">forecastLogId</span> <span class="operator">=</span> map.get(<span class="string">&quot;forecastLogId&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下游的业务处理</span></span><br><span class="line">        <span class="comment">// TODO 记录用户喜好,更新用户画像</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 更新&#x27;证券预测文章&#x27;的浏览量,重新计算文章的曝光排序</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新状态为已消费</span></span><br><span class="line">        mqTransaction.setUpdateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        mqTransaction.setStatus(MqTransaction.StatusEnum.CONSUMED.getStatus());</span><br><span class="line">        redisService.setCacheObject(<span class="string">&quot;mqTransaction:&quot;</span> + transactionId, mqTransaction, <span class="number">4L</span>, TimeUnit.HOURS);</span><br><span class="line">        log.info(<span class="string">&quot;监听到消息：msg=&#123;&#125;&quot;</span>, JSON.toJSONString(map));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="如何解决消息堆积问题？"><a href="#如何解决消息堆积问题？" class="headerlink" title="如何解决消息堆积问题？"></a>如何解决消息堆积问题？</h2><p>在上面我们提到了消息队列一个很重要的功能——<strong>削峰</strong> 。那么如果这个峰值太大了导致消息堆积在队列中怎么办呢？</p>
<p>其实这个问题可以将它广义化，因为产生消息堆积的根源其实就只有两个——生产者生产太快或者消费者消费太慢。</p>
<p>我们可以从多个角度去思考解决这个问题，当流量到峰值的时候是因为生产者生产太快，我们可以使用一些 <strong>限流降级</strong> 的方法，当然你也可以增加多个消费者实例去水平扩展增加消费能力来匹配生产的激增。如果消费者消费过慢的话，我们可以先检查 <strong>是否是消费者出现了大量的消费错误</strong> ，或者打印一下日志查看是否是哪一个线程卡死，出现了锁资源不释放等等的问题。</p>
<blockquote>
<p>当然，最快速解决消息堆积问题的方法还是增加消费者实例，不过 <strong>同时你还需要增加每个主题的队列数量</strong> 。</p>
<p>别忘了在 <code>RocketMQ</code> 中，<strong>一个队列只会被一个消费者消费</strong> ，如果你仅仅是增加消费者实例就会出现我一开始给你画架构图的那种情况。</p>
</blockquote>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/16ef387d939ab66d.jpg"></p>
<h2 id="什么是回溯消费？"><a href="#什么是回溯消费？" class="headerlink" title="什么是回溯消费？"></a>什么是回溯消费？</h2><p>回溯消费是指 <code>Consumer</code> 已经消费成功的消息，由于业务上需求需要重新消费，在<code>RocketMQ</code> 中， <code>Broker</code> 在向<code>Consumer</code> 投递成功消息后，<strong>消息仍然需要保留</strong> 。并且重新消费一般是按照时间维度，例如由于 <code>Consumer</code> 系统故障，恢复后需要重新消费 1 小时前的数据，那么 <code>Broker</code> 要提供一种机制，可以按照时间维度来回退消费进度。<code>RocketMQ</code> 支持按照时间回溯消费，时间维度精确到毫秒。</p>
<p>这是官方文档的解释，我直接照搬过来就当科普了 😁😁😁。</p>
<h2 id="RocketMQ-如何保证高性能读写"><a href="#RocketMQ-如何保证高性能读写" class="headerlink" title="RocketMQ 如何保证高性能读写"></a>RocketMQ 如何保证高性能读写</h2><h3 id="传统-IO-方式"><a href="#传统-IO-方式" class="headerlink" title="传统 IO 方式"></a>传统 IO 方式</h3><p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/31699457085_.pic.jpg"></p>
<p>传统的 IO 读写其实就是 read + write 的操作，整个过程会分为如下几步</p>
<ul>
<li>用户调用 read()方法，开始读取数据，此时发生一次上下文从用户态到内核态的切换，也就是图示的切换 1</li>
<li>将磁盘数据通过 DMA 拷贝到内核缓存区</li>
<li>将内核缓存区的数据拷贝到用户缓冲区，这样用户，也就是我们写的代码就能拿到文件的数据</li>
<li>read()方法返回，此时就会从内核态切换到用户态，也就是图示的切换 2</li>
<li>当我们拿到数据之后，就可以调用 write()方法，此时上下文会从用户态切换到内核态，即图示切换 3</li>
<li>CPU 将用户缓冲区的数据拷贝到 Socket 缓冲区</li>
<li>将 Socket 缓冲区数据拷贝至网卡</li>
<li>write()方法返回，上下文重新从内核态切换到用户态，即图示切换 4</li>
</ul>
<p>整个过程发生了 4 次上下文切换和 4 次数据的拷贝，这在高并发场景下肯定会严重影响读写性能故引入了零拷贝技术</p>
<h3 id="零拷贝技术"><a href="#零拷贝技术" class="headerlink" title="零拷贝技术"></a>零拷贝技术</h3><h4 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h4><p>mmap（memory map）是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。</p>
<p>简单地说就是内核缓冲区和应用缓冲区共享，从而减少了从读缓冲区到用户缓冲区的一次 CPU 拷贝。基于此上述架构图可变为：</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/41699457086_.pic.jpg"></p>
<p>基于 mmap IO 读写其实就变成 mmap + write 的操作，也就是用 mmap 替代传统 IO 中的 read 操作。</p>
<p>当用户发起 mmap 调用的时候会发生上下文切换 1，进行内存映射，然后数据被拷贝到内核缓冲区，mmap 返回，发生上下文切换 2；随后用户调用 write，发生上下文切换 3，将内核缓冲区的数据拷贝到 Socket 缓冲区，write 返回，发生上下文切换 4。</p>
<p>发生 4 次上下文切换和 3 次 IO 拷贝操作，在 Java 中的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>).getChannel();</span><br><span class="line"><span class="type">MappedByteBuffer</span> <span class="variable">mappedByteBuffer</span> <span class="operator">=</span> fileChannel.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, fileChannel.size());</span><br></pre></td></tr></table></figure>

<h4 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile"></a>sendfile</h4><p>sendfile()跟 mmap()一样，也会减少一次 CPU 拷贝，但是它同时也会减少两次上下文切换。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/51699457087_.pic.jpg"></p>
<p>如图，用户在发起 sendfile()调用时会发生切换 1，之后数据通过 DMA 拷贝到内核缓冲区，之后再将内核缓冲区的数据 CPU 拷贝到 Socket 缓冲区，最后拷贝到网卡，sendfile()返回，发生切换 2。发生了 3 次拷贝和两次切换。Java 也提供了相应 api：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> FileChannel.open(Paths.get(<span class="string">&quot;./test.txt&quot;</span>), StandardOpenOption.WRITE, StandardOpenOption.CREATE);</span><br><span class="line"><span class="comment">//调用transferTo方法向目标数据传输</span></span><br><span class="line">channel.transferTo(position, len, target);</span><br></pre></td></tr></table></figure>

<p>在如上代码中，并没有文件的读写操作，而是直接将文件的数据传输到 target 目标缓冲区，也就是说，sendfile 是无法知道文件的具体的数据的；但是 mmap 不一样，他是可以修改内核缓冲区的数据的。假设如果需要对文件的内容进行修改之后再传输，只有 mmap 可以满足。</p>
<p>通过上面的一些介绍，结论是基于零拷贝技术，可以减少 CPU 的拷贝次数和上下文切换次数，从而可以实现文件高效的读写操作。</p>
<p>RocketMQ 内部主要是使用基于 mmap 实现的零拷贝(其实就是调用上述提到的 api)，用来读写文件，这也是 RocketMQ 为什么快的一个很重要原因。</p>
<h2 id="RocketMQ-的刷盘机制"><a href="#RocketMQ-的刷盘机制" class="headerlink" title="RocketMQ 的刷盘机制"></a>RocketMQ 的刷盘机制</h2><p>上面我讲了那么多的 <code>RocketMQ</code> 的架构和设计原理，你有没有好奇</p>
<p>在 <code>Topic</code> 中的 <strong>队列是以什么样的形式存在的？</strong></p>
<p><strong>队列中的消息又是如何进行存储持久化的呢？</strong></p>
<p>我在上文中提到的 <strong>同步刷盘</strong> 和 <strong>异步刷盘</strong> 又是什么呢？它们会给持久化带来什么样的影响呢？</p>
<p>下面我将给你们一一解释。</p>
<h3 id="同步刷盘和异步刷盘"><a href="#同步刷盘和异步刷盘" class="headerlink" title="同步刷盘和异步刷盘"></a>同步刷盘和异步刷盘</h3><p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/16ef387fba311cda-20230814005009889.jpg"></p>
<p>如上图所示，在同步刷盘中需要等待一个刷盘成功的 <code>ACK</code> ，同步刷盘对 <code>MQ</code> 消息可靠性来说是一种不错的保障，但是 <strong>性能上会有较大影响</strong> ，一般地适用于金融等特定业务场景。</p>
<p>而异步刷盘往往是开启一个线程去异步地执行刷盘操作。消息刷盘采用后台异步线程提交的方式进行， <strong>降低了读写延迟</strong> ，提高了 <code>MQ</code> 的性能和吞吐量，一般适用于如发验证码等对于消息保证要求不太高的业务场景。</p>
<p>一般地，<strong>异步刷盘只有在 <code>Broker</code> 意外宕机的时候会丢失部分数据</strong>，你可以设置 <code>Broker</code> 的参数 <code>FlushDiskType</code> 来调整你的刷盘策略(ASYNC_FLUSH 或者 SYNC_FLUSH)。</p>
<h3 id="同步复制和异步复制"><a href="#同步复制和异步复制" class="headerlink" title="同步复制和异步复制"></a>同步复制和异步复制</h3><p>上面的同步刷盘和异步刷盘是在单个结点层面的，而同步复制和异步复制主要是指的 <code>Borker</code> 主从模式下，主节点返回消息给客户端的时候是否需要同步从节点。</p>
<ul>
<li>同步复制：也叫 “同步双写”，也就是说，<strong>只有消息同步双写到主从节点上时才返回写入成功</strong> 。</li>
<li>异步复制：<strong>消息写入主节点之后就直接返回写入成功</strong> 。</li>
</ul>
<p>然而，很多事情是没有完美的方案的，就比如我们进行消息写入的节点越多就更能保证消息的可靠性，但是随之的性能也会下降，所以需要程序员根据特定业务场景去选择适应的主从复制方案。</p>
<p>那么，<strong>异步复制会不会也像异步刷盘那样影响消息的可靠性呢？</strong></p>
<p>答案是不会的，因为两者就是不同的概念，对于消息可靠性是通过不同的刷盘策略保证的，而像异步同步复制策略仅仅是影响到了 <strong>可用性</strong> 。为什么呢？其主要原因<strong>是 <code>RocketMQ</code> 是不支持自动主从切换的，当主节点挂掉之后，生产者就不能再给这个主节点生产消息了</strong>。</p>
<p>比如这个时候采用异步复制的方式，在主节点还未发送完需要同步的消息的时候主节点挂掉了，这个时候从节点就少了一部分消息。但是此时生产者无法再给主节点生产消息了，<strong>消费者可以自动切换到从节点进行消费</strong>(仅仅是消费)，所以在主节点挂掉的时间只会产生主从结点短暂的消息不一致的情况，降低了可用性，而当主节点重启之后，从节点那部分未来得及复制的消息还会继续复制。</p>
<p>在单主从架构中，如果一个主节点挂掉了，那么也就意味着整个系统不能再生产了。那么这个可用性的问题能否解决呢？<strong>一个主从不行那就多个主从的呗</strong>，别忘了在我们最初的架构图中，每个 <code>Topic</code> 是分布在不同 <code>Broker</code> 中的。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/16ef38687488a5asadasfg4.jpg"></p>
<p>但是这种复制方式同样也会带来一个问题，那就是无法保证 <strong>严格顺序</strong> 。在上文中我们提到了如何保证的消息顺序性是通过将一个语义的消息发送在同一个队列中，使用 <code>Topic</code> 下的队列来保证顺序性的。如果此时我们主节点 A 负责的是订单 A 的一系列语义消息，然后它挂了，这样其他节点是无法代替主节点 A 的，如果我们任意节点都可以存入任何消息，那就没有顺序性可言了。</p>
<p>而在 <code>RocketMQ</code> 中采用了 <code>Dledger</code> 解决这个问题。他要求在写入消息的时候，要求<strong>至少消息复制到半数以上的节点之后</strong>，才给客⼾端返回写⼊成功，并且它是⽀持通过选举来动态切换主节点的。这里我就不展开说明了，读者可以自己去了解。</p>
<blockquote>
<p>也不是说 <code>Dledger</code> 是个完美的方案，至少在 <code>Dledger</code> 选举过程中是无法提供服务的，而且他必须要使用三个节点或以上，如果多数节点同时挂掉他也是无法保证可用性的，而且要求消息复制半数以上节点的效率和直接异步复制还是有一定的差距的。</p>
</blockquote>
<h3 id="存储机制"><a href="#存储机制" class="headerlink" title="存储机制"></a>存储机制</h3><p>还记得上面我们一开始的三个问题吗？到这里第三个问题已经解决了。</p>
<p>但是，在 <code>Topic</code> 中的 <strong>队列是以什么样的形式存在的？队列中的消息又是如何进行存储持久化的呢？</strong> 还未解决，其实这里涉及到了 <code>RocketMQ</code> 是如何设计它的存储结构了。我首先想大家介绍 <code>RocketMQ</code> 消息存储架构中的三大角色——<code>CommitLog</code>、<code>ConsumeQueue</code> 和 <code>IndexFile</code> 。</p>
<ul>
<li><code>CommitLog</code>：<strong>消息主体以及元数据的存储主体</strong>，存储 <code>Producer</code> 端写入的消息主体内容,消息内容不是定长的。单个文件大小默认 1G ，文件名长度为 20 位，左边补零，剩余为起始偏移量，比如 00000000000000000000 代表了第一个文件，起始偏移量为 0，文件大小为 1G&#x3D;1073741824；当第一个文件写满了，第二个文件为 00000000001073741824，起始偏移量为 1073741824，以此类推。消息主要是<strong>顺序写入日志文件</strong>，当文件满了，写入下一个文件。</li>
<li><code>ConsumeQueue</code>：消息消费队列，<strong>引入的目的主要是提高消息消费的性能</strong>(我们再前面也讲了)，由于<code>RocketMQ</code> 是基于主题 <code>Topic</code> 的订阅模式，消息消费是针对主题进行的，如果要遍历 <code>commitlog</code> 文件中根据 <code>Topic</code> 检索消息是非常低效的。<code>Consumer</code> 即可根据 <code>ConsumeQueue</code> 来查找待消费的消息。其中，<code>ConsumeQueue</code>（逻辑消费队列）<strong>作为消费消息的索引</strong>，保存了指定 <code>Topic</code> 下的队列消息在 <code>CommitLog</code> 中的<strong>起始物理偏移量 <code>offset</code> <strong>，消息大小 <code>size</code> 和消息 <code>Tag</code> 的 <code>HashCode</code> 值。</strong><code>consumequeue</code> 文件可以看成是基于 <code>topic</code> 的 <code>commitlog</code> 索引文件</strong>，故 <code>consumequeue</code> 文件夹的组织方式如下：topic&#x2F;queue&#x2F;file 三层组织结构，具体存储路径为：$HOME&#x2F;store&#x2F;consumequeue&#x2F;{topic}&#x2F;{queueId}&#x2F;{fileName}。同样 <code>consumequeue</code> 文件采取定长设计，每一个条目共 20 个字节，分别为 8 字节的 <code>commitlog</code> 物理偏移量、4 字节的消息长度、8 字节 tag <code>hashcode</code>，单个文件由 30W 个条目组成，可以像数组一样随机访问每一个条目，每个 <code>ConsumeQueue</code>文件大小约 5.72M；</li>
<li><code>IndexFile</code>：<code>IndexFile</code>（索引文件）提供了一种可以通过 key 或时间区间来查询消息的方法。这里只做科普不做详细介绍。</li>
</ul>
<p>总结来说，整个消息存储的结构，最主要的就是 <code>CommitLoq</code> 和 <code>ConsumeQueue</code> 。而 <code>ConsumeQueue</code> 你可以大概理解为 <code>Topic</code> 中的队列。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/16ef3884c02acc72.png"></p>
<p><code>RocketMQ</code> 采用的是 <strong>混合型的存储结构</strong> ，即为 <code>Broker</code> 单个实例下所有的队列共用一个日志数据文件来存储消息。有意思的是在同样高并发的 <code>Kafka</code> 中会为每个 <code>Topic</code> 分配一个存储文件。这就有点类似于我们有一大堆书需要装上书架，<code>RocketMQ</code> 是不分书的种类直接成批的塞上去的，而 <code>Kafka</code> 是将书本放入指定的分类区域的。</p>
<p>而 <code>RocketMQ</code> 为什么要这么做呢？原因是 <strong>提高数据的写入效率</strong> ，不分 <code>Topic</code> 意味着我们有更大的几率获取 <strong>成批</strong> 的消息进行数据写入，但也会带来一个麻烦就是读取消息的时候需要遍历整个大文件，这是非常耗时的。</p>
<p>所以，在 <code>RocketMQ</code> 中又使用了 <code>ConsumeQueue</code> 作为每个队列的索引文件来 <strong>提升读取消息的效率</strong>。我们可以直接根据队列的消息序号，计算出索引的全局位置（索引序号*索引固定⻓度 20），然后直接读取这条索引，再根据索引中记录的消息的全局位置，找到消息。</p>
<p>讲到这里，你可能对 <code>RocketMQ</code> 的存储架构还有些模糊，没事，我们结合着图来理解一下。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/16ef388763c25c62.jpg"></p>
<p>emmm，是不是有一点复杂 🤣，看英文图片和英文文档的时候就不要怂，硬着头皮往下看就行。</p>
<blockquote>
<p>如果上面没看懂的读者一定要认真看下面的流程分析！</p>
</blockquote>
<p>首先，在最上面的那一块就是我刚刚讲的你现在可以直接 **把 <code>ConsumerQueue</code> 理解为 <code>Queue</code>**。</p>
<p>在图中最左边说明了红色方块代表被写入的消息，虚线方块代表等待被写入的。左边的生产者发送消息会指定 <code>Topic</code>、<code>QueueId</code> 和具体消息内容，而在 <code>Broker</code> 中管你是哪门子消息，他直接 <strong>全部顺序存储到了 CommitLog</strong>。而根据生产者指定的 <code>Topic</code> 和 <code>QueueId</code> 将这条消息本身在 <code>CommitLog</code> 的偏移(offset)，消息本身大小，和 tag 的 hash 值存入对应的 <code>ConsumeQueue</code> 索引文件中。而在每个队列中都保存了 <code>ConsumeOffset</code> 即每个消费者组的消费位置(我在架构那里提到了，忘了的同学可以回去看一下)，而消费者拉取消息进行消费的时候只需要根据 <code>ConsumeOffset</code> 获取下一个未被消费的消息就行了。</p>
<p>上述就是我对于整个消息存储架构的大概理解(这里不涉及到一些细节讨论，比如稀疏索引等等问题)，希望对你有帮助。</p>
<p>因为有一个知识点因为写嗨了忘讲了，想想在哪里加也不好，所以我留给大家去思考 🤔🤔 一下吧。</p>
<p>为什么 <code>CommitLog</code> 文件要设计成固定大小的长度呢？提醒：<strong>内存映射机制</strong>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总算把这篇博客写完了。我讲的你们还记得吗 😅？</p>
<p>这篇文章中我主要想大家介绍了</p>
<ol>
<li>消息队列出现的原因</li>
<li>消息队列的作用(异步，解耦，削峰)</li>
<li>消息队列带来的一系列问题(消息堆积、重复消费、顺序消费、分布式事务等等)</li>
<li>消息队列的两种消息模型——队列和主题模式</li>
<li>分析了 <code>RocketMQ</code> 的技术架构(<code>NameServer</code>、<code>Broker</code>、<code>Producer</code>、<code>Consumer</code>)</li>
<li>结合 <code>RocketMQ</code> 回答了消息队列副作用的解决方案</li>
<li>介绍了 <code>RocketMQ</code> 的存储机制和刷盘策略。</li>
</ol>
<p>等等。。。</p>
<!-- @include: @article-footer.snippet.md -->

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2024/11/04/sql-questions-03/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/11/04/sql-questions-03/" itemprop="url">SQL常见面试题总结（3）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-11-04T21:14:30+08:00">
                2024-11-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/" itemprop="url" rel="index">
                    <span itemprop="name">面试问题</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2024/11/04/sql-questions-03/" class="leancloud_visitors" data-flag-title="SQL常见面试题总结（3）">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  11.9k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  55 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>题目来源于：<a href="https://www.nowcoder.com/exam/oj?page=1&tab=SQL%E7%AF%87&topicId=240">牛客题霸 - SQL 进阶挑战</a></p>
</blockquote>
<p>较难或者困难的题目可以根据自身实际情况和面试需要来决定是否要跳过。</p>
<h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><h3 id="SQL-类别高难度试卷得分的截断平均值（较难）"><a href="#SQL-类别高难度试卷得分的截断平均值（较难）" class="headerlink" title="SQL 类别高难度试卷得分的截断平均值（较难）"></a>SQL 类别高难度试卷得分的截断平均值（较难）</h3><p><strong>描述</strong>： 牛客的运营同学想要查看大家在 SQL 类别中高难度试卷的得分情况。</p>
<p>请你帮她从<code>exam_record</code>数据表中计算所有用户完成 SQL 类别高难度试卷得分的截断平均值（去掉一个最大值和一个最小值后的平均值）。</p>
<p>示例数据：<code>examination_info</code>（<code>exam_id</code> 试卷 ID, tag 试卷类别, <code>difficulty</code> 试卷难度, <code>duration</code> 考试时长, <code>release_time</code> 发布时间）</p>
<table>
<thead>
<tr>
<th>id</th>
<th>exam_id</th>
<th>tag</th>
<th>difficulty</th>
<th>duration</th>
<th>release_time</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>9001</td>
<td>SQL</td>
<td>hard</td>
<td>60</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>2</td>
<td>9002</td>
<td>算法</td>
<td>medium</td>
<td>80</td>
<td>2020-08-02 10:00:00</td>
</tr>
</tbody></table>
<p>示例数据：<code>exam_record</code>（uid 用户 ID, exam_id 试卷 ID, start_time 开始作答时间, submit_time 交卷时间, score 得分）</p>
<table>
<thead>
<tr>
<th>id</th>
<th>uid</th>
<th>exam_id</th>
<th>start_time</th>
<th>submit_time</th>
<th>score</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1001</td>
<td>9001</td>
<td>2020-01-02 09:01:01</td>
<td>2020-01-02 09:21:01</td>
<td>80</td>
</tr>
<tr>
<td>2</td>
<td>1001</td>
<td>9001</td>
<td>2021-05-02 10:01:01</td>
<td>2021-05-02 10:30:01</td>
<td>81</td>
</tr>
<tr>
<td>3</td>
<td>1001</td>
<td>9001</td>
<td>2021-06-02 19:01:01</td>
<td>2021-06-02 19:31:01</td>
<td>84</td>
</tr>
<tr>
<td>4</td>
<td>1001</td>
<td>9002</td>
<td>2021-09-05 19:01:01</td>
<td>2021-09-05 19:40:01</td>
<td>89</td>
</tr>
<tr>
<td>5</td>
<td>1001</td>
<td>9001</td>
<td>2021-09-02 12:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>6</td>
<td>1001</td>
<td>9002</td>
<td>2021-09-01 12:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>7</td>
<td>1002</td>
<td>9002</td>
<td>2021-02-02 19:01:01</td>
<td>2021-02-02 19:30:01</td>
<td>87</td>
</tr>
<tr>
<td>8</td>
<td>1002</td>
<td>9001</td>
<td>2021-05-05 18:01:01</td>
<td>2021-05-05 18:59:02</td>
<td>90</td>
</tr>
<tr>
<td>9</td>
<td>1003</td>
<td>9001</td>
<td>2021-09-07 12:01:01</td>
<td>2021-09-07 10:31:01</td>
<td>50</td>
</tr>
<tr>
<td>10</td>
<td>1004</td>
<td>9001</td>
<td>2021-09-06 10:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
</tbody></table>
<p>根据输入你的查询结果如下：</p>
<table>
<thead>
<tr>
<th>tag</th>
<th>difficulty</th>
<th>clip_avg_score</th>
</tr>
</thead>
<tbody><tr>
<td>SQL</td>
<td>hard</td>
<td>81.7</td>
</tr>
</tbody></table>
<p>从<code>examination_info</code>表可知，试卷 9001 为高难度 SQL 试卷，该试卷被作答的得分有[80,81,84,90,50]，去除最高分和最低分后为[80,81,84]，平均分为 81.6666667，保留一位小数后为 81.7</p>
<p><strong>输入描述：</strong></p>
<p>输入数据中至少有 3 个有效分数</p>
<p><strong>思路一：</strong> 要找出高难度 sql 试卷，肯定需要联 examination_info 这张表，然后找出高难度的课程，由 examination_info 得知，高难度 sql 的 exam_id 为 9001，那么等下就以 exam_id &#x3D; 9001 作为条件去查询；</p>
<p>先找出 9001 号考试 <code>select * from exam_record where exam_id = 9001</code></p>
<p>然后，找出最高分 <code>select max(score) 最高分 from exam_record where exam_id = 9001</code></p>
<p>接着，找出最低分 <code>select min(score) 最低分 from exam_record where exam_id = 9001</code></p>
<p>在查询出来的分数结果集当中，去掉最高分和最低分，最直观能想到的就是 NOT IN 或者 用 NOT EXISTS 也行，这里以 NOT IN 来做</p>
<p>首先将主体写出来<code>select tag, difficulty, round(avg(score), 1) clip_avg_score from examination_info info INNER JOIN exam_record record</code></p>
<p><strong>小 tips</strong> : MYSQL 的 <code>ROUND()</code> 函数 ,<code>ROUND(X)</code>返回参数 X 最近似的整数 <code>ROUND(X,D)</code>返回 X ,其值保留到小数点后 D 位,第 D 位的保留方式为四舍五入。</p>
<p>再将上面的 “碎片” 语句拼凑起来即可， 注意在 NOT IN 中两个子查询用 UNION ALL 来关联，用 union 把 max 和 min 的结果集中在一行当中，这样形成一列多行的效果。</p>
<p><strong>答案一：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> tag, difficulty, ROUND(<span class="built_in">AVG</span>(score), <span class="number">1</span>) clip_avg_score</span><br><span class="line">	<span class="keyword">FROM</span> examination_info info  <span class="keyword">INNER</span> <span class="keyword">JOIN</span> exam_record record</span><br><span class="line">		<span class="keyword">WHERE</span> info.exam_id <span class="operator">=</span> record.exam_id</span><br><span class="line">			<span class="keyword">AND</span>  record.exam_id <span class="operator">=</span> <span class="number">9001</span></span><br><span class="line">				<span class="keyword">AND</span> record.score <span class="keyword">NOT</span> <span class="keyword">IN</span>(</span><br><span class="line">					<span class="keyword">SELECT</span> <span class="built_in">MAX</span>(score)</span><br><span class="line">						<span class="keyword">FROM</span> exam_record</span><br><span class="line">							<span class="keyword">WHERE</span> exam_id <span class="operator">=</span> <span class="number">9001</span></span><br><span class="line">								<span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line">					<span class="keyword">SELECT</span> <span class="built_in">MIN</span>(score)</span><br><span class="line">						<span class="keyword">FROM</span> exam_record</span><br><span class="line">							<span class="keyword">WHERE</span> exam_id <span class="operator">=</span> <span class="number">9001</span></span><br><span class="line">				)</span><br></pre></td></tr></table></figure>

<p>这是最直观，也是最容易想到的解法，但是还有待改进，这算是投机取巧过关，其实严格按照题目要求应该这么写：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> tag,</span><br><span class="line">       difficulty,</span><br><span class="line">       ROUND(<span class="built_in">AVG</span>(score), <span class="number">1</span>) clip_avg_score</span><br><span class="line"><span class="keyword">FROM</span> examination_info info</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> exam_record record</span><br><span class="line"><span class="keyword">WHERE</span> info.exam_id <span class="operator">=</span> record.exam_id</span><br><span class="line">  <span class="keyword">AND</span> record.exam_id <span class="operator">=</span></span><br><span class="line">    (<span class="keyword">SELECT</span> examination_info.exam_id</span><br><span class="line">     <span class="keyword">FROM</span> examination_info</span><br><span class="line">     <span class="keyword">WHERE</span> tag <span class="operator">=</span> <span class="string">&#x27;SQL&#x27;</span></span><br><span class="line">       <span class="keyword">AND</span> difficulty <span class="operator">=</span> <span class="string">&#x27;hard&#x27;</span> )</span><br><span class="line">  <span class="keyword">AND</span> record.score <span class="keyword">NOT</span> <span class="keyword">IN</span></span><br><span class="line">    (<span class="keyword">SELECT</span> <span class="built_in">MAX</span>(score)</span><br><span class="line">     <span class="keyword">FROM</span> exam_record</span><br><span class="line">     <span class="keyword">WHERE</span> exam_id <span class="operator">=</span></span><br><span class="line">         (<span class="keyword">SELECT</span> examination_info.exam_id</span><br><span class="line">          <span class="keyword">FROM</span> examination_info</span><br><span class="line">          <span class="keyword">WHERE</span> tag <span class="operator">=</span> <span class="string">&#x27;SQL&#x27;</span></span><br><span class="line">            <span class="keyword">AND</span> difficulty <span class="operator">=</span> <span class="string">&#x27;hard&#x27;</span> )</span><br><span class="line">     <span class="keyword">UNION</span> <span class="keyword">ALL</span> <span class="keyword">SELECT</span> <span class="built_in">MIN</span>(score)</span><br><span class="line">     <span class="keyword">FROM</span> exam_record</span><br><span class="line">     <span class="keyword">WHERE</span> exam_id <span class="operator">=</span></span><br><span class="line">         (<span class="keyword">SELECT</span> examination_info.exam_id</span><br><span class="line">          <span class="keyword">FROM</span> examination_info</span><br><span class="line">          <span class="keyword">WHERE</span> tag <span class="operator">=</span> <span class="string">&#x27;SQL&#x27;</span></span><br><span class="line">            <span class="keyword">AND</span> difficulty <span class="operator">=</span> <span class="string">&#x27;hard&#x27;</span> ) )</span><br></pre></td></tr></table></figure>

<p>然而你会发现，重复的语句非常多，所以可以利用<code>WITH</code>来抽取公共部分</p>
<p><strong><code>WITH</code> 子句介绍</strong>：</p>
<p><code>WITH</code> 子句，也称为公共表表达式（Common Table Expression，CTE），是在 SQL 查询中定义临时表的方式。它可以让我们在查询中创建一个临时命名的结果集，并且可以在同一查询中引用该结果集。</p>
<p>基本用法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> cte_name (column1, column2, ..., columnN) <span class="keyword">AS</span> (</span><br><span class="line">    <span class="comment">-- 查询体</span></span><br><span class="line">    <span class="keyword">SELECT</span> ...</span><br><span class="line">    <span class="keyword">FROM</span> ...</span><br><span class="line">    <span class="keyword">WHERE</span> ...</span><br><span class="line">)</span><br><span class="line"><span class="comment">-- 主查询</span></span><br><span class="line"><span class="keyword">SELECT</span> ...</span><br><span class="line"><span class="keyword">FROM</span> cte_name</span><br><span class="line"><span class="keyword">WHERE</span> ...</span><br></pre></td></tr></table></figure>

<p><code>WITH</code> 子句由以下几个部分组成：</p>
<ul>
<li><code>cte_name</code>: 给临时表起一个名称，可以在主查询中引用。</li>
<li><code>(column1, column2, ..., columnN)</code>: 可选，指定临时表的列名。</li>
<li><code>AS</code>: 必需，表示开始定义临时表。</li>
<li><code>CTE 查询体</code>: 实际的查询语句，用于定义临时表中的数据。</li>
</ul>
<p><code>WITH</code> 子句的主要用途之一是增强查询的可读性和可维护性，尤其在涉及多个嵌套子查询或需要重复使用相同的查询逻辑时。通过将这些逻辑放在一个命名的临时表中，我们可以更清晰地组织查询，并消除重复代码。</p>
<p>此外，<code>WITH</code> 子句还可以在复杂的查询中实现递归查询。递归查询允许我们在单个查询中执行对同一表的多次迭代，逐步构建结果集。这在处理层次结构数据、组织结构和树状结构等场景中非常有用。</p>
<p><strong>小细节</strong>：MySQL 5.7 版本以及之前的版本不支持在 <code>WITH</code> 子句中直接使用别名。</p>
<p>下面是改进后的答案：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> t1 <span class="keyword">AS</span></span><br><span class="line">  (<span class="keyword">SELECT</span> record.<span class="operator">*</span>,</span><br><span class="line">          info.tag,</span><br><span class="line">          info.difficulty</span><br><span class="line">   <span class="keyword">FROM</span> exam_record record</span><br><span class="line">   <span class="keyword">INNER</span> <span class="keyword">JOIN</span> examination_info info <span class="keyword">ON</span> record.exam_id <span class="operator">=</span> info.exam_id</span><br><span class="line">   <span class="keyword">WHERE</span> info.tag <span class="operator">=</span> &quot;SQL&quot;</span><br><span class="line">     <span class="keyword">AND</span> info.difficulty <span class="operator">=</span> &quot;hard&quot; )</span><br><span class="line"><span class="keyword">SELECT</span> tag,</span><br><span class="line">       difficulty,</span><br><span class="line">       ROUND(<span class="built_in">AVG</span>(score), <span class="number">1</span>)</span><br><span class="line"><span class="keyword">FROM</span> t1</span><br><span class="line"><span class="keyword">WHERE</span> score <span class="keyword">NOT</span> <span class="keyword">IN</span></span><br><span class="line">    (<span class="keyword">SELECT</span> <span class="built_in">max</span>(score)</span><br><span class="line">     <span class="keyword">FROM</span> t1</span><br><span class="line">     <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="built_in">min</span>(score)</span><br><span class="line">     <span class="keyword">FROM</span> t1)</span><br></pre></td></tr></table></figure>

<p><strong>思路二：</strong></p>
<ul>
<li>筛选 SQL 高难度试卷：<code>where tag=&quot;SQL&quot; and difficulty=&quot;hard&quot;</code></li>
<li>计算截断平均值：<code>(和-最大值-最小值) / (总个数-2)</code>:<ul>
<li><code>(sum(score) - max(score) - min(score)) / (count(score) - 2)</code></li>
<li>有一个缺点就是，如果最大值和最小值有多个，这个方法就很难筛选出来, 但是题目中说了—–&gt;<strong><code>去掉一个最大值和一个最小值后的平均值</code></strong>, 所以这里可以用这个公式。</li>
</ul>
</li>
</ul>
<p><strong>答案二：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> info.tag,</span><br><span class="line">       info.difficulty,</span><br><span class="line">       ROUND((<span class="built_in">SUM</span>(record.score)<span class="operator">-</span> <span class="built_in">MIN</span>(record.score)<span class="operator">-</span> <span class="built_in">MAX</span>(record.score)) <span class="operator">/</span> (<span class="built_in">COUNT</span>(record.score)<span class="operator">-</span> <span class="number">2</span>), <span class="number">1</span>) <span class="keyword">AS</span> clip_avg_score</span><br><span class="line"><span class="keyword">FROM</span> examination_info info,</span><br><span class="line">     exam_record record</span><br><span class="line"><span class="keyword">WHERE</span> info.exam_id <span class="operator">=</span> record.exam_id</span><br><span class="line">  <span class="keyword">AND</span> info.tag <span class="operator">=</span> &quot;SQL&quot;</span><br><span class="line">  <span class="keyword">AND</span> info.difficulty <span class="operator">=</span> &quot;hard&quot;;</span><br></pre></td></tr></table></figure>

<h3 id="统计作答次数"><a href="#统计作答次数" class="headerlink" title="统计作答次数"></a>统计作答次数</h3><p>有一个试卷作答记录表 <code>exam_record</code>，请从中统计出总作答次数 <code>total_pv</code>、试卷已完成作答数 <code>complete_pv</code>、已完成的试卷数 <code>complete_exam_cnt</code>。</p>
<p>示例数据 <code>exam_record</code> 表（<code>uid</code> 用户 ID, <code>exam_id</code> 试卷 ID, <code>start_time</code> 开始作答时间, <code>submit_time</code> 交卷时间, <code>score</code> 得分）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>uid</th>
<th>exam_id</th>
<th>start_time</th>
<th>submit_time</th>
<th>score</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1001</td>
<td>9001</td>
<td>2020-01-02 09:01:01</td>
<td>2020-01-02 09:21:01</td>
<td>80</td>
</tr>
<tr>
<td>2</td>
<td>1001</td>
<td>9001</td>
<td>2021-05-02 10:01:01</td>
<td>2021-05-02 10:30:01</td>
<td>81</td>
</tr>
<tr>
<td>3</td>
<td>1001</td>
<td>9001</td>
<td>2021-06-02 19:01:01</td>
<td>2021-06-02 19:31:01</td>
<td>84</td>
</tr>
<tr>
<td>4</td>
<td>1001</td>
<td>9002</td>
<td>2021-09-05 19:01:01</td>
<td>2021-09-05 19:40:01</td>
<td>89</td>
</tr>
<tr>
<td>5</td>
<td>1001</td>
<td>9001</td>
<td>2021-09-02 12:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>6</td>
<td>1001</td>
<td>9002</td>
<td>2021-09-01 12:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>7</td>
<td>1002</td>
<td>9002</td>
<td>2021-02-02 19:01:01</td>
<td>2021-02-02 19:30:01</td>
<td>87</td>
</tr>
<tr>
<td>8</td>
<td>1002</td>
<td>9001</td>
<td>2021-05-05 18:01:01</td>
<td>2021-05-05 18:59:02</td>
<td>90</td>
</tr>
<tr>
<td>9</td>
<td>1003</td>
<td>9001</td>
<td>2021-09-07 12:01:01</td>
<td>2021-09-07 10:31:01</td>
<td>50</td>
</tr>
<tr>
<td>10</td>
<td>1004</td>
<td>9001</td>
<td>2021-09-06 10:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
</tbody></table>
<p>示例输出：</p>
<table>
<thead>
<tr>
<th>total_pv</th>
<th>complete_pv</th>
<th>complete_exam_cnt</th>
</tr>
</thead>
<tbody><tr>
<td>10</td>
<td>7</td>
<td>2</td>
</tr>
</tbody></table>
<p>解释：表示截止当前，有 10 次试卷作答记录，已完成的作答次数为 7 次（中途退出的为未完成状态，其交卷时间和份数为 NULL），已完成的试卷有 9001 和 9002 两份。</p>
<p><strong>思路</strong>： 这题一看到统计次数，肯定第一时间就要想到用<code>COUNT</code>这个函数来解决，问题是要统计不同的记录，该怎么来写？使用子查询就能解决这个题目(这题用 case when 也能写出来，解法类似，逻辑不同而已)；首先在做这个题之前，让我们先来了解一下<code>COUNT</code>的基本用法；</p>
<p><code>COUNT()</code> 函数的基本语法如下所示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">COUNT</span>(expression)</span><br></pre></td></tr></table></figure>

<p>其中，<code>expression</code> 可以是列名、表达式、常量或通配符。下面是一些常见的用法示例：</p>
<ol>
<li>计算表中所有行的数量：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>计算特定列非空（不为 NULL）值的数量：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(column_name) <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>计算满足条件的行数：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>结合 <code>GROUP BY</code> 使用，计算分组后每个组的行数：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> table_name <span class="keyword">GROUP</span> <span class="keyword">BY</span> column_name;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>计算不同列组合的唯一组合数：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> column_name1, column_name2) <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure>

<p>在使用 <code>COUNT()</code> 函数时，如果不指定任何参数或者使用 <code>COUNT(*)</code>，将会计算所有行的数量。而如果使用列名，则只会计算该列非空值的数量。</p>
<p>另外，<code>COUNT()</code> 函数的结果是一个整数值。即使结果是零，也不会返回 NULL，这点需要谨记。</p>
<p><strong>答案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	<span class="built_in">count</span>(<span class="operator">*</span>) total_pv,</span><br><span class="line">	( <span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> exam_record <span class="keyword">WHERE</span> submit_time <span class="keyword">IS</span> <span class="keyword">NOT NULL</span> ) complete_pv,</span><br><span class="line">	( <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>( <span class="keyword">DISTINCT</span> exam_id, score <span class="keyword">IS</span> <span class="keyword">NOT NULL</span> <span class="keyword">OR</span> <span class="keyword">NULL</span> ) <span class="keyword">FROM</span> exam_record ) complete_exam_cnt</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	exam_record</span><br></pre></td></tr></table></figure>

<p>这里着重说一下<code>COUNT( DISTINCT exam_id, score IS NOT NULL OR NULL )</code>这一句，判断 score 是否为 null ，如果是即为真，如果不是返回 null；注意这里如果不加 <code>or null</code> 在不是 null 的情况下只会返回 false 也就是返回 0；</p>
<p><code>COUNT</code>本身是不可以对多列求行数的，<code>distinct</code>的加入是的多列成为一个整体，可以求出现的行数了;<code>count distinct</code>在计算时只返回非 null 的行, 这个也要注意；</p>
<p>另外通过本题 get 到了——&gt;count 加条件常用句式<code>count( 列判断 or null)</code></p>
<h3 id="得分不小于平均分的最低分"><a href="#得分不小于平均分的最低分" class="headerlink" title="得分不小于平均分的最低分"></a>得分不小于平均分的最低分</h3><p><strong>描述</strong>： 请从试卷作答记录表中找到 SQL 试卷得分不小于该类试卷平均得分的用户最低得分。</p>
<p>示例数据 exam_record 表（uid 用户 ID, exam_id 试卷 ID, start_time 开始作答时间, submit_time 交卷时间, score 得分）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>uid</th>
<th>exam_id</th>
<th>start_time</th>
<th>submit_time</th>
<th>score</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1001</td>
<td>9001</td>
<td>2020-01-02 09:01:01</td>
<td>2020-01-02 09:21:01</td>
<td>80</td>
</tr>
<tr>
<td>2</td>
<td>1002</td>
<td>9001</td>
<td>2021-09-05 19:01:01</td>
<td>2021-09-05 19:40:01</td>
<td>89</td>
</tr>
<tr>
<td>3</td>
<td>1002</td>
<td>9002</td>
<td>2021-09-02 12:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>4</td>
<td>1002</td>
<td>9003</td>
<td>2021-09-01 12:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>5</td>
<td>1002</td>
<td>9001</td>
<td>2021-02-02 19:01:01</td>
<td>2021-02-02 19:30:01</td>
<td>87</td>
</tr>
<tr>
<td>6</td>
<td>1002</td>
<td>9002</td>
<td>2021-05-05 18:01:01</td>
<td>2021-05-05 18:59:02</td>
<td>90</td>
</tr>
<tr>
<td>7</td>
<td>1003</td>
<td>9002</td>
<td>2021-02-06 12:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>8</td>
<td>1003</td>
<td>9003</td>
<td>2021-09-07 10:01:01</td>
<td>2021-09-07 10:31:01</td>
<td>86</td>
</tr>
<tr>
<td>9</td>
<td>1004</td>
<td>9003</td>
<td>2021-09-06 12:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
</tbody></table>
<p><code>examination_info</code> 表（<code>exam_id</code> 试卷 ID, <code>tag</code> 试卷类别, <code>difficulty</code> 试卷难度, <code>duration</code> 考试时长, <code>release_time</code> 发布时间）</p>
<table>
<thead>
<tr>
<th>id</th>
<th>exam_id</th>
<th>tag</th>
<th>difficulty</th>
<th>duration</th>
<th>release_time</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>9001</td>
<td>SQL</td>
<td>hard</td>
<td>60</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>2</td>
<td>9002</td>
<td>SQL</td>
<td>easy</td>
<td>60</td>
<td>2020-02-01 10:00:00</td>
</tr>
<tr>
<td>3</td>
<td>9003</td>
<td>算法</td>
<td>medium</td>
<td>80</td>
<td>2020-08-02 10:00:00</td>
</tr>
</tbody></table>
<p>示例输出数据：</p>
<table>
<thead>
<tr>
<th>min_score_over_avg</th>
</tr>
</thead>
<tbody><tr>
<td>87</td>
</tr>
</tbody></table>
<p><strong>解释</strong>：试卷 9001 和 9002 为 SQL 类别，作答这两份试卷的得分有[80,89,87,90]，平均分为 86.5，不小于平均分的最小分数为 87</p>
<p><strong>思路</strong>：这类题目第一眼看确实很复杂， 因为不知道从哪入手，但是当我们仔细读题审题后，要学会抓住题干中的关键信息。以本题为例：<code>请从试卷作答记录表中找到SQL试卷得分不小于该类试卷平均得分的用户最低得分。</code>你能一眼从中提取哪些有效信息来作为解题思路？</p>
<p>第一条：找到&#x3D;&#x3D;SQL&#x3D;&#x3D;试卷得分</p>
<p>第二条：该类试卷&#x3D;&#x3D;平均得分&#x3D;&#x3D;</p>
<p>第三条：该类试卷的&#x3D;&#x3D;用户最低得分&#x3D;&#x3D;</p>
<p>然后中间的 “桥梁” 就是&#x3D;&#x3D;不小于&#x3D;&#x3D;</p>
<p>将条件拆分后，先逐步完成</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 找出tag为‘SQL’的得分   【80, 89,87,90】</span></span><br><span class="line"><span class="comment">-- 再算出这一组的平均得分</span></span><br><span class="line"><span class="keyword">select</span>  ROUND(<span class="built_in">AVG</span>(score), <span class="number">1</span>) <span class="keyword">from</span>  examination_info info <span class="keyword">INNER</span> <span class="keyword">JOIN</span> exam_record record</span><br><span class="line">	<span class="keyword">where</span> info.exam_id <span class="operator">=</span> record.exam_id</span><br><span class="line">	<span class="keyword">and</span> tag<span class="operator">=</span> <span class="string">&#x27;SQL&#x27;</span></span><br></pre></td></tr></table></figure>

<p>然后再找出该类试卷的最低得分，接着将结果集<code>【80, 89,87,90】</code> 去和平均分数作比较，方可得出最终答案。</p>
<p><strong>答案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(score) <span class="keyword">AS</span> min_score_over_avg</span><br><span class="line"><span class="keyword">FROM</span> examination_info info</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> exam_record record</span><br><span class="line"><span class="keyword">WHERE</span> info.exam_id <span class="operator">=</span> record.exam_id</span><br><span class="line">  <span class="keyword">AND</span> tag<span class="operator">=</span> <span class="string">&#x27;SQL&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> score <span class="operator">&gt;=</span></span><br><span class="line">    (<span class="keyword">SELECT</span> ROUND(<span class="built_in">AVG</span>(score), <span class="number">1</span>)</span><br><span class="line">     <span class="keyword">FROM</span> examination_info info</span><br><span class="line">     <span class="keyword">INNER</span> <span class="keyword">JOIN</span> exam_record record</span><br><span class="line">     <span class="keyword">WHERE</span> info.exam_id <span class="operator">=</span> record.exam_id</span><br><span class="line">       <span class="keyword">AND</span> tag<span class="operator">=</span> <span class="string">&#x27;SQL&#x27;</span> )</span><br></pre></td></tr></table></figure>

<p>其实这类题目给出的要求看似很 “绕”，但其实仔细梳理一遍，将大条件拆分成小条件，逐个拆分完以后，最后将所有条件拼凑起来。反正只要记住：<strong>抓主干，理分支</strong>，问题便迎刃而解。</p>
<h2 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h2><h3 id="平均活跃天数和月活人数"><a href="#平均活跃天数和月活人数" class="headerlink" title="平均活跃天数和月活人数"></a>平均活跃天数和月活人数</h3><p><strong>描述</strong>：用户在牛客试卷作答区作答记录存储在表 <code>exam_record</code> 中，内容如下：</p>
<p><code>exam_record</code> 表（<code>uid</code> 用户 ID, <code>exam_id</code> 试卷 ID, <code>start_time</code> 开始作答时间, <code>submit_time</code> 交卷时间, <code>score</code> 得分）</p>
<table>
<thead>
<tr>
<th>id</th>
<th>uid</th>
<th>exam_id</th>
<th>start_time</th>
<th>submit_time</th>
<th>score</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1001</td>
<td>9001</td>
<td>2021-07-02 09:01:01</td>
<td>2021-07-02 09:21:01</td>
<td>80</td>
</tr>
<tr>
<td>2</td>
<td>1002</td>
<td>9001</td>
<td>2021-09-05 19:01:01</td>
<td>2021-09-05 19:40:01</td>
<td>81</td>
</tr>
<tr>
<td>3</td>
<td>1002</td>
<td>9002</td>
<td>2021-09-02 12:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>4</td>
<td>1002</td>
<td>9003</td>
<td>2021-09-01 12:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>5</td>
<td>1002</td>
<td>9001</td>
<td>2021-07-02 19:01:01</td>
<td>2021-07-02 19:30:01</td>
<td>82</td>
</tr>
<tr>
<td>6</td>
<td>1002</td>
<td>9002</td>
<td>2021-07-05 18:01:01</td>
<td>2021-07-05 18:59:02</td>
<td>90</td>
</tr>
<tr>
<td>7</td>
<td>1003</td>
<td>9002</td>
<td>2021-07-06 12:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>8</td>
<td>1003</td>
<td>9003</td>
<td>2021-09-07 10:01:01</td>
<td>2021-09-07 10:31:01</td>
<td>86</td>
</tr>
<tr>
<td>9</td>
<td>1004</td>
<td>9003</td>
<td>2021-09-06 12:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>10</td>
<td>1002</td>
<td>9003</td>
<td>2021-09-01 12:01:01</td>
<td>2021-09-01 12:31:01</td>
<td>81</td>
</tr>
<tr>
<td>11</td>
<td>1005</td>
<td>9001</td>
<td>2021-09-01 12:01:01</td>
<td>2021-09-01 12:31:01</td>
<td>88</td>
</tr>
<tr>
<td>12</td>
<td>1006</td>
<td>9002</td>
<td>2021-09-02 12:11:01</td>
<td>2021-09-02 12:31:01</td>
<td>89</td>
</tr>
<tr>
<td>13</td>
<td>1007</td>
<td>9002</td>
<td>2020-09-02 12:11:01</td>
<td>2020-09-02 12:31:01</td>
<td>89</td>
</tr>
</tbody></table>
<p>请计算 2021 年每个月里试卷作答区用户平均月活跃天数 <code>avg_active_days</code> 和月度活跃人数 <code>mau</code>，上面数据的示例输出如下：</p>
<table>
<thead>
<tr>
<th>month</th>
<th>avg_active_days</th>
<th>mau</th>
</tr>
</thead>
<tbody><tr>
<td>202107</td>
<td>1.50</td>
<td>2</td>
</tr>
<tr>
<td>202109</td>
<td>1.25</td>
<td>4</td>
</tr>
</tbody></table>
<p><strong>解释</strong>：2021 年 7 月有 2 人活跃，共活跃了 3 天（1001 活跃 1 天，1002 活跃 2 天），平均活跃天数 1.5；2021 年 9 月有 4 人活跃，共活跃了 5 天，平均活跃天数 1.25，结果保留 2 位小数。</p>
<p>注：此处活跃指有&#x3D;&#x3D;交卷&#x3D;&#x3D;行为。</p>
<p><strong>思路</strong>：读完题先注意高亮部分；一般求天数和月活跃人数马上就要想到相关的日期函数；这一题我们同样来进行拆分，把问题细化再解决；首先求活跃人数，肯定要用到<code>COUNT()</code>，那这里首先就有一个坑，不知道大家注意了没有？用户 1002 在 9 月份做了两种不同的试卷，所以这里要注意去重，不然在统计的时候，活跃人数是错的；第二个就是要知道日期的格式化，如上表，题目要求以<code>202107</code>这种日期格式展现，要用到<code>DATE_FORMAT</code>来进行格式化。</p>
<p>基本用法：</p>
<p><code>DATE_FORMAT(date_value, format)</code></p>
<ul>
<li><code>date_value</code> 参数是待格式化的日期或时间值。</li>
<li><code>format</code> 参数是指定的日期或时间格式（这个和 Java 里面的日期格式一样）。</li>
</ul>
<p><strong>答案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DATE_FORMAT(submit_time, <span class="string">&#x27;%Y%m&#x27;</span>) <span class="keyword">MONTH</span>,</span><br><span class="line">                                        round(<span class="built_in">count</span>(<span class="keyword">DISTINCT</span> UID, DATE_FORMAT(submit_time, <span class="string">&#x27;%Y%m%d&#x27;</span>)) <span class="operator">/</span> <span class="built_in">count</span>(<span class="keyword">DISTINCT</span> UID), <span class="number">2</span>) avg_active_days,</span><br><span class="line">                                        <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> UID) mau</span><br><span class="line"><span class="keyword">FROM</span> exam_record</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">YEAR</span> (submit_time) <span class="operator">=</span> <span class="number">2021</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">MONTH</span></span><br></pre></td></tr></table></figure>

<p>这里多说一句, 使用<code>COUNT(DISTINCT uid, DATE_FORMAT(submit_time, &#39;%Y%m%d&#39;))</code> 可以统计在 <code>uid</code> 列和 <code>submit_time</code> 列按照年份、月份和日期进行格式化后的组合值的数量。</p>
<h3 id="月总刷题数和日均刷题数"><a href="#月总刷题数和日均刷题数" class="headerlink" title="月总刷题数和日均刷题数"></a>月总刷题数和日均刷题数</h3><p><strong>描述</strong>：现有一张题目练习记录表 <code>practice_record</code>，示例内容如下：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>uid</th>
<th>question_id</th>
<th>submit_time</th>
<th>score</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1001</td>
<td>8001</td>
<td>2021-08-02 11:41:01</td>
<td>60</td>
</tr>
<tr>
<td>2</td>
<td>1002</td>
<td>8001</td>
<td>2021-09-02 19:30:01</td>
<td>50</td>
</tr>
<tr>
<td>3</td>
<td>1002</td>
<td>8001</td>
<td>2021-09-02 19:20:01</td>
<td>70</td>
</tr>
<tr>
<td>4</td>
<td>1002</td>
<td>8002</td>
<td>2021-09-02 19:38:01</td>
<td>70</td>
</tr>
<tr>
<td>5</td>
<td>1003</td>
<td>8002</td>
<td>2021-08-01 19:38:01</td>
<td>80</td>
</tr>
</tbody></table>
<p>请从中统计出 2021 年每个月里用户的月总刷题数 <code>month_q_cnt</code> 和日均刷题数 <code>avg_day_q_cnt</code>（按月份升序排序）以及该年的总体情况，示例数据输出如下：</p>
<table>
<thead>
<tr>
<th>submit_month</th>
<th>month_q_cnt</th>
<th>avg_day_q_cnt</th>
</tr>
</thead>
<tbody><tr>
<td>202108</td>
<td>2</td>
<td>0.065</td>
</tr>
<tr>
<td>202109</td>
<td>3</td>
<td>0.100</td>
</tr>
<tr>
<td>2021 汇总</td>
<td>5</td>
<td>0.161</td>
</tr>
</tbody></table>
<p><strong>解释</strong>：2021 年 8 月共有 2 次刷题记录，日均刷题数为 2&#x2F;31&#x3D;0.065（保留 3 位小数）；2021 年 9 月共有 3 次刷题记录，日均刷题数为 3&#x2F;30&#x3D;0.100；2021 年共有 5 次刷题记录（年度汇总平均无实际意义，这里我们按照 31 天来算 5&#x2F;31&#x3D;0.161）</p>
<blockquote>
<p>牛客已经采用最新的 Mysql 版本，如果您运行结果出现错误：ONLY_FULL_GROUP_BY，意思是：对于 GROUP BY 聚合操作，如果在 SELECT 中的列，没有在 GROUP BY 中出现，那么这个 SQL 是不合法的，因为列不在 GROUP BY 从句中，也就是说查出来的列必须在 group by 后面出现否则就会报错，或者这个字段出现在聚合函数里面。</p>
</blockquote>
<p><strong>思路：</strong></p>
<p>看到实例数据就要马上联想到相关的函数，比如<code>submit_month</code>就要用到<code>DATE_FORMAT</code>来格式化日期。然后查出每月的刷题数量。</p>
<p>每月的刷题数量</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MONTH</span> ( submit_time ), <span class="built_in">COUNT</span>( question_id )</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	practice_record</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">	<span class="keyword">MONTH</span> (submit_time)</span><br></pre></td></tr></table></figure>

<p>接着第三列这里要用到<code>DAY(LAST_DAY(date_value))</code>函数来查找给定日期的月份中的天数。</p>
<p>示例代码如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DAY</span>(LAST_DAY(<span class="string">&#x27;2023-07-08&#x27;</span>)) <span class="keyword">AS</span> days_in_month;</span><br><span class="line"><span class="comment">-- 输出：31</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DAY</span>(LAST_DAY(<span class="string">&#x27;2023-02-01&#x27;</span>)) <span class="keyword">AS</span> days_in_month;</span><br><span class="line"><span class="comment">-- 输出：28 (闰年中的二月份)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DAY</span>(LAST_DAY(NOW())) <span class="keyword">AS</span> days_in_current_month;</span><br><span class="line"><span class="comment">-- 输出：31 （当前月份的天数）</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>LAST_DAY()</code> 函数获取给定日期的当月最后一天，然后使用 <code>DAY()</code> 函数提取该日期的天数。这样就能获得指定月份的天数。</p>
<p>需要注意的是，<code>LAST_DAY()</code> 函数返回的是日期值，而 <code>DAY()</code> 函数用于提取日期值中的天数部分。</p>
<p>有了上述的分析之后，即可马上写出答案，这题复杂就复杂在处理日期上，其中的逻辑并不难。</p>
<p><strong>答案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DATE_FORMAT(submit_time, <span class="string">&#x27;%Y%m&#x27;</span>) submit_month,</span><br><span class="line">       <span class="built_in">count</span>(question_id) month_q_cnt,</span><br><span class="line">       ROUND(<span class="built_in">COUNT</span>(question_id) <span class="operator">/</span> <span class="keyword">DAY</span> (LAST_DAY(submit_time)), <span class="number">3</span>) avg_day_q_cnt</span><br><span class="line"><span class="keyword">FROM</span> practice_record</span><br><span class="line"><span class="keyword">WHERE</span> DATE_FORMAT(submit_time, <span class="string">&#x27;%Y&#x27;</span>) <span class="operator">=</span> <span class="string">&#x27;2021&#x27;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> submit_month</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;2021汇总&#x27;</span> <span class="keyword">AS</span> submit_month,</span><br><span class="line">       <span class="built_in">count</span>(question_id) month_q_cnt,</span><br><span class="line">       ROUND(<span class="built_in">COUNT</span>(question_id) <span class="operator">/</span> <span class="number">31</span>, <span class="number">3</span>) avg_day_q_cnt</span><br><span class="line"><span class="keyword">FROM</span> practice_record</span><br><span class="line"><span class="keyword">WHERE</span> DATE_FORMAT(submit_time, <span class="string">&#x27;%Y&#x27;</span>) <span class="operator">=</span> <span class="string">&#x27;2021&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> submit_month</span><br></pre></td></tr></table></figure>

<p>在实例数据输出中因为最后一行需要得出汇总数据，所以这里要 <code>UNION ALL</code>加到结果集中；别忘了最后要排序！</p>
<h3 id="未完成试卷数大于-1-的有效用户（较难）"><a href="#未完成试卷数大于-1-的有效用户（较难）" class="headerlink" title="未完成试卷数大于 1 的有效用户（较难）"></a>未完成试卷数大于 1 的有效用户（较难）</h3><p><strong>描述</strong>：现有试卷作答记录表 <code>exam_record</code>（<code>uid</code> 用户 ID, <code>exam_id</code> 试卷 ID, <code>start_time</code> 开始作答时间, <code>submit_time</code> 交卷时间, <code>score</code> 得分），示例数据如下：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>uid</th>
<th>exam_id</th>
<th>start_time</th>
<th>submit_time</th>
<th>score</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1001</td>
<td>9001</td>
<td>2021-07-02 09:01:01</td>
<td>2021-07-02 09:21:01</td>
<td>80</td>
</tr>
<tr>
<td>2</td>
<td>1002</td>
<td>9001</td>
<td>2021-09-05 19:01:01</td>
<td>2021-09-05 19:40:01</td>
<td>81</td>
</tr>
<tr>
<td>3</td>
<td>1002</td>
<td>9002</td>
<td>2021-09-02 12:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>4</td>
<td>1002</td>
<td>9003</td>
<td>2021-09-01 12:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>5</td>
<td>1002</td>
<td>9001</td>
<td>2021-07-02 19:01:01</td>
<td>2021-07-02 19:30:01</td>
<td>82</td>
</tr>
<tr>
<td>6</td>
<td>1002</td>
<td>9002</td>
<td>2021-07-05 18:01:01</td>
<td>2021-07-05 18:59:02</td>
<td>90</td>
</tr>
<tr>
<td>7</td>
<td>1003</td>
<td>9002</td>
<td>2021-07-06 12:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>8</td>
<td>1003</td>
<td>9003</td>
<td>2021-09-07 10:01:01</td>
<td>2021-09-07 10:31:01</td>
<td>86</td>
</tr>
<tr>
<td>9</td>
<td>1004</td>
<td>9003</td>
<td>2021-09-06 12:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>10</td>
<td>1002</td>
<td>9003</td>
<td>2021-09-01 12:01:01</td>
<td>2021-09-01 12:31:01</td>
<td>81</td>
</tr>
<tr>
<td>11</td>
<td>1005</td>
<td>9001</td>
<td>2021-09-01 12:01:01</td>
<td>2021-09-01 12:31:01</td>
<td>88</td>
</tr>
<tr>
<td>12</td>
<td>1006</td>
<td>9002</td>
<td>2021-09-02 12:11:01</td>
<td>2021-09-02 12:31:01</td>
<td>89</td>
</tr>
<tr>
<td>13</td>
<td>1007</td>
<td>9002</td>
<td>2020-09-02 12:11:01</td>
<td>2020-09-02 12:31:01</td>
<td>89</td>
</tr>
</tbody></table>
<p>还有一张试卷信息表 <code>examination_info</code>（<code>exam_id</code> 试卷 ID, <code>tag</code> 试卷类别, <code>difficulty</code> 试卷难度, <code>duration</code> 考试时长, <code>release_time</code> 发布时间），示例数据如下：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>exam_id</th>
<th>tag</th>
<th>difficulty</th>
<th>duration</th>
<th>release_time</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>9001</td>
<td>SQL</td>
<td>hard</td>
<td>60</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>2</td>
<td>9002</td>
<td>SQL</td>
<td>easy</td>
<td>60</td>
<td>2020-02-01 10:00:00</td>
</tr>
<tr>
<td>3</td>
<td>9003</td>
<td>算法</td>
<td>medium</td>
<td>80</td>
<td>2020-08-02 10:00:00</td>
</tr>
</tbody></table>
<p>请统计 2021 年每个未完成试卷作答数大于 1 的有效用户的数据（有效用户指完成试卷作答数至少为 1 且未完成数小于 5），输出用户 ID、未完成试卷作答数、完成试卷作答数、作答过的试卷 tag 集合，按未完成试卷数量由多到少排序。示例数据的输出结果如下：</p>
<table>
<thead>
<tr>
<th>uid</th>
<th>incomplete_cnt</th>
<th>complete_cnt</th>
<th>detail</th>
</tr>
</thead>
<tbody><tr>
<td>1002</td>
<td>2</td>
<td>4</td>
<td>2021-09-01:算法;2021-07-02:SQL;2021-09-02:SQL;2021-09-05:SQL;2021-07-05:SQL</td>
</tr>
</tbody></table>
<p><strong>解释</strong>：2021 年的作答记录中，除了 1004，其他用户均满足有效用户定义，但只有 1002 未完成试卷数大于 1，因此只输出 1002，detail 中是 1002 作答过的试卷{日期:tag}集合，日期和 tag 间用 <strong>:</strong> 连接，多元素间用 <strong>;</strong> 连接。</p>
<p><strong>思路：</strong></p>
<p>仔细读题后，分析出：首先要联表，因为后面要输出<code>tag</code>；</p>
<p>筛选出 2021 年的数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> exam_record er</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> examination_info ei <span class="keyword">ON</span> er.exam_id <span class="operator">=</span> ei.exam_id</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">YEAR</span> (er.start_time)<span class="operator">=</span> <span class="number">2021</span></span><br></pre></td></tr></table></figure>

<p>根据 uid 进行分组，然后对每个用户进行条件进行判断，题目中要求<code>完成试卷数至少为1,未完成试卷数要大于1，小于5</code></p>
<p>那么等会儿写 sql 的时候条件应该是：<code>未完成 &gt; 1 and 已完成 &gt;=1 and 未完成 &lt; 5</code></p>
<p>因为最后要用到字符串的拼接，而且还要组合拼接，这个可以用<code>GROUP_CONCAT</code>函数，下面简单介绍一下该函数的用法：</p>
<p>基本格式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GROUP_CONCAT([<span class="keyword">DISTINCT</span>] expr [<span class="keyword">ORDER</span> <span class="keyword">BY</span> &#123;unsigned_integer <span class="operator">|</span> col_name <span class="operator">|</span> expr&#125; [<span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>] [, ...]]             [SEPARATOR sep])</span><br></pre></td></tr></table></figure>

<ul>
<li><code>expr</code>：要连接的列或表达式。</li>
<li><code>DISTINCT</code>：可选参数，用于去重。当指定了 <code>DISTINCT</code>，相同的值只会出现一次。</li>
<li><code>ORDER BY</code>：可选参数，用于排序连接后的值。可以选择升序 (<code>ASC</code>) 或降序 (<code>DESC</code>) 排序。</li>
<li><code>SEPARATOR sep</code>：可选参数，用于设置连接后的值的分隔符。（本题要用这个参数设置 ; 号 ）</li>
</ul>
<p><code>GROUP_CONCAT()</code> 函数常用于 <code>GROUP BY</code> 子句中，将一组行的值连接为一个字符串，并在结果集中以聚合的形式返回。</p>
<p><strong>答案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.uid,</span><br><span class="line">       <span class="built_in">SUM</span>(<span class="keyword">CASE</span></span><br><span class="line">               <span class="keyword">WHEN</span> a.submit_time <span class="keyword">IS</span> <span class="keyword">NULL</span> <span class="keyword">THEN</span> <span class="number">1</span></span><br><span class="line">           <span class="keyword">END</span>) <span class="keyword">AS</span> incomplete_cnt,</span><br><span class="line">       <span class="built_in">SUM</span>(<span class="keyword">CASE</span></span><br><span class="line">               <span class="keyword">WHEN</span> a.submit_time <span class="keyword">IS</span> <span class="keyword">NOT NULL</span> <span class="keyword">THEN</span> <span class="number">1</span></span><br><span class="line">           <span class="keyword">END</span>) <span class="keyword">AS</span> complete_cnt,</span><br><span class="line">       GROUP_CONCAT(<span class="keyword">DISTINCT</span> CONCAT(DATE_FORMAT(a.start_time, <span class="string">&#x27;%Y-%m-%d&#x27;</span>), <span class="string">&#x27;:&#x27;</span>, b.tag)</span><br><span class="line">                    <span class="keyword">ORDER</span> <span class="keyword">BY</span> start_time SEPARATOR &quot;;&quot;) <span class="keyword">AS</span> detail</span><br><span class="line"><span class="keyword">FROM</span> exam_record a</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> examination_info b <span class="keyword">ON</span> a.exam_id <span class="operator">=</span> b.exam_id</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">YEAR</span> (a.start_time)<span class="operator">=</span> <span class="number">2021</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> a.uid</span><br><span class="line"><span class="keyword">HAVING</span> incomplete_cnt <span class="operator">&gt;</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">AND</span> complete_cnt <span class="operator">&gt;=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">AND</span> incomplete_cnt <span class="operator">&lt;</span> <span class="number">5</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> incomplete_cnt <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>SUM(CASE WHEN a.submit_time IS NULL THEN 1 END)</code> 统计了每个用户未完成的记录数量。</li>
<li><code>SUM(CASE WHEN a.submit_time IS NOT NULL THEN 1 END)</code> 统计了每个用户已完成的记录数量。</li>
<li><code>GROUP_CONCAT(DISTINCT CONCAT(DATE_FORMAT(a.start_time, &#39;%Y-%m-%d&#39;), &#39;:&#39;, b.tag) ORDER BY a.start_time SEPARATOR &#39;;&#39;)</code> 将每个用户的考试日期和标签以逗号分隔的形式连接成一个字符串，并按考试开始时间进行排序。</li>
</ul>
<h2 id="嵌套子查询"><a href="#嵌套子查询" class="headerlink" title="嵌套子查询"></a>嵌套子查询</h2><h3 id="月均完成试卷数不小于-3-的用户爱作答的类别（较难）"><a href="#月均完成试卷数不小于-3-的用户爱作答的类别（较难）" class="headerlink" title="月均完成试卷数不小于 3 的用户爱作答的类别（较难）"></a>月均完成试卷数不小于 3 的用户爱作答的类别（较难）</h3><p><strong>描述</strong>：现有试卷作答记录表 <code>exam_record</code>（<code>uid</code>：用户 ID, <code>exam_id</code>：试卷 ID, <code>start_time</code>：开始作答时间, <code>submit_time</code>：交卷时间，没提交的话为 NULL, <code>score</code>：得分），示例数据如下：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>uid</th>
<th>exam_id</th>
<th>start_time</th>
<th>submit_time</th>
<th>score</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1001</td>
<td>9001</td>
<td>2021-07-02 09:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>2</td>
<td>1002</td>
<td>9003</td>
<td>2021-09-01 12:01:01</td>
<td>2021-09-01 12:21:01</td>
<td>60</td>
</tr>
<tr>
<td>3</td>
<td>1002</td>
<td>9002</td>
<td>2021-09-02 12:01:01</td>
<td>2021-09-02 12:31:01</td>
<td>70</td>
</tr>
<tr>
<td>4</td>
<td>1002</td>
<td>9001</td>
<td>2021-09-05 19:01:01</td>
<td>2021-09-05 19:40:01</td>
<td>81</td>
</tr>
<tr>
<td>5</td>
<td>1002</td>
<td>9002</td>
<td>2021-07-06 12:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>6</td>
<td>1003</td>
<td>9003</td>
<td>2021-09-07 10:01:01</td>
<td>2021-09-07 10:31:01</td>
<td>86</td>
</tr>
<tr>
<td>7</td>
<td>1003</td>
<td>9003</td>
<td>2021-09-08 12:01:01</td>
<td>2021-09-08 12:11:01</td>
<td>40</td>
</tr>
<tr>
<td>8</td>
<td>1003</td>
<td>9001</td>
<td>2021-09-08 13:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>9</td>
<td>1003</td>
<td>9002</td>
<td>2021-09-08 14:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>10</td>
<td>1003</td>
<td>9003</td>
<td>2021-09-08 15:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>11</td>
<td>1005</td>
<td>9001</td>
<td>2021-09-01 12:01:01</td>
<td>2021-09-01 12:31:01</td>
<td>88</td>
</tr>
<tr>
<td>12</td>
<td>1005</td>
<td>9002</td>
<td>2021-09-01 12:01:01</td>
<td>2021-09-01 12:31:01</td>
<td>88</td>
</tr>
<tr>
<td>13</td>
<td>1005</td>
<td>9002</td>
<td>2021-09-02 12:11:01</td>
<td>2021-09-02 12:31:01</td>
<td>89</td>
</tr>
</tbody></table>
<p>试卷信息表 <code>examination_info</code>（<code>exam_id</code>：试卷 ID, <code>tag</code>：试卷类别, <code>difficulty</code>：试卷难度, <code>duration</code>：考试时长, <code>release_time</code>：发布时间），示例数据如下：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>exam_id</th>
<th>tag</th>
<th>difficulty</th>
<th>duration</th>
<th>release_time</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>9001</td>
<td>SQL</td>
<td>hard</td>
<td>60</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>2</td>
<td>9002</td>
<td>C++</td>
<td>easy</td>
<td>60</td>
<td>2020-02-01 10:00:00</td>
</tr>
<tr>
<td>3</td>
<td>9003</td>
<td>算法</td>
<td>medium</td>
<td>80</td>
<td>2020-08-02 10:00:00</td>
</tr>
</tbody></table>
<p>请从表中统计出 “当月均完成试卷数”不小于 3 的用户们爱作答的类别及作答次数，按次数降序输出，示例输出如下：</p>
<table>
<thead>
<tr>
<th>tag</th>
<th>tag_cnt</th>
</tr>
</thead>
<tbody><tr>
<td>C++</td>
<td>4</td>
</tr>
<tr>
<td>SQL</td>
<td>2</td>
</tr>
<tr>
<td>算法</td>
<td>1</td>
</tr>
</tbody></table>
<p><strong>解释</strong>：用户 1002 和 1005 在 2021 年 09 月的完成试卷数目均为 3，其他用户均小于 3；然后用户 1002 和 1005 作答过的试卷 tag 分布结果按作答次数降序排序依次为 C++、SQL、算法。</p>
<p><strong>思路</strong>：这题考察联合子查询，重点在于<code>月均回答&gt;=3</code>, 但是个人认为这里没有表述清楚，应该直接说查 9 月的就容易理解多了；这里不是每个月都要&gt;&#x3D;3 或者是所有答题次数&#x2F;答题月份。不要理解错误了。</p>
<p>先查询出哪些用户月均答题大于三次</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> UID</span><br><span class="line"><span class="keyword">FROM</span> exam_record record</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> UID,</span><br><span class="line">         <span class="keyword">MONTH</span> (start_time)</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">count</span>(submit_time) <span class="operator">&gt;=</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>有了这一步之后再进行深入，只要能理解上一步(我的意思是不被题目中的月均所困扰)，然后再套一个子查询，查哪些用户包含其中，然后查出题目中所需的列即可。记得排序！！</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> tag,</span><br><span class="line">       <span class="built_in">count</span>(start_time) <span class="keyword">AS</span> tag_cnt</span><br><span class="line"><span class="keyword">FROM</span> exam_record record</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> examination_info info <span class="keyword">ON</span> record.exam_id <span class="operator">=</span> info.exam_id</span><br><span class="line"><span class="keyword">WHERE</span> UID <span class="keyword">IN</span></span><br><span class="line">    (<span class="keyword">SELECT</span> UID</span><br><span class="line">     <span class="keyword">FROM</span> exam_record record</span><br><span class="line">     <span class="keyword">GROUP</span> <span class="keyword">BY</span> UID,</span><br><span class="line">              <span class="keyword">MONTH</span> (start_time)</span><br><span class="line">     <span class="keyword">HAVING</span> <span class="built_in">count</span>(submit_time) <span class="operator">&gt;=</span> <span class="number">3</span>)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> tag</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> tag_cnt <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>

<h3 id="试卷发布当天作答人数和平均分"><a href="#试卷发布当天作答人数和平均分" class="headerlink" title="试卷发布当天作答人数和平均分"></a>试卷发布当天作答人数和平均分</h3><p><strong>描述</strong>：现有用户信息表 <code>user_info</code>（<code>uid</code> 用户 ID，<code>nick_name</code> 昵称, <code>achievement</code> 成就值, <code>level</code> 等级, <code>job</code> 职业方向, <code>register_time</code> 注册时间），示例数据如下：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>uid</th>
<th>nick_name</th>
<th>achievement</th>
<th>level</th>
<th>job</th>
<th>register_time</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1001</td>
<td>牛客 1 号</td>
<td>3100</td>
<td>7</td>
<td>算法</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>2</td>
<td>1002</td>
<td>牛客 2 号</td>
<td>2100</td>
<td>6</td>
<td>算法</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>3</td>
<td>1003</td>
<td>牛客 3 号</td>
<td>1500</td>
<td>5</td>
<td>算法</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>4</td>
<td>1004</td>
<td>牛客 4 号</td>
<td>1100</td>
<td>4</td>
<td>算法</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>5</td>
<td>1005</td>
<td>牛客 5 号</td>
<td>1600</td>
<td>6</td>
<td>C++</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>6</td>
<td>1006</td>
<td>牛客 6 号</td>
<td>3000</td>
<td>6</td>
<td>C++</td>
<td>2020-01-01 10:00:00</td>
</tr>
</tbody></table>
<p><strong>释义</strong>：用户 1001 昵称为牛客 1 号，成就值为 3100，用户等级是 7 级，职业方向为算法，注册时间 2020-01-01 10:00:00</p>
<p>试卷信息表 <code>examination_info</code>（<code>exam_id</code> 试卷 ID, <code>tag</code> 试卷类别, <code>difficulty</code> 试卷难度, <code>duration</code> 考试时长, <code>release_time</code> 发布时间） 示例数据如下：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>exam_id</th>
<th>tag</th>
<th>difficulty</th>
<th>duration</th>
<th>release_time</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>9001</td>
<td>SQL</td>
<td>hard</td>
<td>60</td>
<td>2021-09-01 06:00:00</td>
</tr>
<tr>
<td>2</td>
<td>9002</td>
<td>C++</td>
<td>easy</td>
<td>60</td>
<td>2020-02-01 10:00:00</td>
</tr>
<tr>
<td>3</td>
<td>9003</td>
<td>算法</td>
<td>medium</td>
<td>80</td>
<td>2020-08-02 10:00:00</td>
</tr>
</tbody></table>
<p>试卷作答记录表 <code>exam_record</code>（<code>uid</code> 用户 ID, <code>exam_id</code> 试卷 ID, <code>start_time</code> 开始作答时间, <code>submit_time</code> 交卷时间, <code>score</code> 得分） 示例数据如下：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>uid</th>
<th>exam_id</th>
<th>start_time</th>
<th>submit_time</th>
<th>score</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1001</td>
<td>9001</td>
<td>2021-07-02 09:01:01</td>
<td>2021-09-01 09:41:01</td>
<td>70</td>
</tr>
<tr>
<td>2</td>
<td>1002</td>
<td>9003</td>
<td>2021-09-01 12:01:01</td>
<td>2021-09-01 12:21:01</td>
<td>60</td>
</tr>
<tr>
<td>3</td>
<td>1002</td>
<td>9002</td>
<td>2021-09-02 12:01:01</td>
<td>2021-09-02 12:31:01</td>
<td>70</td>
</tr>
<tr>
<td>4</td>
<td>1002</td>
<td>9001</td>
<td>2021-09-01 19:01:01</td>
<td>2021-09-01 19:40:01</td>
<td>80</td>
</tr>
<tr>
<td>5</td>
<td>1002</td>
<td>9003</td>
<td>2021-08-01 12:01:01</td>
<td>2021-08-01 12:21:01</td>
<td>60</td>
</tr>
<tr>
<td>6</td>
<td>1002</td>
<td>9002</td>
<td>2021-08-02 12:01:01</td>
<td>2021-08-02 12:31:01</td>
<td>70</td>
</tr>
<tr>
<td>7</td>
<td>1002</td>
<td>9001</td>
<td>2021-09-01 19:01:01</td>
<td>2021-09-01 19:40:01</td>
<td>85</td>
</tr>
<tr>
<td>8</td>
<td>1002</td>
<td>9002</td>
<td>2021-07-06 12:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>9</td>
<td>1003</td>
<td>9002</td>
<td>2021-09-07 10:01:01</td>
<td>2021-09-07 10:31:01</td>
<td>86</td>
</tr>
<tr>
<td>10</td>
<td>1003</td>
<td>9003</td>
<td>2021-09-08 12:01:01</td>
<td>2021-09-08 12:11:01</td>
<td>40</td>
</tr>
<tr>
<td>11</td>
<td>1003</td>
<td>9003</td>
<td>2021-09-01 13:01:01</td>
<td>2021-09-01 13:41:01</td>
<td>70</td>
</tr>
<tr>
<td>12</td>
<td>1003</td>
<td>9001</td>
<td>2021-09-08 14:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>13</td>
<td>1003</td>
<td>9002</td>
<td>2021-09-08 15:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>14</td>
<td>1005</td>
<td>9001</td>
<td>2021-09-01 12:01:01</td>
<td>2021-09-01 12:31:01</td>
<td>90</td>
</tr>
<tr>
<td>15</td>
<td>1005</td>
<td>9002</td>
<td>2021-09-01 12:01:01</td>
<td>2021-09-01 12:31:01</td>
<td>88</td>
</tr>
<tr>
<td>16</td>
<td>1005</td>
<td>9002</td>
<td>2021-09-02 12:11:01</td>
<td>2021-09-02 12:31:01</td>
<td>89</td>
</tr>
</tbody></table>
<p>请计算每张 SQL 类别试卷发布后，当天 5 级以上的用户作答的人数 <code>uv</code> 和平均分 <code>avg_score</code>，按人数降序，相同人数的按平均分升序，示例数据结果输出如下：</p>
<table>
<thead>
<tr>
<th>exam_id</th>
<th>uv</th>
<th>avg_score</th>
</tr>
</thead>
<tbody><tr>
<td>9001</td>
<td>3</td>
<td>81.3</td>
</tr>
</tbody></table>
<p>解释：只有一张 SQL 类别的试卷，试卷 ID 为 9001，发布当天（2021-09-01）有 1001、1002、1003、1005 作答过，但是 1003 是 5 级用户，其他 3 位为 5 级以上，他们三的得分有[70,80,85,90]，平均分为 81.3（保留 1 位小数）。</p>
<p><strong>思路</strong>：这题看似很复杂，但是先逐步将“外边”条件拆分，然后合拢到一起，答案就出来，多表查询反正记住：由外向里，抽丝剥茧。</p>
<p>先把三种表连起来，同时给定一些条件，比如题目中要求<code>等级&gt; 5</code>的用户，那么可以先查出来</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> u_info.uid</span><br><span class="line"><span class="keyword">FROM</span> examination_info e_info</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> exam_record record</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> user_info u_info</span><br><span class="line"><span class="keyword">WHERE</span> e_info.exam_id <span class="operator">=</span> record.exam_id</span><br><span class="line">  <span class="keyword">AND</span> u_info.uid <span class="operator">=</span> record.uid</span><br><span class="line">  <span class="keyword">AND</span> u_info.LEVEL <span class="operator">&gt;</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>接着注意题目中要求：<code>每张sql类别试卷发布后，当天作答用户</code>，注意其中的&#x3D;&#x3D;当天&#x3D;&#x3D;，那我们马上就要想到要用到时间的比较。</p>
<p>对试卷发布日期和开始考试日期进行比较：<code>DATE(e_info.release_time) = DATE(record.start_time)</code>；不用担心<code>submit_time</code> 为 null 的问题，后续在 where 中会给过滤掉。</p>
<p><strong>答案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> record.exam_id <span class="keyword">AS</span> exam_id,</span><br><span class="line">       <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> u_info.uid) <span class="keyword">AS</span> uv,</span><br><span class="line">       ROUND(<span class="built_in">SUM</span>(record.score) <span class="operator">/</span> <span class="built_in">COUNT</span>(u_info.uid), <span class="number">1</span>) <span class="keyword">AS</span> avg_score</span><br><span class="line"><span class="keyword">FROM</span> examination_info e_info</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> exam_record record</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> user_info u_info</span><br><span class="line"><span class="keyword">WHERE</span> e_info.exam_id <span class="operator">=</span> record.exam_id</span><br><span class="line">  <span class="keyword">AND</span> u_info.uid <span class="operator">=</span> record.uid</span><br><span class="line">  <span class="keyword">AND</span> <span class="type">DATE</span> (e_info.release_time) <span class="operator">=</span> <span class="type">DATE</span> (record.start_time)</span><br><span class="line">  <span class="keyword">AND</span> submit_time <span class="keyword">IS</span> <span class="keyword">NOT NULL</span></span><br><span class="line">  <span class="keyword">AND</span> tag <span class="operator">=</span> <span class="string">&#x27;SQL&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> u_info.LEVEL <span class="operator">&gt;</span> <span class="number">5</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> record.exam_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> uv <span class="keyword">DESC</span>,</span><br><span class="line">         avg_score <span class="keyword">ASC</span></span><br></pre></td></tr></table></figure>

<p>注意最后的分组排序！先按人数排，若一致，按平均分排。</p>
<h3 id="作答试卷得分大于过-80-的人的用户等级分布"><a href="#作答试卷得分大于过-80-的人的用户等级分布" class="headerlink" title="作答试卷得分大于过 80 的人的用户等级分布"></a>作答试卷得分大于过 80 的人的用户等级分布</h3><p><strong>描述</strong>：</p>
<p>现有用户信息表 <code>user_info</code>（<code>uid</code> 用户 ID，<code>nick_name</code> 昵称, <code>achievement</code> 成就值, <code>level</code> 等级, <code>job</code> 职业方向, <code>register_time</code> 注册时间）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>uid</th>
<th>nick_name</th>
<th>achievement</th>
<th>level</th>
<th>job</th>
<th>register_time</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1001</td>
<td>牛客 1 号</td>
<td>3100</td>
<td>7</td>
<td>算法</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>2</td>
<td>1002</td>
<td>牛客 2 号</td>
<td>2100</td>
<td>6</td>
<td>算法</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>3</td>
<td>1003</td>
<td>牛客 3 号</td>
<td>1500</td>
<td>5</td>
<td>算法</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>4</td>
<td>1004</td>
<td>牛客 4 号</td>
<td>1100</td>
<td>4</td>
<td>算法</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>5</td>
<td>1005</td>
<td>牛客 5 号</td>
<td>1600</td>
<td>6</td>
<td>C++</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>6</td>
<td>1006</td>
<td>牛客 6 号</td>
<td>3000</td>
<td>6</td>
<td>C++</td>
<td>2020-01-01 10:00:00</td>
</tr>
</tbody></table>
<p>试卷信息表 <code>examination_info</code>（<code>exam_id</code> 试卷 ID, <code>tag</code> 试卷类别, <code>difficulty</code> 试卷难度, <code>duration</code> 考试时长, <code>release_time</code> 发布时间）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>exam_id</th>
<th>tag</th>
<th>difficulty</th>
<th>duration</th>
<th>release_time</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>9001</td>
<td>SQL</td>
<td>hard</td>
<td>60</td>
<td>2021-09-01 06:00:00</td>
</tr>
<tr>
<td>2</td>
<td>9002</td>
<td>C++</td>
<td>easy</td>
<td>60</td>
<td>2021-09-01 06:00:00</td>
</tr>
<tr>
<td>3</td>
<td>9003</td>
<td>算法</td>
<td>medium</td>
<td>80</td>
<td>2021-09-01 10:00:00</td>
</tr>
</tbody></table>
<p>试卷作答信息表 <code>exam_record</code>（<code>uid</code> 用户 ID, <code>exam_id</code> 试卷 ID, <code>start_time</code> 开始作答时间, <code>submit_time</code> 交卷时间, <code>score</code> 得分）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>uid</th>
<th>exam_id</th>
<th>start_time</th>
<th>submit_time</th>
<th>score</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1001</td>
<td>9001</td>
<td>2021-09-01 09:01:01</td>
<td>2021-09-01 09:41:01</td>
<td>79</td>
</tr>
<tr>
<td>2</td>
<td>1002</td>
<td>9003</td>
<td>2021-09-01 12:01:01</td>
<td>2021-09-01 12:21:01</td>
<td>60</td>
</tr>
<tr>
<td>3</td>
<td>1002</td>
<td>9002</td>
<td>2021-09-01 12:01:01</td>
<td>2021-09-01 12:31:01</td>
<td>70</td>
</tr>
<tr>
<td>4</td>
<td>1002</td>
<td>9001</td>
<td>2021-09-01 19:01:01</td>
<td>2021-09-01 19:40:01</td>
<td>80</td>
</tr>
<tr>
<td>5</td>
<td>1002</td>
<td>9003</td>
<td>2021-08-01 12:01:01</td>
<td>2021-08-01 12:21:01</td>
<td>60</td>
</tr>
<tr>
<td>6</td>
<td>1002</td>
<td>9002</td>
<td>2021-09-01 12:01:01</td>
<td>2021-09-01 12:31:01</td>
<td>70</td>
</tr>
<tr>
<td>7</td>
<td>1002</td>
<td>9001</td>
<td>2021-09-01 19:01:01</td>
<td>2021-09-01 19:40:01</td>
<td>85</td>
</tr>
<tr>
<td>8</td>
<td>1002</td>
<td>9002</td>
<td>2021-09-01 12:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>9</td>
<td>1003</td>
<td>9002</td>
<td>2021-09-07 10:01:01</td>
<td>2021-09-07 10:31:01</td>
<td>86</td>
</tr>
<tr>
<td>10</td>
<td>1003</td>
<td>9003</td>
<td>2021-09-08 12:01:01</td>
<td>2021-09-08 12:11:01</td>
<td>40</td>
</tr>
<tr>
<td>11</td>
<td>1003</td>
<td>9003</td>
<td>2021-09-01 13:01:01</td>
<td>2021-09-01 13:41:01</td>
<td>81</td>
</tr>
<tr>
<td>12</td>
<td>1003</td>
<td>9001</td>
<td>2021-09-01 14:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>13</td>
<td>1003</td>
<td>9002</td>
<td>2021-09-08 15:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>14</td>
<td>1005</td>
<td>9001</td>
<td>2021-09-01 12:01:01</td>
<td>2021-09-01 12:31:01</td>
<td>90</td>
</tr>
<tr>
<td>15</td>
<td>1005</td>
<td>9002</td>
<td>2021-09-01 12:01:01</td>
<td>2021-09-01 12:31:01</td>
<td>88</td>
</tr>
<tr>
<td>16</td>
<td>1005</td>
<td>9002</td>
<td>2021-09-02 12:11:01</td>
<td>2021-09-02 12:31:01</td>
<td>89</td>
</tr>
</tbody></table>
<p>统计作答 SQL 类别的试卷得分大于过 80 的人的用户等级分布，按数量降序排序（保证数量都不同）。示例数据结果输出如下：</p>
<table>
<thead>
<tr>
<th>level</th>
<th>level_cnt</th>
</tr>
</thead>
<tbody><tr>
<td>6</td>
<td>2</td>
</tr>
<tr>
<td>5</td>
<td>1</td>
</tr>
</tbody></table>
<p>解释：9001 为 SQL 类试卷，作答该试卷大于 80 分的人有 1002、1003、1005 共 3 人，6 级两人，5 级一人。</p>
<p><strong>思路：</strong>这题和上一题都是一样的数据，只是查询条件改变了而已，上一题理解了，这题分分钟做出来。</p>
<p><strong>答案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> u_info.LEVEL <span class="keyword">AS</span> LEVEL,</span><br><span class="line">       <span class="built_in">count</span>(u_info.uid) <span class="keyword">AS</span> level_cnt</span><br><span class="line"><span class="keyword">FROM</span> examination_info e_info</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> exam_record record</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> user_info u_info</span><br><span class="line"><span class="keyword">WHERE</span> e_info.exam_id <span class="operator">=</span> record.exam_id</span><br><span class="line">  <span class="keyword">AND</span> u_info.uid <span class="operator">=</span> record.uid</span><br><span class="line">  <span class="keyword">AND</span> record.score <span class="operator">&gt;</span> <span class="number">80</span></span><br><span class="line">  <span class="keyword">AND</span> submit_time <span class="keyword">IS</span> <span class="keyword">NOT NULL</span></span><br><span class="line">  <span class="keyword">AND</span> tag <span class="operator">=</span> <span class="string">&#x27;SQL&#x27;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> LEVEL</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> level_cnt <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>

<h2 id="合并查询"><a href="#合并查询" class="headerlink" title="合并查询"></a>合并查询</h2><h3 id="每个题目和每份试卷被作答的人数和次数"><a href="#每个题目和每份试卷被作答的人数和次数" class="headerlink" title="每个题目和每份试卷被作答的人数和次数"></a>每个题目和每份试卷被作答的人数和次数</h3><p><strong>描述</strong>：</p>
<p>现有试卷作答记录表 exam_record（uid 用户 ID, exam_id 试卷 ID, start_time 开始作答时间, submit_time 交卷时间, score 得分）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>uid</th>
<th>exam_id</th>
<th>start_time</th>
<th>submit_time</th>
<th>score</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1001</td>
<td>9001</td>
<td>2021-09-01 09:01:01</td>
<td>2021-09-01 09:41:01</td>
<td>81</td>
</tr>
<tr>
<td>2</td>
<td>1002</td>
<td>9002</td>
<td>2021-09-01 12:01:01</td>
<td>2021-09-01 12:31:01</td>
<td>70</td>
</tr>
<tr>
<td>3</td>
<td>1002</td>
<td>9001</td>
<td>2021-09-01 19:01:01</td>
<td>2021-09-01 19:40:01</td>
<td>80</td>
</tr>
<tr>
<td>4</td>
<td>1002</td>
<td>9002</td>
<td>2021-09-01 12:01:01</td>
<td>2021-09-01 12:31:01</td>
<td>70</td>
</tr>
<tr>
<td>5</td>
<td>1004</td>
<td>9001</td>
<td>2021-09-01 19:01:01</td>
<td>2021-09-01 19:40:01</td>
<td>85</td>
</tr>
<tr>
<td>6</td>
<td>1002</td>
<td>9002</td>
<td>2021-09-01 12:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
</tbody></table>
<p>题目练习表 practice_record（uid 用户 ID, question_id 题目 ID, submit_time 提交时间, score 得分）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>uid</th>
<th>question_id</th>
<th>submit_time</th>
<th>score</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1001</td>
<td>8001</td>
<td>2021-08-02 11:41:01</td>
<td>60</td>
</tr>
<tr>
<td>2</td>
<td>1002</td>
<td>8001</td>
<td>2021-09-02 19:30:01</td>
<td>50</td>
</tr>
<tr>
<td>3</td>
<td>1002</td>
<td>8001</td>
<td>2021-09-02 19:20:01</td>
<td>70</td>
</tr>
<tr>
<td>4</td>
<td>1002</td>
<td>8002</td>
<td>2021-09-02 19:38:01</td>
<td>70</td>
</tr>
<tr>
<td>5</td>
<td>1003</td>
<td>8001</td>
<td>2021-08-02 19:38:01</td>
<td>70</td>
</tr>
<tr>
<td>6</td>
<td>1003</td>
<td>8001</td>
<td>2021-08-02 19:48:01</td>
<td>90</td>
</tr>
<tr>
<td>7</td>
<td>1003</td>
<td>8002</td>
<td>2021-08-01 19:38:01</td>
<td>80</td>
</tr>
</tbody></table>
<p>请统计每个题目和每份试卷被作答的人数和次数，分别按照”试卷”和”题目”的 uv &amp; pv 降序显示，示例数据结果输出如下：</p>
<table>
<thead>
<tr>
<th>tid</th>
<th>uv</th>
<th>pv</th>
</tr>
</thead>
<tbody><tr>
<td>9001</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>9002</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>8001</td>
<td>3</td>
<td>5</td>
</tr>
<tr>
<td>8002</td>
<td>2</td>
<td>2</td>
</tr>
</tbody></table>
<p><strong>解释</strong>：“试卷”有 3 人共练习 3 次试卷 9001，1 人作答 3 次 9002；“刷题”有 3 人刷 5 次 8001，有 2 人刷 2 次 8002</p>
<p><strong>思路</strong>：这题的难点和易错点在于<code>UNION</code>和<code>ORDER BY</code> 同时使用的问题</p>
<p>有以下几种情况：使用<code>union</code>和多个<code>order by</code>不加括号，报错！</p>
<p><code>order by</code>在<code>union</code>连接的子句中不起作用；</p>
<p>比如不加括号：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> exam_id <span class="keyword">AS</span> tid,</span><br><span class="line">       <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> UID) <span class="keyword">AS</span> uv,</span><br><span class="line">       <span class="built_in">COUNT</span>(UID) <span class="keyword">AS</span> pv</span><br><span class="line"><span class="keyword">FROM</span> exam_record</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> exam_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> uv <span class="keyword">DESC</span>,</span><br><span class="line">         pv <span class="keyword">DESC</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> question_id <span class="keyword">AS</span> tid,</span><br><span class="line">       <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> UID) <span class="keyword">AS</span> uv,</span><br><span class="line">       <span class="built_in">COUNT</span>(UID) <span class="keyword">AS</span> pv</span><br><span class="line"><span class="keyword">FROM</span> practice_record</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> question_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> uv <span class="keyword">DESC</span>,</span><br><span class="line">         pv <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>

<p>直接报语法错误，如果没有括号，只能有一个<code>order by</code></p>
<p>还有一种<code>order by</code>不起作用的情况，但是能在子句的子句中起作用，这里的解决方案就是在外面再套一层查询。</p>
<p><strong>答案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  (<span class="keyword">SELECT</span> exam_id <span class="keyword">AS</span> tid,</span><br><span class="line">          <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> exam_record.uid) uv,</span><br><span class="line">          <span class="built_in">COUNT</span>(<span class="operator">*</span>) pv</span><br><span class="line">   <span class="keyword">FROM</span> exam_record</span><br><span class="line">   <span class="keyword">GROUP</span> <span class="keyword">BY</span> exam_id</span><br><span class="line">   <span class="keyword">ORDER</span> <span class="keyword">BY</span> uv <span class="keyword">DESC</span>, pv <span class="keyword">DESC</span>) t1</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  (<span class="keyword">SELECT</span> question_id <span class="keyword">AS</span> tid,</span><br><span class="line">          <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> practice_record.uid) uv,</span><br><span class="line">          <span class="built_in">COUNT</span>(<span class="operator">*</span>) pv</span><br><span class="line">   <span class="keyword">FROM</span> practice_record</span><br><span class="line">   <span class="keyword">GROUP</span> <span class="keyword">BY</span> question_id</span><br><span class="line">   <span class="keyword">ORDER</span> <span class="keyword">BY</span> uv <span class="keyword">DESC</span>, pv <span class="keyword">DESC</span>) t2;</span><br></pre></td></tr></table></figure>

<h3 id="分别满足两个活动的人"><a href="#分别满足两个活动的人" class="headerlink" title="分别满足两个活动的人"></a>分别满足两个活动的人</h3><p><strong>描述</strong>： 为了促进更多用户在牛客平台学习和刷题进步，我们会经常给一些既活跃又表现不错的用户发放福利。假使以前我们有两拨运营活动，分别给每次试卷得分都能到 85 分的人（activity1）、至少有一次用了一半时间就完成高难度试卷且分数大于 80 的人（activity2）发了福利券。</p>
<p>现在，需要你一次性将这两个活动满足的人筛选出来，交给运营同学。请写出一个 SQL 实现：输出 2021 年里，所有每次试卷得分都能到 85 分的人以及至少有一次用了一半时间就完成高难度试卷且分数大于 80 的人的 id 和活动号，按用户 ID 排序输出。</p>
<p>现有试卷信息表 <code>examination_info</code>（<code>exam_id</code> 试卷 ID, <code>tag</code> 试卷类别, <code>difficulty</code> 试卷难度, <code>duration</code> 考试时长, <code>release_time</code> 发布时间）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>exam_id</th>
<th>tag</th>
<th>difficulty</th>
<th>duration</th>
<th>release_time</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>9001</td>
<td>SQL</td>
<td>hard</td>
<td>60</td>
<td>2021-09-01 06:00:00</td>
</tr>
<tr>
<td>2</td>
<td>9002</td>
<td>C++</td>
<td>easy</td>
<td>60</td>
<td>2021-09-01 06:00:00</td>
</tr>
<tr>
<td>3</td>
<td>9003</td>
<td>算法</td>
<td>medium</td>
<td>80</td>
<td>2021-09-01 10:00:00</td>
</tr>
</tbody></table>
<p>试卷作答记录表 <code>exam_record</code>（<code>uid</code> 用户 ID, <code>exam_id</code> 试卷 ID, <code>start_time</code> 开始作答时间, <code>submit_time</code> 交卷时间, <code>score</code> 得分）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>uid</th>
<th>exam_id</th>
<th>start_time</th>
<th>submit_time</th>
<th>score</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1001</td>
<td>9001</td>
<td>2021-09-01 09:01:01</td>
<td>2021-09-01 09:31:00</td>
<td>81</td>
</tr>
<tr>
<td>2</td>
<td>1002</td>
<td>9002</td>
<td>2021-09-01 12:01:01</td>
<td>2021-09-01 12:31:01</td>
<td>70</td>
</tr>
<tr>
<td>3</td>
<td>1003</td>
<td>9001</td>
<td>2021-09-01 19:01:01</td>
<td>2021-09-01 19:40:01</td>
<td><strong>86</strong></td>
</tr>
<tr>
<td>4</td>
<td>1003</td>
<td>9002</td>
<td>2021-09-01 12:01:01</td>
<td>2021-09-01 12:31:01</td>
<td>89</td>
</tr>
<tr>
<td>5</td>
<td>1004</td>
<td>9001</td>
<td>2021-09-01 19:01:01</td>
<td>2021-09-01 19:30:01</td>
<td>85</td>
</tr>
</tbody></table>
<p>示例数据输出结果：</p>
<table>
<thead>
<tr>
<th>uid</th>
<th>activity</th>
</tr>
</thead>
<tbody><tr>
<td>1001</td>
<td>activity2</td>
</tr>
<tr>
<td>1003</td>
<td>activity1</td>
</tr>
<tr>
<td>1004</td>
<td>activity1</td>
</tr>
<tr>
<td>1004</td>
<td>activity2</td>
</tr>
</tbody></table>
<p><strong>解释</strong>：用户 1001 最小分数 81 不满足活动 1，但 29 分 59 秒完成了 60 分钟长的试卷得分 81，满足活动 2；1003 最小分数 86 满足活动 1，完成时长都大于试卷时长的一半，不满足活动 2；用户 1004 刚好用了一半时间（30 分钟整）完成了试卷得分 85，满足活动 1 和活动 2。</p>
<p><strong>思路</strong>： 这一题需要涉及到时间的减法，需要用到 <code>TIMESTAMPDIFF()</code> 函数计算两个时间戳之间的分钟差值。</p>
<p>下面我们来看一下基本用法</p>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TIMESTAMPDIFF(<span class="keyword">MINUTE</span>, start_time, end_time)</span><br></pre></td></tr></table></figure>

<p><code>TIMESTAMPDIFF()</code> 函数的第一个参数是时间单位，这里我们选择 <code>MINUTE</code> 表示返回分钟差值。第二个参数是较早的时间戳，第三个参数是较晚的时间戳。函数会返回它们之间的分钟差值</p>
<p>了解了这个函数的用法之后，我们再回过头来看<code>activity1</code>的要求，求分数大于 85 即可，那我们还是先把这个写出来，后续思路就会清晰很多</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> UID</span><br><span class="line"><span class="keyword">FROM</span> exam_record</span><br><span class="line"><span class="keyword">WHERE</span> score <span class="operator">&gt;=</span> <span class="number">85</span></span><br><span class="line">  <span class="keyword">AND</span> <span class="keyword">YEAR</span> (start_time) <span class="operator">=</span> <span class="string">&#x27;2021&#x27;</span></span><br></pre></td></tr></table></figure>

<p>根据条件 2，接着写出<code>在一半时间内完成高难度试卷且分数大于80的人</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> UID</span><br><span class="line"><span class="keyword">FROM</span> examination_info info</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> exam_record record</span><br><span class="line"><span class="keyword">WHERE</span> info.exam_id <span class="operator">=</span> record.exam_id</span><br><span class="line">  <span class="keyword">AND</span> (TIMESTAMPDIFF(<span class="keyword">MINUTE</span>, start_time, submit_time)) <span class="operator">&lt;</span> (info.duration <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">AND</span> difficulty <span class="operator">=</span> <span class="string">&#x27;hard&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> score <span class="operator">&gt;=</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>然后再把两者<code>UNION</code> 起来即可。（这里特别要注意括号问题和<code>order by</code>位置，具体用法在上一篇中已提及）</p>
<p><strong>答案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> UID UID,</span><br><span class="line">                    <span class="string">&#x27;activity1&#x27;</span> activity</span><br><span class="line"><span class="keyword">FROM</span> exam_record</span><br><span class="line"><span class="keyword">WHERE</span> UID <span class="keyword">not</span> <span class="keyword">in</span></span><br><span class="line">    (<span class="keyword">SELECT</span> UID</span><br><span class="line">     <span class="keyword">FROM</span> exam_record</span><br><span class="line">     <span class="keyword">WHERE</span> score<span class="operator">&lt;</span><span class="number">85</span></span><br><span class="line">       <span class="keyword">AND</span> <span class="keyword">YEAR</span>(submit_time) <span class="operator">=</span> <span class="number">2021</span> )</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> UID UID,</span><br><span class="line">                    <span class="string">&#x27;activity2&#x27;</span> activity</span><br><span class="line"><span class="keyword">FROM</span> exam_record e_r</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> examination_info e_i <span class="keyword">ON</span> e_r.exam_id <span class="operator">=</span> e_i.exam_id</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">YEAR</span>(submit_time) <span class="operator">=</span> <span class="number">2021</span></span><br><span class="line">  <span class="keyword">AND</span> difficulty <span class="operator">=</span> <span class="string">&#x27;hard&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> TIMESTAMPDIFF(<span class="keyword">SECOND</span>, start_time, submit_time) <span class="operator">&lt;=</span> duration <span class="operator">*</span><span class="number">30</span></span><br><span class="line">  <span class="keyword">AND</span> score<span class="operator">&gt;</span><span class="number">80</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> UID</span><br></pre></td></tr></table></figure>

<h2 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h2><h3 id="满足条件的用户的试卷完成数和题目练习数（困难）"><a href="#满足条件的用户的试卷完成数和题目练习数（困难）" class="headerlink" title="满足条件的用户的试卷完成数和题目练习数（困难）"></a>满足条件的用户的试卷完成数和题目练习数（困难）</h3><p><strong>描述</strong>：</p>
<p>现有用户信息表 user_info（uid 用户 ID，nick_name 昵称, achievement 成就值, level 等级, job 职业方向, register_time 注册时间）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>uid</th>
<th>nick_name</th>
<th>achievement</th>
<th>level</th>
<th>job</th>
<th>register_time</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1001</td>
<td>牛客 1 号</td>
<td>3100</td>
<td>7</td>
<td>算法</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>2</td>
<td>1002</td>
<td>牛客 2 号</td>
<td>2300</td>
<td>7</td>
<td>算法</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>3</td>
<td>1003</td>
<td>牛客 3 号</td>
<td>2500</td>
<td>7</td>
<td>算法</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>4</td>
<td>1004</td>
<td>牛客 4 号</td>
<td>1200</td>
<td>5</td>
<td>算法</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>5</td>
<td>1005</td>
<td>牛客 5 号</td>
<td>1600</td>
<td>6</td>
<td>C++</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>6</td>
<td>1006</td>
<td>牛客 6 号</td>
<td>2000</td>
<td>6</td>
<td>C++</td>
<td>2020-01-01 10:00:00</td>
</tr>
</tbody></table>
<p>试卷信息表 examination_info（exam_id 试卷 ID, tag 试卷类别, difficulty 试卷难度, duration 考试时长, release_time 发布时间）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>exam_id</th>
<th>tag</th>
<th>difficulty</th>
<th>duration</th>
<th>release_time</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>9001</td>
<td>SQL</td>
<td>hard</td>
<td>60</td>
<td>2021-09-01 06:00:00</td>
</tr>
<tr>
<td>2</td>
<td>9002</td>
<td>C++</td>
<td>hard</td>
<td>60</td>
<td>2021-09-01 06:00:00</td>
</tr>
<tr>
<td>3</td>
<td>9003</td>
<td>算法</td>
<td>medium</td>
<td>80</td>
<td>2021-09-01 10:00:00</td>
</tr>
</tbody></table>
<p>试卷作答记录表 exam_record（uid 用户 ID, exam_id 试卷 ID, start_time 开始作答时间, submit_time 交卷时间, score 得分）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>uid</th>
<th>exam_id</th>
<th>start_time</th>
<th>submit_time</th>
<th>score</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1001</td>
<td>9001</td>
<td>2021-09-01 09:01:01</td>
<td>2021-09-01 09:31:00</td>
<td>81</td>
</tr>
<tr>
<td>2</td>
<td>1002</td>
<td>9002</td>
<td>2021-09-01 12:01:01</td>
<td>2021-09-01 12:31:01</td>
<td>81</td>
</tr>
<tr>
<td>3</td>
<td>1003</td>
<td>9001</td>
<td>2021-09-01 19:01:01</td>
<td>2021-09-01 19:40:01</td>
<td>86</td>
</tr>
<tr>
<td>4</td>
<td>1003</td>
<td>9002</td>
<td>2021-09-01 12:01:01</td>
<td>2021-09-01 12:31:51</td>
<td>89</td>
</tr>
<tr>
<td>5</td>
<td>1004</td>
<td>9001</td>
<td>2021-09-01 19:01:01</td>
<td>2021-09-01 19:30:01</td>
<td>85</td>
</tr>
<tr>
<td>6</td>
<td>1005</td>
<td>9002</td>
<td>2021-09-01 12:01:01</td>
<td>2021-09-01 12:31:02</td>
<td>85</td>
</tr>
<tr>
<td>7</td>
<td>1006</td>
<td>9003</td>
<td>2021-09-07 10:01:01</td>
<td>2021-09-07 10:21:01</td>
<td>84</td>
</tr>
<tr>
<td>8</td>
<td>1006</td>
<td>9001</td>
<td>2021-09-07 10:01:01</td>
<td>2021-09-07 10:21:01</td>
<td>80</td>
</tr>
</tbody></table>
<p>题目练习记录表 practice_record（uid 用户 ID, question_id 题目 ID, submit_time 提交时间, score 得分）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>uid</th>
<th>question_id</th>
<th>submit_time</th>
<th>score</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1001</td>
<td>8001</td>
<td>2021-08-02 11:41:01</td>
<td>60</td>
</tr>
<tr>
<td>2</td>
<td>1002</td>
<td>8001</td>
<td>2021-09-02 19:30:01</td>
<td>50</td>
</tr>
<tr>
<td>3</td>
<td>1002</td>
<td>8001</td>
<td>2021-09-02 19:20:01</td>
<td>70</td>
</tr>
<tr>
<td>4</td>
<td>1002</td>
<td>8002</td>
<td>2021-09-02 19:38:01</td>
<td>70</td>
</tr>
<tr>
<td>5</td>
<td>1004</td>
<td>8001</td>
<td>2021-08-02 19:38:01</td>
<td>70</td>
</tr>
<tr>
<td>6</td>
<td>1004</td>
<td>8002</td>
<td>2021-08-02 19:48:01</td>
<td>90</td>
</tr>
<tr>
<td>7</td>
<td>1001</td>
<td>8002</td>
<td>2021-08-02 19:38:01</td>
<td>70</td>
</tr>
<tr>
<td>8</td>
<td>1004</td>
<td>8002</td>
<td>2021-08-02 19:48:01</td>
<td>90</td>
</tr>
<tr>
<td>9</td>
<td>1004</td>
<td>8002</td>
<td>2021-08-02 19:58:01</td>
<td>94</td>
</tr>
<tr>
<td>10</td>
<td>1004</td>
<td>8003</td>
<td>2021-08-02 19:38:01</td>
<td>70</td>
</tr>
<tr>
<td>11</td>
<td>1004</td>
<td>8003</td>
<td>2021-08-02 19:48:01</td>
<td>90</td>
</tr>
<tr>
<td>12</td>
<td>1004</td>
<td>8003</td>
<td>2021-08-01 19:38:01</td>
<td>80</td>
</tr>
</tbody></table>
<p>请你找到高难度 SQL 试卷得分平均值大于 80 并且是 7 级的红名大佬，统计他们的 2021 年试卷总完成次数和题目总练习次数，只保留 2021 年有试卷完成记录的用户。结果按试卷完成数升序，按题目练习数降序。</p>
<p>示例数据输出如下：</p>
<table>
<thead>
<tr>
<th>uid</th>
<th>exam_cnt</th>
<th>question_cnt</th>
</tr>
</thead>
<tbody><tr>
<td>1001</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>1003</td>
<td>2</td>
<td>0</td>
</tr>
</tbody></table>
<p>解释：用户 1001、1003、1004、1006 满足高难度 SQL 试卷得分平均值大于 80，但只有 1001、1003 是 7 级红名大佬；1001 完成了 1 次试卷 1001，练习了 2 次题目；1003 完成了 2 次试卷 9001、9002，未练习题目（因此计数为 0）</p>
<p><strong>思路：</strong></p>
<p>先将条件进行初步筛选，比如先查出做过高难度 sql 试卷的用户</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	record.uid</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	exam_record record</span><br><span class="line">	<span class="keyword">INNER</span> <span class="keyword">JOIN</span> examination_info e_info <span class="keyword">ON</span> record.exam_id <span class="operator">=</span> e_info.exam_id</span><br><span class="line">	<span class="keyword">JOIN</span> user_info u_info <span class="keyword">ON</span> record.uid <span class="operator">=</span> u_info.uid</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	e_info.tag <span class="operator">=</span> <span class="string">&#x27;SQL&#x27;</span></span><br><span class="line">	<span class="keyword">AND</span> e_info.difficulty <span class="operator">=</span> <span class="string">&#x27;hard&#x27;</span></span><br></pre></td></tr></table></figure>

<p>然后根据题目要求，接着再往里叠条件即可；</p>
<p>但是这里又要注意：</p>
<p>第一：不能<code>YEAR(submit_time)= 2021</code>这个条件放到最后，要在<code>ON</code>条件里，因为左连接存在返回左表全部行，右表为 null 的情形，放在 <code>JOIN</code>条件的 <code>ON</code> 子句中的目的是为了确保在连接两个表时，只有满足年份条件的记录会进行连接。这样可以避免其他年份的记录被包含在结果中。即 1001 做过 2021 年的试卷，但没有练习过，如果把条件放到最后，就会排除掉这种情况。</p>
<p>第二，必须是<code>COUNT(distinct er.exam_id) exam_cnt, COUNT(distinct pr.id) question_cnt，</code>要加 distinct，因为有左连接产生很多重复值。</p>
<p><strong>答案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> er.uid <span class="keyword">AS</span> UID,</span><br><span class="line">       <span class="built_in">count</span>(<span class="keyword">DISTINCT</span> er.exam_id) <span class="keyword">AS</span> exam_cnt,</span><br><span class="line">       <span class="built_in">count</span>(<span class="keyword">DISTINCT</span> pr.id) <span class="keyword">AS</span> question_cnt</span><br><span class="line"><span class="keyword">FROM</span> exam_record er</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> practice_record pr <span class="keyword">ON</span> er.uid <span class="operator">=</span> pr.uid</span><br><span class="line"><span class="keyword">AND</span> <span class="keyword">YEAR</span> (er.submit_time)<span class="operator">=</span> <span class="number">2021</span></span><br><span class="line"><span class="keyword">AND</span> <span class="keyword">YEAR</span> (pr.submit_time)<span class="operator">=</span> <span class="number">2021</span></span><br><span class="line"><span class="keyword">WHERE</span> er.uid <span class="keyword">IN</span></span><br><span class="line">    (<span class="keyword">SELECT</span> er.uid</span><br><span class="line">     <span class="keyword">FROM</span> exam_record er</span><br><span class="line">     <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> examination_info ei <span class="keyword">ON</span> er.exam_id <span class="operator">=</span> ei.exam_id</span><br><span class="line">     <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> user_info ui <span class="keyword">ON</span> er.uid <span class="operator">=</span> ui.uid</span><br><span class="line">     <span class="keyword">WHERE</span> tag <span class="operator">=</span> <span class="string">&#x27;SQL&#x27;</span></span><br><span class="line">       <span class="keyword">AND</span> difficulty <span class="operator">=</span> <span class="string">&#x27;hard&#x27;</span></span><br><span class="line">       <span class="keyword">AND</span> LEVEL <span class="operator">=</span> <span class="number">7</span></span><br><span class="line">     <span class="keyword">GROUP</span> <span class="keyword">BY</span> er.uid</span><br><span class="line">     <span class="keyword">HAVING</span> <span class="built_in">avg</span>(score) <span class="operator">&gt;</span> <span class="number">80</span>)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> er.uid</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> exam_cnt,</span><br><span class="line">         question_cnt <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>

<p>可能细心的小伙伴会发现，为什么明明将条件限制了<code>tag = &#39;SQL&#39; AND difficulty = &#39;hard&#39;</code>，但是用户 1003 仍然能查出两条考试记录，其中一条的考试<code>tag</code>为 <code>C++</code>; 这是由于<code>LEFT JOIN</code>的特性，即使没有与右表匹配的行，左表的所有记录仍然会被保留。</p>
<h3 id="每个-6-7-级用户活跃情况（困难）"><a href="#每个-6-7-级用户活跃情况（困难）" class="headerlink" title="每个 6&#x2F;7 级用户活跃情况（困难）"></a>每个 6&#x2F;7 级用户活跃情况（困难）</h3><p><strong>描述</strong>：</p>
<p>现有用户信息表 <code>user_info</code>（<code>uid</code> 用户 ID，<code>nick_name</code> 昵称, <code>achievement</code> 成就值, <code>level</code> 等级, <code>job</code> 职业方向, <code>register_time</code> 注册时间）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>uid</th>
<th>nick_name</th>
<th>achievement</th>
<th>level</th>
<th>job</th>
<th>register_time</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1001</td>
<td>牛客 1 号</td>
<td>3100</td>
<td>7</td>
<td>算法</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>2</td>
<td>1002</td>
<td>牛客 2 号</td>
<td>2300</td>
<td>7</td>
<td>算法</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>3</td>
<td>1003</td>
<td>牛客 3 号</td>
<td>2500</td>
<td>7</td>
<td>算法</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>4</td>
<td>1004</td>
<td>牛客 4 号</td>
<td>1200</td>
<td>5</td>
<td>算法</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>5</td>
<td>1005</td>
<td>牛客 5 号</td>
<td>1600</td>
<td>6</td>
<td>C++</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>6</td>
<td>1006</td>
<td>牛客 6 号</td>
<td>2600</td>
<td>7</td>
<td>C++</td>
<td>2020-01-01 10:00:00</td>
</tr>
</tbody></table>
<p>试卷信息表 <code>examination_info</code>（<code>exam_id</code> 试卷 ID, <code>tag</code> 试卷类别, <code>difficulty</code> 试卷难度, <code>duration</code> 考试时长, <code>release_time</code> 发布时间）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>exam_id</th>
<th>tag</th>
<th>difficulty</th>
<th>duration</th>
<th>release_time</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>9001</td>
<td>SQL</td>
<td>hard</td>
<td>60</td>
<td>2021-09-01 06:00:00</td>
</tr>
<tr>
<td>2</td>
<td>9002</td>
<td>C++</td>
<td>easy</td>
<td>60</td>
<td>2021-09-01 06:00:00</td>
</tr>
<tr>
<td>3</td>
<td>9003</td>
<td>算法</td>
<td>medium</td>
<td>80</td>
<td>2021-09-01 10:00:00</td>
</tr>
</tbody></table>
<p>试卷作答记录表 <code>exam_record</code>（<code>uid</code> 用户 ID, <code>exam_id</code> 试卷 ID, <code>start_time</code> 开始作答时间, <code>submit_time</code> 交卷时间, <code>score</code> 得分）：</p>
<table>
<thead>
<tr>
<th>uid</th>
<th>exam_id</th>
<th>start_time</th>
<th>submit_time</th>
<th>score</th>
</tr>
</thead>
<tbody><tr>
<td>1001</td>
<td>9001</td>
<td>2021-09-01 09:01:01</td>
<td>2021-09-01 09:31:00</td>
<td>78</td>
</tr>
<tr>
<td>1001</td>
<td>9001</td>
<td>2021-09-01 09:01:01</td>
<td>2021-09-01 09:31:00</td>
<td>81</td>
</tr>
<tr>
<td>1005</td>
<td>9001</td>
<td>2021-09-01 19:01:01</td>
<td>2021-09-01 19:30:01</td>
<td>85</td>
</tr>
<tr>
<td>1005</td>
<td>9002</td>
<td>2021-09-01 12:01:01</td>
<td>2021-09-01 12:31:02</td>
<td>85</td>
</tr>
<tr>
<td>1006</td>
<td>9003</td>
<td>2021-09-07 10:01:01</td>
<td>2021-09-07 10:21:59</td>
<td>84</td>
</tr>
<tr>
<td>1006</td>
<td>9001</td>
<td>2021-09-07 10:01:01</td>
<td>2021-09-07 10:21:01</td>
<td>81</td>
</tr>
<tr>
<td>1002</td>
<td>9001</td>
<td>2020-09-01 13:01:01</td>
<td>2020-09-01 13:41:01</td>
<td>81</td>
</tr>
<tr>
<td>1005</td>
<td>9001</td>
<td>2021-09-01 14:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
</tbody></table>
<p>题目练习记录表 <code>practice_record</code>（<code>uid</code> 用户 ID, <code>question_id</code> 题目 ID, <code>submit_time</code> 提交时间, <code>score</code> 得分）：</p>
<table>
<thead>
<tr>
<th>uid</th>
<th>question_id</th>
<th>submit_time</th>
<th>score</th>
</tr>
</thead>
<tbody><tr>
<td>1001</td>
<td>8001</td>
<td>2021-08-02 11:41:01</td>
<td>60</td>
</tr>
<tr>
<td>1004</td>
<td>8001</td>
<td>2021-08-02 19:38:01</td>
<td>70</td>
</tr>
<tr>
<td>1004</td>
<td>8002</td>
<td>2021-08-02 19:48:01</td>
<td>90</td>
</tr>
<tr>
<td>1001</td>
<td>8002</td>
<td>2021-08-02 19:38:01</td>
<td>70</td>
</tr>
<tr>
<td>1004</td>
<td>8002</td>
<td>2021-08-02 19:48:01</td>
<td>90</td>
</tr>
<tr>
<td>1006</td>
<td>8002</td>
<td>2021-08-04 19:58:01</td>
<td>94</td>
</tr>
<tr>
<td>1006</td>
<td>8003</td>
<td>2021-08-03 19:38:01</td>
<td>70</td>
</tr>
<tr>
<td>1006</td>
<td>8003</td>
<td>2021-08-02 19:48:01</td>
<td>90</td>
</tr>
<tr>
<td>1006</td>
<td>8003</td>
<td>2020-08-01 19:38:01</td>
<td>80</td>
</tr>
</tbody></table>
<p>请统计每个 6&#x2F;7 级用户总活跃月份数、2021 年活跃天数、2021 年试卷作答活跃天数、2021 年答题活跃天数，按照总活跃月份数、2021 年活跃天数降序排序。由示例数据结果输出如下：</p>
<table>
<thead>
<tr>
<th>uid</th>
<th>act_month_total</th>
<th>act_days_2021</th>
<th>act_days_2021_exam</th>
</tr>
</thead>
<tbody><tr>
<td>1006</td>
<td>3</td>
<td>4</td>
<td>1</td>
</tr>
<tr>
<td>1001</td>
<td>2</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>1005</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1002</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1003</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody></table>
<p><strong>解释</strong>：6&#x2F;7 级用户共有 5 个，其中 1006 在 202109、202108、202008 共 3 个月活跃过，2021 年活跃的日期有 20210907、20210804、20210803、20210802 共 4 天，2021 年在试卷作答区 20210907 活跃 1 天，在题目练习区活跃了 3 天。</p>
<p><strong>思路：</strong></p>
<p>这题的关键在于<code>CASE WHEN THEN</code>的使用，不然要写很多的<code>left join</code> 因为会产生很多的结果集。</p>
<p><code>CASE WHEN THEN</code>语句是一种条件表达式，用于在 SQL 中根据条件执行不同的操作或返回不同的结果。</p>
<p>语法结构如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CASE</span></span><br><span class="line">    <span class="keyword">WHEN</span> condition1 <span class="keyword">THEN</span> result1</span><br><span class="line">    <span class="keyword">WHEN</span> condition2 <span class="keyword">THEN</span> result2</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">ELSE</span> <span class="keyword">result</span></span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>

<p>在这个结构中，可以根据需要添加多个<code>WHEN</code>子句，每个<code>WHEN</code>子句后面跟着一个条件（condition）和一个结果（result）。条件可以是任何逻辑表达式，如果满足条件，将返回对应的结果。</p>
<p>最后的<code>ELSE</code>子句是可选的，用于指定当所有前面的条件都不满足时的默认返回结果。如果没有提供<code>ELSE</code>子句，则默认返回<code>NULL</code>。</p>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> score,</span><br><span class="line">    <span class="keyword">CASE</span></span><br><span class="line">        <span class="keyword">WHEN</span> score <span class="operator">&gt;=</span> <span class="number">90</span> <span class="keyword">THEN</span> <span class="string">&#x27;优秀&#x27;</span></span><br><span class="line">        <span class="keyword">WHEN</span> score <span class="operator">&gt;=</span> <span class="number">80</span> <span class="keyword">THEN</span> <span class="string">&#x27;良好&#x27;</span></span><br><span class="line">        <span class="keyword">WHEN</span> score <span class="operator">&gt;=</span> <span class="number">60</span> <span class="keyword">THEN</span> <span class="string">&#x27;及格&#x27;</span></span><br><span class="line">        <span class="keyword">ELSE</span> <span class="string">&#x27;不及格&#x27;</span></span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">AS</span> grade</span><br><span class="line"><span class="keyword">FROM</span> student_scores;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，根据学生成绩（score）的不同范围，使用 CASE WHEN THEN 语句返回相应的等级（grade）。如果成绩大于等于 90，则返回”优秀”；如果成绩大于等于 80，则返回”良好”；如果成绩大于等于 60，则返回”及格”；否则返回”不及格”。</p>
<p>那了解到了上述的用法之后，回过头看看该题，要求列出不同的活跃天数。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">count</span>(<span class="keyword">distinct</span> act_month) <span class="keyword">as</span> act_month_total,</span><br><span class="line"><span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">case</span> <span class="keyword">when</span> <span class="keyword">year</span>(act_time)<span class="operator">=</span><span class="string">&#x27;2021&#x27;</span><span class="keyword">then</span> act_day <span class="keyword">end</span>) <span class="keyword">as</span> act_days_2021,</span><br><span class="line"><span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">case</span> <span class="keyword">when</span> <span class="keyword">year</span>(act_time)<span class="operator">=</span><span class="string">&#x27;2021&#x27;</span> <span class="keyword">and</span> tag<span class="operator">=</span><span class="string">&#x27;exam&#x27;</span> <span class="keyword">then</span> act_day <span class="keyword">end</span>) <span class="keyword">as</span> act_days_2021_exam,</span><br><span class="line"><span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">case</span> <span class="keyword">when</span> <span class="keyword">year</span>(act_time)<span class="operator">=</span><span class="string">&#x27;2021&#x27;</span> <span class="keyword">and</span> tag<span class="operator">=</span><span class="string">&#x27;question&#x27;</span><span class="keyword">then</span> act_day <span class="keyword">end</span>) <span class="keyword">as</span> act_days_2021_question</span><br></pre></td></tr></table></figure>

<p>这里的 tag 是先给标记，方便对查询进行区分，将考试和答题分开。</p>
<p>找出试卷作答区的用户</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">		uid,</span><br><span class="line">		exam_id <span class="keyword">AS</span> ans_id,</span><br><span class="line">		start_time <span class="keyword">AS</span> act_time,</span><br><span class="line">		date_format( start_time, <span class="string">&#x27;%Y%m&#x27;</span> ) <span class="keyword">AS</span> act_month,</span><br><span class="line">		date_format( start_time, <span class="string">&#x27;%Y%m%d&#x27;</span> ) <span class="keyword">AS</span> act_day,</span><br><span class="line">		<span class="string">&#x27;exam&#x27;</span> <span class="keyword">AS</span> tag</span><br><span class="line">	<span class="keyword">FROM</span></span><br><span class="line">		exam_record</span><br></pre></td></tr></table></figure>

<p>紧接着就是答题作答区的用户</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">		uid,</span><br><span class="line">		question_id <span class="keyword">AS</span> ans_id,</span><br><span class="line">		submit_time <span class="keyword">AS</span> act_time,</span><br><span class="line">		date_format( submit_time, <span class="string">&#x27;%Y%m&#x27;</span> ) <span class="keyword">AS</span> act_month,</span><br><span class="line">		date_format( submit_time, <span class="string">&#x27;%Y%m%d&#x27;</span> ) <span class="keyword">AS</span> act_day,</span><br><span class="line">		<span class="string">&#x27;question&#x27;</span> <span class="keyword">AS</span> tag</span><br><span class="line">	<span class="keyword">FROM</span></span><br><span class="line">		practice_record</span><br></pre></td></tr></table></figure>

<p>最后将两个结果进行<code>UNION</code> 最后别忘了将结果进行排序 （这题有点类似于分治法的思想）</p>
<p><strong>答案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> user_info.uid,</span><br><span class="line">       <span class="built_in">count</span>(<span class="keyword">DISTINCT</span> act_month) <span class="keyword">AS</span> act_month_total,</span><br><span class="line">       <span class="built_in">count</span>(<span class="keyword">DISTINCT</span> <span class="keyword">CASE</span></span><br><span class="line">                          <span class="keyword">WHEN</span> <span class="keyword">YEAR</span> (act_time)<span class="operator">=</span> <span class="string">&#x27;2021&#x27;</span> <span class="keyword">THEN</span> act_day</span><br><span class="line">                      <span class="keyword">END</span>) <span class="keyword">AS</span> act_days_2021,</span><br><span class="line">       <span class="built_in">count</span>(<span class="keyword">DISTINCT</span> <span class="keyword">CASE</span></span><br><span class="line">                          <span class="keyword">WHEN</span> <span class="keyword">YEAR</span> (act_time)<span class="operator">=</span> <span class="string">&#x27;2021&#x27;</span></span><br><span class="line">                               <span class="keyword">AND</span> tag <span class="operator">=</span> <span class="string">&#x27;exam&#x27;</span> <span class="keyword">THEN</span> act_day</span><br><span class="line">                      <span class="keyword">END</span>) <span class="keyword">AS</span> act_days_2021_exam,</span><br><span class="line">       <span class="built_in">count</span>(<span class="keyword">DISTINCT</span> <span class="keyword">CASE</span></span><br><span class="line">                          <span class="keyword">WHEN</span> <span class="keyword">YEAR</span> (act_time)<span class="operator">=</span> <span class="string">&#x27;2021&#x27;</span></span><br><span class="line">                               <span class="keyword">AND</span> tag <span class="operator">=</span> <span class="string">&#x27;question&#x27;</span> <span class="keyword">THEN</span> act_day</span><br><span class="line">                      <span class="keyword">END</span>) <span class="keyword">AS</span> act_days_2021_question</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  (<span class="keyword">SELECT</span> UID,</span><br><span class="line">          exam_id <span class="keyword">AS</span> ans_id,</span><br><span class="line">          start_time <span class="keyword">AS</span> act_time,</span><br><span class="line">          date_format(start_time, <span class="string">&#x27;%Y%m&#x27;</span>) <span class="keyword">AS</span> act_month,</span><br><span class="line">          date_format(start_time, <span class="string">&#x27;%Y%m%d&#x27;</span>) <span class="keyword">AS</span> act_day,</span><br><span class="line">          <span class="string">&#x27;exam&#x27;</span> <span class="keyword">AS</span> tag</span><br><span class="line">   <span class="keyword">FROM</span> exam_record</span><br><span class="line">   <span class="keyword">UNION</span> <span class="keyword">ALL</span> <span class="keyword">SELECT</span> UID,</span><br><span class="line">                    question_id <span class="keyword">AS</span> ans_id,</span><br><span class="line">                    submit_time <span class="keyword">AS</span> act_time,</span><br><span class="line">                    date_format(submit_time, <span class="string">&#x27;%Y%m&#x27;</span>) <span class="keyword">AS</span> act_month,</span><br><span class="line">                    date_format(submit_time, <span class="string">&#x27;%Y%m%d&#x27;</span>) <span class="keyword">AS</span> act_day,</span><br><span class="line">                    <span class="string">&#x27;question&#x27;</span> <span class="keyword">AS</span> tag</span><br><span class="line">   <span class="keyword">FROM</span> practice_record) total</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> user_info <span class="keyword">ON</span> total.uid <span class="operator">=</span> user_info.uid</span><br><span class="line"><span class="keyword">WHERE</span> user_info.LEVEL <span class="keyword">IN</span> (<span class="number">6</span>,</span><br><span class="line">                          <span class="number">7</span>)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> user_info.uid</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> act_month_total <span class="keyword">DESC</span>,</span><br><span class="line">         act_days_2021 <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>

<!-- @include: @article-footer.snippet.md -->

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2024/10/29/sql-questions-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/10/29/sql-questions-01/" itemprop="url">SQL常见面试题总结（1）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-10-29T21:48:04+08:00">
                2024-10-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/" itemprop="url" rel="index">
                    <span itemprop="name">面试问题</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2024/10/29/sql-questions-01/" class="leancloud_visitors" data-flag-title="SQL常见面试题总结（1）">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  9.8k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  42 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>题目来源于：<a href="https://www.nowcoder.com/exam/oj?page=1&tab=SQL%E7%AF%87&topicId=298">牛客题霸 - SQL 必知必会</a></p>
</blockquote>
<h2 id="检索数据"><a href="#检索数据" class="headerlink" title="检索数据"></a>检索数据</h2><p><code>SELECT</code> 用于从数据库中查询数据。</p>
<h3 id="从-Customers-表中检索所有的-ID"><a href="#从-Customers-表中检索所有的-ID" class="headerlink" title="从 Customers 表中检索所有的 ID"></a>从 Customers 表中检索所有的 ID</h3><p>现有表 <code>Customers</code> 如下：</p>
<table>
<thead>
<tr>
<th>cust_id</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
</tr>
<tr>
<td>B</td>
</tr>
<tr>
<td>C</td>
</tr>
</tbody></table>
<p>编写 SQL 语句，从 <code>Customers</code> 表中检索所有的 <code>cust_id</code>。</p>
<p>答案：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_id</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br></pre></td></tr></table></figure>

<h3 id="检索并列出已订购产品的清单"><a href="#检索并列出已订购产品的清单" class="headerlink" title="检索并列出已订购产品的清单"></a>检索并列出已订购产品的清单</h3><p>表 <code>OrderItems</code> 含有非空的列 <code>prod_id</code> 代表商品 id，包含了所有已订购的商品（有些已被订购多次）。</p>
<table>
<thead>
<tr>
<th>prod_id</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
</tr>
<tr>
<td>a2</td>
</tr>
<tr>
<td>a3</td>
</tr>
<tr>
<td>a4</td>
</tr>
<tr>
<td>a5</td>
</tr>
<tr>
<td>a6</td>
</tr>
<tr>
<td>a7</td>
</tr>
</tbody></table>
<p>编写 SQL 语句，检索并列出所有已订购商品（<code>prod_id</code>）的去重后的清单。</p>
<p>答案：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> prod_id</span><br><span class="line"><span class="keyword">FROM</span> OrderItems</span><br></pre></td></tr></table></figure>

<p>知识点：<code>DISTINCT</code> 用于返回列中的唯一不同值。</p>
<h3 id="检索所有列"><a href="#检索所有列" class="headerlink" title="检索所有列"></a>检索所有列</h3><p>现在有 <code>Customers</code> 表（表中含有列 <code>cust_id</code> 代表客户 id，<code>cust_name</code> 代表客户姓名）</p>
<table>
<thead>
<tr>
<th>cust_id</th>
<th>cust_name</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>andy</td>
</tr>
<tr>
<td>a2</td>
<td>ben</td>
</tr>
<tr>
<td>a3</td>
<td>tony</td>
</tr>
<tr>
<td>a4</td>
<td>tom</td>
</tr>
<tr>
<td>a5</td>
<td>an</td>
</tr>
<tr>
<td>a6</td>
<td>lee</td>
</tr>
<tr>
<td>a7</td>
<td>hex</td>
</tr>
</tbody></table>
<p>需要编写 SQL 语句，检索所有列。</p>
<p>答案：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_id, cust_name</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br></pre></td></tr></table></figure>

<h2 id="排序检索数据"><a href="#排序检索数据" class="headerlink" title="排序检索数据"></a>排序检索数据</h2><p><code>ORDER BY</code> 用于对结果集按照一个列或者多个列进行排序。默认按照升序对记录进行排序，如果需要按照降序对记录进行排序，可以使用 <code>DESC</code> 关键字。</p>
<h3 id="检索顾客名称并且排序"><a href="#检索顾客名称并且排序" class="headerlink" title="检索顾客名称并且排序"></a>检索顾客名称并且排序</h3><p>有表 <code>Customers</code>，<code>cust_id</code> 代表客户 id，<code>cust_name</code> 代表客户姓名。</p>
<table>
<thead>
<tr>
<th>cust_id</th>
<th>cust_name</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>andy</td>
</tr>
<tr>
<td>a2</td>
<td>ben</td>
</tr>
<tr>
<td>a3</td>
<td>tony</td>
</tr>
<tr>
<td>a4</td>
<td>tom</td>
</tr>
<tr>
<td>a5</td>
<td>an</td>
</tr>
<tr>
<td>a6</td>
<td>lee</td>
</tr>
<tr>
<td>a7</td>
<td>hex</td>
</tr>
</tbody></table>
<p>从 <code>Customers</code> 中检索所有的顾客名称（<code>cust_name</code>），并按从 Z 到 A 的顺序显示结果。</p>
<p>答案：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cust_name <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>

<h3 id="对顾客-ID-和日期排序"><a href="#对顾客-ID-和日期排序" class="headerlink" title="对顾客 ID 和日期排序"></a>对顾客 ID 和日期排序</h3><p>有 <code>Orders</code> 表：</p>
<table>
<thead>
<tr>
<th>cust_id</th>
<th>order_num</th>
<th>order_date</th>
</tr>
</thead>
<tbody><tr>
<td>andy</td>
<td>aaaa</td>
<td>2021-01-01 00:00:00</td>
</tr>
<tr>
<td>andy</td>
<td>bbbb</td>
<td>2021-01-01 12:00:00</td>
</tr>
<tr>
<td>bob</td>
<td>cccc</td>
<td>2021-01-10 12:00:00</td>
</tr>
<tr>
<td>dick</td>
<td>dddd</td>
<td>2021-01-11 00:00:00</td>
</tr>
</tbody></table>
<p>编写 SQL 语句，从 <code>Orders</code> 表中检索顾客 ID（<code>cust_id</code>）和订单号（<code>order_num</code>），并先按顾客 ID 对结果进行排序，再按订单日期倒序排列。</p>
<p>答案：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 根据列名排序</span><br><span class="line"># 注意：是 order_date 降序，而不是 order_num</span><br><span class="line"><span class="keyword">SELECT</span> cust_id, order_num</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cust_id,order_date <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>

<p>知识点：<code>order by</code> 对多列排序的时候，先排序的列放前面，后排序的列放后面。并且，不同的列可以有不同的排序规则。</p>
<h3 id="按照数量和价格排序"><a href="#按照数量和价格排序" class="headerlink" title="按照数量和价格排序"></a>按照数量和价格排序</h3><p>假设有一个 <code>OrderItems</code> 表：</p>
<table>
<thead>
<tr>
<th>quantity</th>
<th>item_price</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>100</td>
</tr>
<tr>
<td>10</td>
<td>1003</td>
</tr>
<tr>
<td>2</td>
<td>500</td>
</tr>
</tbody></table>
<p>编写 SQL 语句，显示 <code>OrderItems</code> 表中的数量（<code>quantity</code>）和价格（<code>item_price</code>），并按数量由多到少、价格由高到低排序。</p>
<p>答案：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> quantity, item_price</span><br><span class="line"><span class="keyword">FROM</span> OrderItems</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> quantity <span class="keyword">DESC</span>,item_price <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>

<h3 id="检查-SQL-语句"><a href="#检查-SQL-语句" class="headerlink" title="检查 SQL 语句"></a>检查 SQL 语句</h3><p>有 <code>Vendors</code> 表：</p>
<table>
<thead>
<tr>
<th>vend_name</th>
</tr>
</thead>
<tbody><tr>
<td>海底捞</td>
</tr>
<tr>
<td>小龙坎</td>
</tr>
<tr>
<td>大龙燚</td>
</tr>
</tbody></table>
<p>下面的 SQL 语句有问题吗？尝试将它改正确，使之能够正确运行，并且返回结果根据<code>vend_name</code> 逆序排列。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_name,</span><br><span class="line"><span class="keyword">FROM</span> Vendors</span><br><span class="line"><span class="keyword">ORDER</span> vend_name <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>

<p>改正后：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_name</span><br><span class="line"><span class="keyword">FROM</span> Vendors</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>

<p>知识点：</p>
<ul>
<li>逗号作用是用来隔开列与列之间的。</li>
<li>ORDER BY 是有 BY 的，需要撰写完整，且位置正确。</li>
</ul>
<h2 id="过滤数据"><a href="#过滤数据" class="headerlink" title="过滤数据"></a>过滤数据</h2><p><code>WHERE</code> 可以过滤返回的数据。</p>
<p>下面的运算符可以在 <code>WHERE</code> 子句中使用：</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&#x3D;</td>
<td align="left">等于</td>
</tr>
<tr>
<td align="left">&lt;&gt;</td>
<td align="left">不等于。 <strong>注释：</strong> 在 SQL 的一些版本中，该操作符可被写成 !&#x3D;</td>
</tr>
<tr>
<td align="left">&gt;</td>
<td align="left">大于</td>
</tr>
<tr>
<td align="left">&lt;</td>
<td align="left">小于</td>
</tr>
<tr>
<td align="left">&gt;&#x3D;</td>
<td align="left">大于等于</td>
</tr>
<tr>
<td align="left">&lt;&#x3D;</td>
<td align="left">小于等于</td>
</tr>
<tr>
<td align="left">BETWEEN</td>
<td align="left">在某个范围内</td>
</tr>
<tr>
<td align="left">LIKE</td>
<td align="left">搜索某种模式</td>
</tr>
<tr>
<td align="left">IN</td>
<td align="left">指定针对某个列的多个可能值</td>
</tr>
</tbody></table>
<h3 id="返回固定价格的产品"><a href="#返回固定价格的产品" class="headerlink" title="返回固定价格的产品"></a>返回固定价格的产品</h3><p>有表 <code>Products</code>：</p>
<table>
<thead>
<tr>
<th>prod_id</th>
<th>prod_name</th>
<th>prod_price</th>
</tr>
</thead>
<tbody><tr>
<td>a0018</td>
<td>sockets</td>
<td>9.49</td>
</tr>
<tr>
<td>a0019</td>
<td>iphone13</td>
<td>600</td>
</tr>
<tr>
<td>b0018</td>
<td>gucci t-shirts</td>
<td>1000</td>
</tr>
</tbody></table>
<p>【问题】从 <code>Products</code> 表中检索产品 ID（<code>prod_id</code>）和产品名称（<code>prod_name</code>），只返回价格为 9.49 美元的产品。</p>
<p>答案：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, prod_name</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="operator">=</span> <span class="number">9.49</span></span><br></pre></td></tr></table></figure>

<h3 id="返回更高价格的产品"><a href="#返回更高价格的产品" class="headerlink" title="返回更高价格的产品"></a>返回更高价格的产品</h3><p>有表 <code>Products</code>：</p>
<table>
<thead>
<tr>
<th>prod_id</th>
<th>prod_name</th>
<th>prod_price</th>
</tr>
</thead>
<tbody><tr>
<td>a0018</td>
<td>sockets</td>
<td>9.49</td>
</tr>
<tr>
<td>a0019</td>
<td>iphone13</td>
<td>600</td>
</tr>
<tr>
<td>b0019</td>
<td>gucci t-shirts</td>
<td>1000</td>
</tr>
</tbody></table>
<p>【问题】编写 SQL 语句，从 <code>Products</code> 表中检索产品 ID（<code>prod_id</code>）和产品名称（<code>prod_name</code>），只返回价格为 9 美元或更高的产品。</p>
<p>答案：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, prod_name</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="operator">&gt;=</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>

<h3 id="返回产品并且按照价格排序"><a href="#返回产品并且按照价格排序" class="headerlink" title="返回产品并且按照价格排序"></a>返回产品并且按照价格排序</h3><p>有表 <code>Products</code>：</p>
<table>
<thead>
<tr>
<th>prod_id</th>
<th>prod_name</th>
<th>prod_price</th>
</tr>
</thead>
<tbody><tr>
<td>a0011</td>
<td>egg</td>
<td>3</td>
</tr>
<tr>
<td>a0019</td>
<td>sockets</td>
<td>4</td>
</tr>
<tr>
<td>b0019</td>
<td>coffee</td>
<td>15</td>
</tr>
</tbody></table>
<p>【问题】编写 SQL 语句，返回 <code>Products</code> 表中所有价格在 3 美元到 6 美元之间的产品的名称（<code>prod_name</code>）和价格（<code>prod_price</code>），然后按价格对结果进行排序。</p>
<p>答案：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="keyword">BETWEEN</span> <span class="number">3</span> <span class="keyword">AND</span> <span class="number">6</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_price</span><br><span class="line"></span><br><span class="line"># 或者</span><br><span class="line"><span class="keyword">SELECT</span> prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="operator">&gt;=</span> <span class="number">3</span> <span class="keyword">AND</span> prod_price <span class="operator">&lt;=</span> <span class="number">6</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_price</span><br></pre></td></tr></table></figure>

<h3 id="返回更多的产品"><a href="#返回更多的产品" class="headerlink" title="返回更多的产品"></a>返回更多的产品</h3><p><code>OrderItems</code> 表含有：订单号 <code>order_num</code>，<code>quantity</code>产品数量</p>
<table>
<thead>
<tr>
<th>order_num</th>
<th>quantity</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>105</td>
</tr>
<tr>
<td>a2</td>
<td>1100</td>
</tr>
<tr>
<td>a2</td>
<td>200</td>
</tr>
<tr>
<td>a4</td>
<td>1121</td>
</tr>
<tr>
<td>a5</td>
<td>10</td>
</tr>
<tr>
<td>a2</td>
<td>19</td>
</tr>
<tr>
<td>a7</td>
<td>5</td>
</tr>
</tbody></table>
<p>【问题】从 <code>OrderItems</code> 表中检索出所有不同且不重复的订单号（<code>order_num</code>），其中每个订单都要包含 100 个或更多的产品。</p>
<p>答案：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_num</span><br><span class="line"><span class="keyword">FROM</span> OrderItems</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> order_num</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">SUM</span>(quantity) <span class="operator">&gt;=</span> <span class="number">100</span></span><br></pre></td></tr></table></figure>

<h2 id="高级数据过滤"><a href="#高级数据过滤" class="headerlink" title="高级数据过滤"></a>高级数据过滤</h2><p><code>AND</code> 和 <code>OR</code> 运算符用于基于一个以上的条件对记录进行过滤，两者可以结合使用。<code>AND</code> 必须 2 个条件都成立，<code>OR</code>只要 2 个条件中的一个成立即可。</p>
<h3 id="检索供应商名称"><a href="#检索供应商名称" class="headerlink" title="检索供应商名称"></a>检索供应商名称</h3><p><code>Vendors</code> 表有字段供应商名称（<code>vend_name</code>）、供应商国家（<code>vend_country</code>）、供应商州（<code>vend_state</code>）</p>
<table>
<thead>
<tr>
<th>vend_name</th>
<th>vend_country</th>
<th>vend_state</th>
</tr>
</thead>
<tbody><tr>
<td>apple</td>
<td>USA</td>
<td>CA</td>
</tr>
<tr>
<td>vivo</td>
<td>CNA</td>
<td>shenzhen</td>
</tr>
<tr>
<td>huawei</td>
<td>CNA</td>
<td>xian</td>
</tr>
</tbody></table>
<p>【问题】编写 SQL 语句，从 <code>Vendors</code> 表中检索供应商名称（<code>vend_name</code>），仅返回加利福尼亚州的供应商（这需要按国家[USA]和州[CA]进行过滤，没准其他国家也存在一个 CA）</p>
<p>答案：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_name</span><br><span class="line"><span class="keyword">FROM</span> Vendors</span><br><span class="line"><span class="keyword">WHERE</span> vend_country <span class="operator">=</span> <span class="string">&#x27;USA&#x27;</span> <span class="keyword">AND</span> vend_state <span class="operator">=</span> <span class="string">&#x27;CA&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="检索并列出已订购产品的清单-1"><a href="#检索并列出已订购产品的清单-1" class="headerlink" title="检索并列出已订购产品的清单"></a>检索并列出已订购产品的清单</h3><p><code>OrderItems</code> 表包含了所有已订购的产品（有些已被订购多次）。</p>
<table>
<thead>
<tr>
<th>prod_id</th>
<th>order_num</th>
<th>quantity</th>
</tr>
</thead>
<tbody><tr>
<td>BR01</td>
<td>a1</td>
<td>105</td>
</tr>
<tr>
<td>BR02</td>
<td>a2</td>
<td>1100</td>
</tr>
<tr>
<td>BR02</td>
<td>a2</td>
<td>200</td>
</tr>
<tr>
<td>BR03</td>
<td>a4</td>
<td>1121</td>
</tr>
<tr>
<td>BR017</td>
<td>a5</td>
<td>10</td>
</tr>
<tr>
<td>BR02</td>
<td>a2</td>
<td>19</td>
</tr>
<tr>
<td>BR017</td>
<td>a7</td>
<td>5</td>
</tr>
</tbody></table>
<p>【问题】编写 SQL 语句，查找所有订购了数量至少 100 个的 <code>BR01</code>、<code>BR02</code> 或 <code>BR03</code> 的订单。你需要返回 <code>OrderItems</code> 表的订单号（<code>order_num</code>）、产品 ID（<code>prod_id</code>）和数量（<code>quantity</code>），并按产品 ID 和数量进行过滤。</p>
<p>答案：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_num, prod_id, quantity</span><br><span class="line"><span class="keyword">FROM</span> OrderItems</span><br><span class="line"><span class="keyword">WHERE</span> prod_id <span class="keyword">IN</span> (<span class="string">&#x27;BR01&#x27;</span>, <span class="string">&#x27;BR02&#x27;</span>, <span class="string">&#x27;BR03&#x27;</span>) <span class="keyword">AND</span> quantity <span class="operator">&gt;=</span> <span class="number">100</span></span><br></pre></td></tr></table></figure>

<h3 id="返回所有价格在-3-美元到-6-美元之间的产品的名称和价格"><a href="#返回所有价格在-3-美元到-6-美元之间的产品的名称和价格" class="headerlink" title="返回所有价格在 3 美元到 6 美元之间的产品的名称和价格"></a>返回所有价格在 3 美元到 6 美元之间的产品的名称和价格</h3><p>有表 <code>Products</code>：</p>
<table>
<thead>
<tr>
<th>prod_id</th>
<th>prod_name</th>
<th>prod_price</th>
</tr>
</thead>
<tbody><tr>
<td>a0011</td>
<td>egg</td>
<td>3</td>
</tr>
<tr>
<td>a0019</td>
<td>sockets</td>
<td>4</td>
</tr>
<tr>
<td>b0019</td>
<td>coffee</td>
<td>15</td>
</tr>
</tbody></table>
<p>【问题】编写 SQL 语句，返回所有价格在 3 美元到 6 美元之间的产品的名称（<code>prod_name</code>）和价格（<code>prod_price</code>），使用 AND 操作符，然后按价格对结果进行升序排序。</p>
<p>答案：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="operator">&gt;=</span> <span class="number">3</span> <span class="keyword">and</span> prod_price <span class="operator">&lt;=</span> <span class="number">6</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_price</span><br></pre></td></tr></table></figure>

<h3 id="检查-SQL-语句-1"><a href="#检查-SQL-语句-1" class="headerlink" title="检查 SQL 语句"></a>检查 SQL 语句</h3><p>供应商表 <code>Vendors</code> 有字段供应商名称 <code>vend_name</code>、供应商国家 <code>vend_country</code>、供应商省份 <code>vend_state</code></p>
<table>
<thead>
<tr>
<th>vend_name</th>
<th>vend_country</th>
<th>vend_state</th>
</tr>
</thead>
<tbody><tr>
<td>apple</td>
<td>USA</td>
<td>CA</td>
</tr>
<tr>
<td>vivo</td>
<td>CNA</td>
<td>shenzhen</td>
</tr>
<tr>
<td>huawei</td>
<td>CNA</td>
<td>xian</td>
</tr>
</tbody></table>
<p>【问题】修改正确下面 sql，使之正确返回。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_name</span><br><span class="line"><span class="keyword">FROM</span> Vendors</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name</span><br><span class="line"><span class="keyword">WHERE</span> vend_country <span class="operator">=</span> <span class="string">&#x27;USA&#x27;</span> <span class="keyword">AND</span> vend_state <span class="operator">=</span> <span class="string">&#x27;CA&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>修改后：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_name</span><br><span class="line"><span class="keyword">FROM</span> Vendors</span><br><span class="line"><span class="keyword">WHERE</span> vend_country <span class="operator">=</span> <span class="string">&#x27;USA&#x27;</span> <span class="keyword">AND</span> vend_state <span class="operator">=</span> <span class="string">&#x27;CA&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name</span><br></pre></td></tr></table></figure>

<p><code>ORDER BY</code> 语句必须放在 <code>WHERE</code> 之后。</p>
<h2 id="用通配符进行过滤"><a href="#用通配符进行过滤" class="headerlink" title="用通配符进行过滤"></a>用通配符进行过滤</h2><p>SQL 通配符必须与 <code>LIKE</code> 运算符一起使用</p>
<p>在 SQL 中，可使用以下通配符：</p>
<table>
<thead>
<tr>
<th align="left">通配符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>%</code></td>
<td align="left">代表零个或多个字符</td>
</tr>
<tr>
<td align="left"><code>_</code></td>
<td align="left">仅替代一个字符</td>
</tr>
<tr>
<td align="left"><code>[charlist]</code></td>
<td align="left">字符列中的任何单一字符</td>
</tr>
<tr>
<td align="left"><code>[^charlist]</code> 或者 <code>[!charlist]</code></td>
<td align="left">不在字符列中的任何单一字符</td>
</tr>
</tbody></table>
<h3 id="检索产品名称和描述（一）"><a href="#检索产品名称和描述（一）" class="headerlink" title="检索产品名称和描述（一）"></a>检索产品名称和描述（一）</h3><p><code>Products</code> 表如下：</p>
<table>
<thead>
<tr>
<th>prod_name</th>
<th>prod_desc</th>
</tr>
</thead>
<tbody><tr>
<td>a0011</td>
<td>usb</td>
</tr>
<tr>
<td>a0019</td>
<td>iphone13</td>
</tr>
<tr>
<td>b0019</td>
<td>gucci t-shirts</td>
</tr>
<tr>
<td>c0019</td>
<td>gucci toy</td>
</tr>
<tr>
<td>d0019</td>
<td>lego toy</td>
</tr>
</tbody></table>
<p>【问题】编写 SQL 语句，从 <code>Products</code> 表中检索产品名称（<code>prod_name</code>）和描述（<code>prod_desc</code>），仅返回描述中包含 <code>toy</code> 一词的产品名称。</p>
<p>答案：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name, prod_desc</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> prod_desc <span class="keyword">LIKE</span> <span class="string">&#x27;%toy%&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="检索产品名称和描述（二）"><a href="#检索产品名称和描述（二）" class="headerlink" title="检索产品名称和描述（二）"></a>检索产品名称和描述（二）</h3><p><code>Products</code> 表如下：</p>
<table>
<thead>
<tr>
<th>prod_name</th>
<th>prod_desc</th>
</tr>
</thead>
<tbody><tr>
<td>a0011</td>
<td>usb</td>
</tr>
<tr>
<td>a0019</td>
<td>iphone13</td>
</tr>
<tr>
<td>b0019</td>
<td>gucci t-shirts</td>
</tr>
<tr>
<td>c0019</td>
<td>gucci toy</td>
</tr>
<tr>
<td>d0019</td>
<td>lego toy</td>
</tr>
</tbody></table>
<p>【问题】编写 SQL 语句，从 <code>Products</code> 表中检索产品名称（<code>prod_name</code>）和描述（<code>prod_desc</code>），仅返回描述中未出现 <code>toy</code> 一词的产品，最后按”产品名称“对结果进行排序。</p>
<p>答案：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name, prod_desc</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> prod_desc <span class="keyword">NOT</span> <span class="keyword">LIKE</span> <span class="string">&#x27;%toy%&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name</span><br></pre></td></tr></table></figure>

<h3 id="检索产品名称和描述（三）"><a href="#检索产品名称和描述（三）" class="headerlink" title="检索产品名称和描述（三）"></a>检索产品名称和描述（三）</h3><p><code>Products</code> 表如下：</p>
<table>
<thead>
<tr>
<th>prod_name</th>
<th>prod_desc</th>
</tr>
</thead>
<tbody><tr>
<td>a0011</td>
<td>usb</td>
</tr>
<tr>
<td>a0019</td>
<td>iphone13</td>
</tr>
<tr>
<td>b0019</td>
<td>gucci t-shirts</td>
</tr>
<tr>
<td>c0019</td>
<td>gucci toy</td>
</tr>
<tr>
<td>d0019</td>
<td>lego carrots toy</td>
</tr>
</tbody></table>
<p>【问题】编写 SQL 语句，从 <code>Products</code> 表中检索产品名称（<code>prod_name</code>）和描述（<code>prod_desc</code>），仅返回描述中同时出现 <code>toy</code> 和 <code>carrots</code> 的产品。有好几种方法可以执行此操作，但对于这个挑战题，请使用 <code>AND</code> 和两个 <code>LIKE</code> 比较。</p>
<p>答案：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name, prod_desc</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> prod_desc <span class="keyword">LIKE</span> <span class="string">&#x27;%toy%&#x27;</span> <span class="keyword">AND</span> prod_desc <span class="keyword">LIKE</span> &quot;%carrots%&quot;</span><br></pre></td></tr></table></figure>

<h3 id="检索产品名称和描述（四）"><a href="#检索产品名称和描述（四）" class="headerlink" title="检索产品名称和描述（四）"></a>检索产品名称和描述（四）</h3><p><code>Products</code> 表如下：</p>
<table>
<thead>
<tr>
<th>prod_name</th>
<th>prod_desc</th>
</tr>
</thead>
<tbody><tr>
<td>a0011</td>
<td>usb</td>
</tr>
<tr>
<td>a0019</td>
<td>iphone13</td>
</tr>
<tr>
<td>b0019</td>
<td>gucci t-shirts</td>
</tr>
<tr>
<td>c0019</td>
<td>gucci toy</td>
</tr>
<tr>
<td>d0019</td>
<td>lego toy carrots</td>
</tr>
</tbody></table>
<p>【问题】编写 SQL 语句，从 Products 表中检索产品名称（prod_name）和描述（prod_desc），仅返回在描述中以<strong>先后顺序</strong>同时出现 toy 和 carrots 的产品。提示：只需要用带有三个 <code>%</code> 符号的 <code>LIKE</code> 即可。</p>
<p>答案：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name, prod_desc</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> prod_desc <span class="keyword">LIKE</span> <span class="string">&#x27;%toy%carrots%&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="创建计算字段"><a href="#创建计算字段" class="headerlink" title="创建计算字段"></a>创建计算字段</h2><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>别名的常见用法是在检索出的结果中重命名表的列字段（为了符合特定的报表要求或客户需求）。有表 <code>Vendors</code> 代表供应商信息，<code>vend_id</code> 供应商 id、<code>vend_name</code> 供应商名称、<code>vend_address</code> 供应商地址、<code>vend_city</code> 供应商城市。</p>
<table>
<thead>
<tr>
<th>vend_id</th>
<th>vend_name</th>
<th>vend_address</th>
<th>vend_city</th>
</tr>
</thead>
<tbody><tr>
<td>a001</td>
<td>tencent cloud</td>
<td>address1</td>
<td>shenzhen</td>
</tr>
<tr>
<td>a002</td>
<td>huawei cloud</td>
<td>address2</td>
<td>dongguan</td>
</tr>
<tr>
<td>a003</td>
<td>aliyun cloud</td>
<td>address3</td>
<td>hangzhou</td>
</tr>
<tr>
<td>a003</td>
<td>netease cloud</td>
<td>address4</td>
<td>guangzhou</td>
</tr>
</tbody></table>
<p>【问题】编写 SQL 语句，从 <code>Vendors</code> 表中检索 <code>vend_id</code>、<code>vend_name</code>、<code>vend_address</code> 和 <code>vend_city</code>，将 <code>vend_name</code> 重命名为 <code>vname</code>，将 <code>vend_city</code> 重命名为 <code>vcity</code>，将 <code>vend_address</code> 重命名为 <code>vaddress</code>，按供应商名称对结果进行升序排序。</p>
<p>答案：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id, vend_name <span class="keyword">AS</span> vname, vend_address <span class="keyword">AS</span> vaddress, vend_city <span class="keyword">AS</span> vcity</span><br><span class="line"><span class="keyword">FROM</span> Vendors</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vname</span><br><span class="line"># <span class="keyword">as</span> 可以省略</span><br><span class="line"><span class="keyword">SELECT</span> vend_id, vend_name vname, vend_address vaddress, vend_city vcity</span><br><span class="line"><span class="keyword">FROM</span> Vendors</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vname</span><br></pre></td></tr></table></figure>

<h3 id="打折"><a href="#打折" class="headerlink" title="打折"></a>打折</h3><p>我们的示例商店正在进行打折促销，所有产品均降价 10%。<code>Products</code> 表包含 <code>prod_id</code> 产品 id、<code>prod_price</code> 产品价格。</p>
<p>【问题】编写 SQL 语句，从 <code>Products</code> 表中返回 <code>prod_id</code>、<code>prod_price</code> 和 <code>sale_price</code>。<code>sale_price</code> 是一个包含促销价格的计算字段。提示：可以乘以 0.9，得到原价的 90%（即 10%的折扣）。</p>
<p>答案：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, prod_price, prod_price <span class="operator">*</span> <span class="number">0.9</span> <span class="keyword">AS</span> sale_price</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br></pre></td></tr></table></figure>

<p>注意：<code>sale_price</code> 是对计算结果的命名，而不是原有的列名。</p>
<h2 id="使用函数处理数据"><a href="#使用函数处理数据" class="headerlink" title="使用函数处理数据"></a>使用函数处理数据</h2><h3 id="顾客登录名"><a href="#顾客登录名" class="headerlink" title="顾客登录名"></a>顾客登录名</h3><p>我们的商店已经上线了，正在创建顾客账户。所有用户都需要登录名，默认登录名是其名称和所在城市的组合。</p>
<p>给出 <code>Customers</code> 表 如下：</p>
<table>
<thead>
<tr>
<th>cust_id</th>
<th>cust_name</th>
<th>cust_contact</th>
<th>cust_city</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>Andy Li</td>
<td>Andy Li</td>
<td>Oak Park</td>
</tr>
<tr>
<td>a2</td>
<td>Ben Liu</td>
<td>Ben Liu</td>
<td>Oak Park</td>
</tr>
<tr>
<td>a3</td>
<td>Tony Dai</td>
<td>Tony Dai</td>
<td>Oak Park</td>
</tr>
<tr>
<td>a4</td>
<td>Tom Chen</td>
<td>Tom Chen</td>
<td>Oak Park</td>
</tr>
<tr>
<td>a5</td>
<td>An Li</td>
<td>An Li</td>
<td>Oak Park</td>
</tr>
<tr>
<td>a6</td>
<td>Lee Chen</td>
<td>Lee Chen</td>
<td>Oak Park</td>
</tr>
<tr>
<td>a7</td>
<td>Hex Liu</td>
<td>Hex Liu</td>
<td>Oak Park</td>
</tr>
</tbody></table>
<p>【问题】编写 SQL 语句，返回顾客 ID（<code>cust_id</code>）、顾客名称（<code>cust_name</code>）和登录名（<code>user_login</code>），其中登录名全部为大写字母，并由顾客联系人的前两个字符（<code>cust_contact</code>）和其所在城市的前三个字符（<code>cust_city</code>）组成。提示：需要使用函数、拼接和别名。</p>
<p>答案：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_id, cust_name, <span class="built_in">UPPER</span>(CONCAT(<span class="built_in">SUBSTRING</span>(cust_contact, <span class="number">1</span>, <span class="number">2</span>), <span class="built_in">SUBSTRING</span>(cust_city, <span class="number">1</span>, <span class="number">3</span>))) <span class="keyword">AS</span> user_login</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br></pre></td></tr></table></figure>

<p>知识点：</p>
<ul>
<li><p>截取函数<code>SUBSTRING()</code>：截取字符串，<code>substring(str ,n ,m)</code>（n 表示起始截取位置，m 表示要截取的字符个数）表示返回字符串 str 从第 n 个字符开始截取 m 个字符；</p>
</li>
<li><p>拼接函数<code>CONCAT()</code>：将两个或多个字符串连接成一个字符串，select concat(A,B)：连接字符串 A 和 B。</p>
</li>
<li><p>大写函数 <code>UPPER()</code>：将指定字符串转换为大写。</p>
</li>
</ul>
<h3 id="返回-2020-年-1-月的所有订单的订单号和订单日期"><a href="#返回-2020-年-1-月的所有订单的订单号和订单日期" class="headerlink" title="返回 2020 年 1 月的所有订单的订单号和订单日期"></a>返回 2020 年 1 月的所有订单的订单号和订单日期</h3><p><code>Orders</code> 订单表如下：</p>
<table>
<thead>
<tr>
<th>order_num</th>
<th>order_date</th>
</tr>
</thead>
<tbody><tr>
<td>a0001</td>
<td>2020-01-01 00:00:00</td>
</tr>
<tr>
<td>a0002</td>
<td>2020-01-02 00:00:00</td>
</tr>
<tr>
<td>a0003</td>
<td>2020-01-01 12:00:00</td>
</tr>
<tr>
<td>a0004</td>
<td>2020-02-01 00:00:00</td>
</tr>
<tr>
<td>a0005</td>
<td>2020-03-01 00:00:00</td>
</tr>
</tbody></table>
<p>【问题】编写 SQL 语句，返回 2020 年 1 月的所有订单的订单号（<code>order_num</code>）和订单日期（<code>order_date</code>），并按订单日期升序排序</p>
<p>答案：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_num, order_date</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">month</span>(order_date) <span class="operator">=</span> <span class="string">&#x27;01&#x27;</span> <span class="keyword">AND</span> <span class="keyword">YEAR</span>(order_date) <span class="operator">=</span> <span class="string">&#x27;2020&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> order_date</span><br></pre></td></tr></table></figure>

<p>也可以用通配符来做：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_num, order_date</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> order_date <span class="keyword">LIKE</span> <span class="string">&#x27;2020-01%&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> order_date</span><br></pre></td></tr></table></figure>

<p>知识点：</p>
<ul>
<li>日期格式：<code>YYYY-MM-DD</code></li>
<li>时间格式：<code>HH:MM:SS</code></li>
</ul>
<p>日期和时间处理相关的常用函数：</p>
<table>
<thead>
<tr>
<th>函 数</th>
<th>说 明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ADDDATE()</code></td>
<td>增加一个日期（天、周等）</td>
</tr>
<tr>
<td><code>ADDTIME()</code></td>
<td>增加一个时间（时、分等）</td>
</tr>
<tr>
<td><code>CURDATE()</code></td>
<td>返回当前日期</td>
</tr>
<tr>
<td><code>CURTIME()</code></td>
<td>返回当前时间</td>
</tr>
<tr>
<td><code>DATE()</code></td>
<td>返回日期时间的日期部分</td>
</tr>
<tr>
<td><code>DATEDIFF</code></td>
<td>计算两个日期之差</td>
</tr>
<tr>
<td><code>DATE_FORMAT()</code></td>
<td>返回一个格式化的日期或时间串</td>
</tr>
<tr>
<td><code>DAY()</code></td>
<td>返回一个日期的天数部分</td>
</tr>
<tr>
<td><code>DAYOFWEEK()</code></td>
<td>对于一个日期，返回对应的星期几</td>
</tr>
<tr>
<td><code>HOUR()</code></td>
<td>返回一个时间的小时部分</td>
</tr>
<tr>
<td><code>MINUTE()</code></td>
<td>返回一个时间的分钟部分</td>
</tr>
<tr>
<td><code>MONTH()</code></td>
<td>返回一个日期的月份部分</td>
</tr>
<tr>
<td><code>NOW()</code></td>
<td>返回当前日期和时间</td>
</tr>
<tr>
<td><code>SECOND()</code></td>
<td>返回一个时间的秒部分</td>
</tr>
<tr>
<td><code>TIME()</code></td>
<td>返回一个日期时间的时间部分</td>
</tr>
<tr>
<td><code>YEAR()</code></td>
<td>返回一个日期的年份部分</td>
</tr>
</tbody></table>
<h2 id="汇总数据"><a href="#汇总数据" class="headerlink" title="汇总数据"></a>汇总数据</h2><p>汇总数据相关的函数：</p>
<table>
<thead>
<tr>
<th>函 数</th>
<th>说 明</th>
</tr>
</thead>
<tbody><tr>
<td><code>AVG()</code></td>
<td>返回某列的平均值</td>
</tr>
<tr>
<td><code>COUNT()</code></td>
<td>返回某列的行数</td>
</tr>
<tr>
<td><code>MAX()</code></td>
<td>返回某列的最大值</td>
</tr>
<tr>
<td><code>MIN()</code></td>
<td>返回某列的最小值</td>
</tr>
<tr>
<td><code>SUM()</code></td>
<td>返回某列值之和</td>
</tr>
</tbody></table>
<h3 id="确定已售出产品的总数"><a href="#确定已售出产品的总数" class="headerlink" title="确定已售出产品的总数"></a>确定已售出产品的总数</h3><p><code>OrderItems</code> 表代表售出的产品，<code>quantity</code> 代表售出商品数量。</p>
<table>
<thead>
<tr>
<th>quantity</th>
</tr>
</thead>
<tbody><tr>
<td>10</td>
</tr>
<tr>
<td>100</td>
</tr>
<tr>
<td>1000</td>
</tr>
<tr>
<td>10001</td>
</tr>
<tr>
<td>2</td>
</tr>
<tr>
<td>15</td>
</tr>
</tbody></table>
<p>【问题】编写 SQL 语句，确定已售出产品的总数。</p>
<p>答案：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">Sum</span>(quantity) <span class="keyword">AS</span> items_ordered</span><br><span class="line"><span class="keyword">FROM</span> OrderItems</span><br></pre></td></tr></table></figure>

<h3 id="确定已售出产品项-BR01-的总数"><a href="#确定已售出产品项-BR01-的总数" class="headerlink" title="确定已售出产品项 BR01 的总数"></a>确定已售出产品项 BR01 的总数</h3><p><code>OrderItems</code> 表代表售出的产品，<code>quantity</code> 代表售出商品数量，产品项为 <code>prod_id</code>。</p>
<table>
<thead>
<tr>
<th>quantity</th>
<th>prod_id</th>
</tr>
</thead>
<tbody><tr>
<td>10</td>
<td>AR01</td>
</tr>
<tr>
<td>100</td>
<td>AR10</td>
</tr>
<tr>
<td>1000</td>
<td>BR01</td>
</tr>
<tr>
<td>10001</td>
<td>BR010</td>
</tr>
</tbody></table>
<p>【问题】修改创建的语句，确定已售出产品项（<code>prod_id</code>）为”BR01”的总数。</p>
<p>答案：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">Sum</span>(quantity) <span class="keyword">AS</span> items_ordered</span><br><span class="line"><span class="keyword">FROM</span> OrderItems</span><br><span class="line"><span class="keyword">WHERE</span> prod_id <span class="operator">=</span> <span class="string">&#x27;BR01&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="确定-Products-表中价格不超过-10-美元的最贵产品的价格"><a href="#确定-Products-表中价格不超过-10-美元的最贵产品的价格" class="headerlink" title="确定 Products 表中价格不超过 10 美元的最贵产品的价格"></a>确定 Products 表中价格不超过 10 美元的最贵产品的价格</h3><p><code>Products</code> 表如下，<code>prod_price</code> 代表商品的价格。</p>
<table>
<thead>
<tr>
<th>prod_price</th>
</tr>
</thead>
<tbody><tr>
<td>9.49</td>
</tr>
<tr>
<td>600</td>
</tr>
<tr>
<td>1000</td>
</tr>
</tbody></table>
<p>【问题】编写 SQL 语句，确定 <code>Products</code> 表中价格不超过 10 美元的最贵产品的价格（<code>prod_price</code>）。将计算所得的字段命名为 <code>max_price</code>。</p>
<p>答案：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">Max</span>(prod_price) <span class="keyword">AS</span> max_price</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="operator">&lt;=</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>

<h2 id="分组数据"><a href="#分组数据" class="headerlink" title="分组数据"></a>分组数据</h2><p><code>GROUP BY</code>：</p>
<ul>
<li><code>GROUP BY</code> 子句将记录分组到汇总行中。</li>
<li><code>GROUP BY</code> 为每个组返回一个记录。</li>
<li><code>GROUP BY</code> 通常还涉及聚合<code>COUNT</code>，<code>MAX</code>，<code>SUM</code>，<code>AVG</code> 等。</li>
<li><code>GROUP BY</code> 可以按一列或多列进行分组。</li>
<li><code>GROUP BY</code> 按分组字段进行排序后，<code>ORDER BY</code> 可以以汇总字段来进行排序。</li>
</ul>
<p><code>HAVING</code>：</p>
<ul>
<li><code>HAVING</code> 用于对汇总的 <code>GROUP BY</code> 结果进行过滤。</li>
<li><code>HAVING</code> 必须要与 <code>GROUP BY</code> 连用。</li>
<li><code>WHERE</code> 和 <code>HAVING</code> 可以在相同的查询中。</li>
</ul>
<p><code>HAVING</code> vs <code>WHERE</code>：</p>
<ul>
<li><code>WHERE</code>：过滤指定的行，后面不能加聚合函数（分组函数）。</li>
<li><code>HAVING</code>：过滤分组，必须要与 <code>GROUP BY</code> 连用，不能单独使用。</li>
</ul>
<h3 id="返回每个订单号各有多少行数"><a href="#返回每个订单号各有多少行数" class="headerlink" title="返回每个订单号各有多少行数"></a>返回每个订单号各有多少行数</h3><p><code>OrderItems</code> 表包含每个订单的每个产品</p>
<table>
<thead>
<tr>
<th>order_num</th>
</tr>
</thead>
<tbody><tr>
<td>a002</td>
</tr>
<tr>
<td>a002</td>
</tr>
<tr>
<td>a002</td>
</tr>
<tr>
<td>a004</td>
</tr>
<tr>
<td>a007</td>
</tr>
</tbody></table>
<p>【问题】编写 SQL 语句，返回每个订单号（<code>order_num</code>）各有多少行数（<code>order_lines</code>），并按 <code>order_lines</code> 对结果进行升序排序。</p>
<p>答案：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_num, <span class="built_in">Count</span>(order_num) <span class="keyword">AS</span> order_lines</span><br><span class="line"><span class="keyword">FROM</span> OrderItems</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> order_num</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> order_lines</span><br></pre></td></tr></table></figure>

<p>知识点：</p>
<ol>
<li><code>count(*)</code>,<code>count(列名)</code>都可以，区别在于，<code>count(列名)</code>是统计非 NULL 的行数；</li>
<li><code>order by</code> 最后执行，所以可以使用列别名；</li>
<li>分组聚合一定不要忘记加上 <code>group by</code> ,不然只会有一行结果。</li>
</ol>
<h3 id="每个供应商成本最低的产品"><a href="#每个供应商成本最低的产品" class="headerlink" title="每个供应商成本最低的产品"></a>每个供应商成本最低的产品</h3><p>有 <code>Products</code> 表，含有字段 <code>prod_price</code> 代表产品价格，<code>vend_id</code> 代表供应商 id</p>
<table>
<thead>
<tr>
<th>vend_id</th>
<th>prod_price</th>
</tr>
</thead>
<tbody><tr>
<td>a0011</td>
<td>100</td>
</tr>
<tr>
<td>a0019</td>
<td>0.1</td>
</tr>
<tr>
<td>b0019</td>
<td>1000</td>
</tr>
<tr>
<td>b0019</td>
<td>6980</td>
</tr>
<tr>
<td>b0019</td>
<td>20</td>
</tr>
</tbody></table>
<p>【问题】编写 SQL 语句，返回名为 <code>cheapest_item</code> 的字段，该字段包含每个供应商成本最低的产品（使用 <code>Products</code> 表中的 <code>prod_price</code>），然后从最低成本到最高成本对结果进行升序排序。</p>
<p>答案：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id, <span class="built_in">Min</span>(prod_price) <span class="keyword">AS</span> cheapest_item</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> vend_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cheapest_item</span><br></pre></td></tr></table></figure>

<h3 id="返回订单数量总和不小于-100-的所有订单的订单号"><a href="#返回订单数量总和不小于-100-的所有订单的订单号" class="headerlink" title="返回订单数量总和不小于 100 的所有订单的订单号"></a>返回订单数量总和不小于 100 的所有订单的订单号</h3><p><code>OrderItems</code> 代表订单商品表，包括：订单号 <code>order_num</code> 和订单数量 <code>quantity</code>。</p>
<table>
<thead>
<tr>
<th>order_num</th>
<th>quantity</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>105</td>
</tr>
<tr>
<td>a2</td>
<td>1100</td>
</tr>
<tr>
<td>a2</td>
<td>200</td>
</tr>
<tr>
<td>a4</td>
<td>1121</td>
</tr>
<tr>
<td>a5</td>
<td>10</td>
</tr>
<tr>
<td>a2</td>
<td>19</td>
</tr>
<tr>
<td>a7</td>
<td>5</td>
</tr>
</tbody></table>
<p>【问题】请编写 SQL 语句，返回订单数量总和不小于 100 的所有订单号，最后结果按照订单号升序排序。</p>
<p>答案：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 直接聚合</span><br><span class="line"><span class="keyword">SELECT</span> order_num</span><br><span class="line"><span class="keyword">FROM</span> OrderItems</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> order_num</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">Sum</span>(quantity) <span class="operator">&gt;=</span> <span class="number">100</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> order_num</span><br><span class="line"></span><br><span class="line"># 子查询</span><br><span class="line"><span class="keyword">SELECT</span> a.order_num</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> order_num, <span class="built_in">Sum</span>(quantity) <span class="keyword">AS</span> sum_num</span><br><span class="line">    <span class="keyword">FROM</span> OrderItems</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> order_num</span><br><span class="line">    <span class="keyword">HAVING</span> sum_num <span class="operator">&gt;=</span> <span class="number">100</span>) a</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> a.order_num</span><br></pre></td></tr></table></figure>

<p>知识点：</p>
<ul>
<li><code>where</code>：过滤过滤指定的行，后面不能加聚合函数（分组函数）。</li>
<li><code>having</code>：过滤分组，与 <code>group by</code> 连用，不能单独使用。</li>
</ul>
<h3 id="计算总和"><a href="#计算总和" class="headerlink" title="计算总和"></a>计算总和</h3><p><code>OrderItems</code> 表代表订单信息，包括字段：订单号 <code>order_num</code> 和 <code>item_price</code> 商品售出价格、<code>quantity</code> 商品数量。</p>
<table>
<thead>
<tr>
<th>order_num</th>
<th>item_price</th>
<th>quantity</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>10</td>
<td>105</td>
</tr>
<tr>
<td>a2</td>
<td>1</td>
<td>1100</td>
</tr>
<tr>
<td>a2</td>
<td>1</td>
<td>200</td>
</tr>
<tr>
<td>a4</td>
<td>2</td>
<td>1121</td>
</tr>
<tr>
<td>a5</td>
<td>5</td>
<td>10</td>
</tr>
<tr>
<td>a2</td>
<td>1</td>
<td>19</td>
</tr>
<tr>
<td>a7</td>
<td>7</td>
<td>5</td>
</tr>
</tbody></table>
<p>【问题】编写 SQL 语句，根据订单号聚合，返回订单总价不小于 1000 的所有订单号，最后的结果按订单号进行升序排序。</p>
<p>提示：总价 &#x3D; item_price 乘以 quantity</p>
<p>答案：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_num, <span class="built_in">Sum</span>(item_price <span class="operator">*</span> quantity) <span class="keyword">AS</span> total_price</span><br><span class="line"><span class="keyword">FROM</span> OrderItems</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> order_num</span><br><span class="line"><span class="keyword">HAVING</span> total_price <span class="operator">&gt;=</span> <span class="number">1000</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> order_num</span><br></pre></td></tr></table></figure>

<h3 id="检查-SQL-语句-2"><a href="#检查-SQL-语句-2" class="headerlink" title="检查 SQL 语句"></a>检查 SQL 语句</h3><p><code>OrderItems</code> 表含有 <code>order_num</code> 订单号</p>
<table>
<thead>
<tr>
<th>order_num</th>
</tr>
</thead>
<tbody><tr>
<td>a002</td>
</tr>
<tr>
<td>a002</td>
</tr>
<tr>
<td>a002</td>
</tr>
<tr>
<td>a004</td>
</tr>
<tr>
<td>a007</td>
</tr>
</tbody></table>
<p>【问题】将下面代码修改正确后执行</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_num, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> items</span><br><span class="line"><span class="keyword">FROM</span> OrderItems</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> items</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> items, order_num;</span><br></pre></td></tr></table></figure>

<p>修改后：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_num, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> items</span><br><span class="line"><span class="keyword">FROM</span> OrderItems</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> order_num</span><br><span class="line"><span class="keyword">HAVING</span> items <span class="operator">&gt;=</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> items, order_num;</span><br></pre></td></tr></table></figure>

<h2 id="使用子查询"><a href="#使用子查询" class="headerlink" title="使用子查询"></a>使用子查询</h2><p>子查询是嵌套在较大查询中的 SQL 查询，也称内部查询或内部选择，包含子查询的语句也称为外部查询或外部选择。简单来说，子查询就是指将一个 <code>SELECT</code> 查询（子查询）的结果作为另一个 SQL 语句（主查询）的数据来源或者判断条件。</p>
<p>子查询可以嵌入 <code>SELECT</code>、<code>INSERT</code>、<code>UPDATE</code> 和 <code>DELETE</code> 语句中，也可以和 <code>=</code>、<code>&lt;</code>、<code>&gt;</code>、<code>IN</code>、<code>BETWEEN</code>、<code>EXISTS</code> 等运算符一起使用。</p>
<p>子查询常用在 <code>WHERE</code> 子句和 <code>FROM</code> 子句后边：</p>
<ul>
<li>当用于 <code>WHERE</code> 子句时，根据不同的运算符，子查询可以返回单行单列、多行单列、单行多列数据。子查询就是要返回能够作为 WHERE 子句查询条件的值。</li>
<li>当用于 <code>FROM</code> 子句时，一般返回多行多列数据，相当于返回一张临时表，这样才符合 <code>FROM</code> 后面是表的规则。这种做法能够实现多表联合查询。</li>
</ul>
<blockquote>
<p>注意：MySQL 数据库从 4.1 版本才开始支持子查询，早期版本是不支持的。</p>
</blockquote>
<p>用于 <code>WHERE</code> 子句的子查询的基本语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name [, column_name ]</span><br><span class="line"><span class="keyword">FROM</span> table1 [, table2 ]</span><br><span class="line"><span class="keyword">WHERE</span> column_name operator</span><br><span class="line">(<span class="keyword">SELECT</span> column_name [, column_name ]</span><br><span class="line"><span class="keyword">FROM</span> table1 [, table2 ]</span><br><span class="line">[<span class="keyword">WHERE</span>])</span><br></pre></td></tr></table></figure>

<ul>
<li>子查询需要放在括号<code>( )</code>内。</li>
<li><code>operator</code> 表示用于 <code>WHERE</code> 子句的运算符，可以是比较运算符（如 <code>=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;&gt;</code> 等）或逻辑运算符（如 <code>IN</code>, <code>NOT IN</code>, <code>EXISTS</code>, <code>NOT EXISTS</code> 等），具体根据需求来确定。</li>
</ul>
<p>用于 <code>FROM</code> 子句的子查询的基本语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name [, column_name ]</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> column_name [, column_name ]</span><br><span class="line">      <span class="keyword">FROM</span> table1 [, table2 ]</span><br><span class="line">      [<span class="keyword">WHERE</span>]) <span class="keyword">AS</span> temp_table_name [, ...]</span><br><span class="line">[<span class="keyword">JOIN</span> type <span class="keyword">JOIN</span> table_name <span class="keyword">ON</span> <span class="keyword">condition</span>]</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>用于 <code>FROM</code> 的子查询返回的结果相当于一张临时表，所以需要使用 AS 关键字为该临时表起一个名字。</li>
<li>子查询需要放在括号 <code>( )</code> 内。</li>
<li>可以指定多个临时表名，并使用 <code>JOIN</code> 语句连接这些表。</li>
</ul>
<h3 id="返回购买价格为-10-美元或以上产品的顾客列表"><a href="#返回购买价格为-10-美元或以上产品的顾客列表" class="headerlink" title="返回购买价格为 10 美元或以上产品的顾客列表"></a>返回购买价格为 10 美元或以上产品的顾客列表</h3><p><code>OrderItems</code> 表示订单商品表，含有字段订单号：<code>order_num</code>、订单价格：<code>item_price</code>；<code>Orders</code> 表代表订单信息表，含有顾客 <code>id：cust_id</code> 和订单号：<code>order_num</code></p>
<p><code>OrderItems</code> 表:</p>
<table>
<thead>
<tr>
<th>order_num</th>
<th>item_price</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>10</td>
</tr>
<tr>
<td>a2</td>
<td>1</td>
</tr>
<tr>
<td>a2</td>
<td>1</td>
</tr>
<tr>
<td>a4</td>
<td>2</td>
</tr>
<tr>
<td>a5</td>
<td>5</td>
</tr>
<tr>
<td>a2</td>
<td>1</td>
</tr>
<tr>
<td>a7</td>
<td>7</td>
</tr>
</tbody></table>
<p><code>Orders</code> 表：</p>
<table>
<thead>
<tr>
<th>order_num</th>
<th>cust_id</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>cust10</td>
</tr>
<tr>
<td>a2</td>
<td>cust1</td>
</tr>
<tr>
<td>a2</td>
<td>cust1</td>
</tr>
<tr>
<td>a4</td>
<td>cust2</td>
</tr>
<tr>
<td>a5</td>
<td>cust5</td>
</tr>
<tr>
<td>a2</td>
<td>cust1</td>
</tr>
<tr>
<td>a7</td>
<td>cust7</td>
</tr>
</tbody></table>
<p>【问题】使用子查询，返回购买价格为 10 美元或以上产品的顾客列表，结果无需排序。</p>
<p>答案：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_id</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> order_num <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> order_num</span><br><span class="line">    <span class="keyword">FROM</span> OrderItems</span><br><span class="line">    <span class="keyword">where</span> item_price <span class="operator">&gt;=</span> <span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<h3 id="确定哪些订单购买了-prod-id-为-BR01-的产品（一）"><a href="#确定哪些订单购买了-prod-id-为-BR01-的产品（一）" class="headerlink" title="确定哪些订单购买了 prod_id 为 BR01 的产品（一）"></a>确定哪些订单购买了 prod_id 为 BR01 的产品（一）</h3><p>表 <code>OrderItems</code> 代表订单商品信息表，<code>prod_id</code> 为产品 id；<code>Orders</code> 表代表订单表有 <code>cust_id</code> 代表顾客 id 和订单日期 <code>order_date</code></p>
<p><code>OrderItems</code> 表：</p>
<table>
<thead>
<tr>
<th>prod_id</th>
<th>order_num</th>
</tr>
</thead>
<tbody><tr>
<td>BR01</td>
<td>a0001</td>
</tr>
<tr>
<td>BR01</td>
<td>a0002</td>
</tr>
<tr>
<td>BR02</td>
<td>a0003</td>
</tr>
<tr>
<td>BR02</td>
<td>a0013</td>
</tr>
</tbody></table>
<p><code>Orders</code> 表：</p>
<table>
<thead>
<tr>
<th>order_num</th>
<th>cust_id</th>
<th>order_date</th>
</tr>
</thead>
<tbody><tr>
<td>a0001</td>
<td>cust10</td>
<td>2022-01-01 00:00:00</td>
</tr>
<tr>
<td>a0002</td>
<td>cust1</td>
<td>2022-01-01 00:01:00</td>
</tr>
<tr>
<td>a0003</td>
<td>cust1</td>
<td>2022-01-02 00:00:00</td>
</tr>
<tr>
<td>a0013</td>
<td>cust2</td>
<td>2022-01-01 00:20:00</td>
</tr>
</tbody></table>
<p>【问题】</p>
<p>编写 SQL 语句，使用子查询来确定哪些订单（在 <code>OrderItems</code> 中）购买了 <code>prod_id</code> 为 “BR01” 的产品，然后从 <code>Orders</code> 表中返回每个产品对应的顾客 ID（<code>cust_id</code>）和订单日期（<code>order_date</code>），按订购日期对结果进行升序排序。</p>
<p>答案：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 写法 <span class="number">1</span>：子查询</span><br><span class="line"><span class="keyword">SELECT</span> cust_id,order_date</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> order_num <span class="keyword">IN</span></span><br><span class="line">    (<span class="keyword">SELECT</span> order_num</span><br><span class="line">     <span class="keyword">FROM</span> OrderItems</span><br><span class="line">     <span class="keyword">WHERE</span> prod_id <span class="operator">=</span> <span class="string">&#x27;BR01&#x27;</span> )</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> order_date;</span><br><span class="line"></span><br><span class="line"># 写法 <span class="number">2</span>: 连接表</span><br><span class="line"><span class="keyword">SELECT</span> b.cust_id, b.order_date</span><br><span class="line"><span class="keyword">FROM</span> OrderItems a,Orders b</span><br><span class="line"><span class="keyword">WHERE</span> a.order_num <span class="operator">=</span> b.order_num <span class="keyword">AND</span> a.prod_id <span class="operator">=</span> <span class="string">&#x27;BR01&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> order_date</span><br></pre></td></tr></table></figure>

<h3 id="返回购买-prod-id-为-BR01-的产品的所有顾客的电子邮件（一）"><a href="#返回购买-prod-id-为-BR01-的产品的所有顾客的电子邮件（一）" class="headerlink" title="返回购买 prod_id 为 BR01 的产品的所有顾客的电子邮件（一）"></a>返回购买 prod_id 为 BR01 的产品的所有顾客的电子邮件（一）</h3><p>你想知道订购 BR01 产品的日期，有表 <code>OrderItems</code> 代表订单商品信息表，<code>prod_id</code> 为产品 id；<code>Orders</code> 表代表订单表有 <code>cust_id</code> 代表顾客 id 和订单日期 <code>order_date</code>；<code>Customers</code> 表含有 <code>cust_email</code> 顾客邮件和 <code>cust_id</code> 顾客 id</p>
<p><code>OrderItems</code> 表：</p>
<table>
<thead>
<tr>
<th>prod_id</th>
<th>order_num</th>
</tr>
</thead>
<tbody><tr>
<td>BR01</td>
<td>a0001</td>
</tr>
<tr>
<td>BR01</td>
<td>a0002</td>
</tr>
<tr>
<td>BR02</td>
<td>a0003</td>
</tr>
<tr>
<td>BR02</td>
<td>a0013</td>
</tr>
</tbody></table>
<p><code>Orders</code> 表：</p>
<table>
<thead>
<tr>
<th>order_num</th>
<th>cust_id</th>
<th>order_date</th>
</tr>
</thead>
<tbody><tr>
<td>a0001</td>
<td>cust10</td>
<td>2022-01-01 00:00:00</td>
</tr>
<tr>
<td>a0002</td>
<td>cust1</td>
<td>2022-01-01 00:01:00</td>
</tr>
<tr>
<td>a0003</td>
<td>cust1</td>
<td>2022-01-02 00:00:00</td>
</tr>
<tr>
<td>a0013</td>
<td>cust2</td>
<td>2022-01-01 00:20:00</td>
</tr>
</tbody></table>
<p><code>Customers</code> 表代表顾客信息，<code>cust_id</code> 为顾客 id，<code>cust_email</code> 为顾客 email</p>
<table>
<thead>
<tr>
<th>cust_id</th>
<th>cust_email</th>
</tr>
</thead>
<tbody><tr>
<td>cust10</td>
<td><a href="mailto:&#99;&#x75;&#x73;&#116;&#49;&#48;&#x40;&#x63;&#x75;&#x73;&#116;&#x2e;&#99;&#111;&#x6d;">&#99;&#x75;&#x73;&#116;&#49;&#48;&#x40;&#x63;&#x75;&#x73;&#116;&#x2e;&#99;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>cust1</td>
<td><a href="mailto:&#99;&#x75;&#115;&#x74;&#49;&#64;&#x63;&#117;&#x73;&#116;&#x2e;&#x63;&#x6f;&#109;">&#99;&#x75;&#115;&#x74;&#49;&#64;&#x63;&#117;&#x73;&#116;&#x2e;&#x63;&#x6f;&#109;</a></td>
</tr>
<tr>
<td>cust2</td>
<td><a href="mailto:&#99;&#x75;&#115;&#116;&#x32;&#x40;&#99;&#117;&#x73;&#116;&#46;&#x63;&#111;&#x6d;">&#99;&#x75;&#115;&#116;&#x32;&#x40;&#99;&#117;&#x73;&#116;&#46;&#x63;&#111;&#x6d;</a></td>
</tr>
</tbody></table>
<p>【问题】返回购买 <code>prod_id</code> 为 <code>BR01</code> 的产品的所有顾客的电子邮件（<code>Customers</code> 表中的 <code>cust_email</code>），结果无需排序。</p>
<p>提示：这涉及 <code>SELECT</code> 语句，最内层的从 <code>OrderItems</code> 表返回 <code>order_num</code>，中间的从 <code>Customers</code> 表返回 <code>cust_id</code>。</p>
<p>答案：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 写法 <span class="number">1</span>：子查询</span><br><span class="line"><span class="keyword">SELECT</span> cust_email</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> cust_id</span><br><span class="line">    <span class="keyword">FROM</span> Orders</span><br><span class="line">    <span class="keyword">WHERE</span> order_num <span class="keyword">IN</span> (<span class="keyword">SELECT</span> order_num</span><br><span class="line">        <span class="keyword">FROM</span> OrderItems</span><br><span class="line">        <span class="keyword">WHERE</span> prod_id <span class="operator">=</span> <span class="string">&#x27;BR01&#x27;</span>))</span><br><span class="line"></span><br><span class="line"># 写法 <span class="number">2</span>: 连接表（<span class="keyword">inner</span> <span class="keyword">join</span>）</span><br><span class="line"><span class="keyword">SELECT</span> c.cust_email</span><br><span class="line"><span class="keyword">FROM</span> OrderItems a,Orders b,Customers c</span><br><span class="line"><span class="keyword">WHERE</span> a.order_num <span class="operator">=</span> b.order_num <span class="keyword">AND</span> b.cust_id <span class="operator">=</span> c.cust_id <span class="keyword">AND</span> a.prod_id <span class="operator">=</span> <span class="string">&#x27;BR01&#x27;</span></span><br><span class="line"></span><br><span class="line"># 写法 <span class="number">3</span>：连接表（<span class="keyword">left</span> <span class="keyword">join</span>）</span><br><span class="line"><span class="keyword">SELECT</span> c.cust_email</span><br><span class="line"><span class="keyword">FROM</span> Orders a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span></span><br><span class="line">  OrderItems b <span class="keyword">ON</span> a.order_num <span class="operator">=</span> b.order_num <span class="keyword">LEFT</span> <span class="keyword">JOIN</span></span><br><span class="line">  Customers c <span class="keyword">ON</span> a.cust_id <span class="operator">=</span> c.cust_id</span><br><span class="line"><span class="keyword">WHERE</span> b.prod_id <span class="operator">=</span> <span class="string">&#x27;BR01&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="返回每个顾客不同订单的总金额"><a href="#返回每个顾客不同订单的总金额" class="headerlink" title="返回每个顾客不同订单的总金额"></a>返回每个顾客不同订单的总金额</h3><p>我们需要一个顾客 ID 列表，其中包含他们已订购的总金额。</p>
<p><code>OrderItems</code> 表代表订单信息，<code>OrderItems</code> 表有订单号：<code>order_num</code> 和商品售出价格：<code>item_price</code>、商品数量：<code>quantity</code>。</p>
<table>
<thead>
<tr>
<th>order_num</th>
<th>item_price</th>
<th>quantity</th>
</tr>
</thead>
<tbody><tr>
<td>a0001</td>
<td>10</td>
<td>105</td>
</tr>
<tr>
<td>a0002</td>
<td>1</td>
<td>1100</td>
</tr>
<tr>
<td>a0002</td>
<td>1</td>
<td>200</td>
</tr>
<tr>
<td>a0013</td>
<td>2</td>
<td>1121</td>
</tr>
<tr>
<td>a0003</td>
<td>5</td>
<td>10</td>
</tr>
<tr>
<td>a0003</td>
<td>1</td>
<td>19</td>
</tr>
<tr>
<td>a0003</td>
<td>7</td>
<td>5</td>
</tr>
</tbody></table>
<p><code>Orders</code> 表订单号：<code>order_num</code>、顾客 id：<code>cust_id</code></p>
<table>
<thead>
<tr>
<th>order_num</th>
<th>cust_id</th>
</tr>
</thead>
<tbody><tr>
<td>a0001</td>
<td>cust10</td>
</tr>
<tr>
<td>a0002</td>
<td>cust1</td>
</tr>
<tr>
<td>a0003</td>
<td>cust1</td>
</tr>
<tr>
<td>a0013</td>
<td>cust2</td>
</tr>
</tbody></table>
<p>【问题】</p>
<p>编写 SQL 语句，返回顾客 ID（<code>Orders</code> 表中的 <code>cust_id</code>），并使用子查询返回 <code>total_ordered</code> 以便返回每个顾客的订单总数，将结果按金额从大到小排序。</p>
<p>答案：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 写法 <span class="number">1</span>：子查询</span><br><span class="line"><span class="keyword">SELECT</span> o.cust_id, <span class="built_in">SUM</span>(tb.total_ordered) <span class="keyword">AS</span> `total_ordered`</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> order_num, <span class="built_in">SUM</span>(item_price <span class="operator">*</span> quantity) <span class="keyword">AS</span> total_ordered</span><br><span class="line">    <span class="keyword">FROM</span> OrderItems</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> order_num) <span class="keyword">AS</span> tb,</span><br><span class="line">  Orders o</span><br><span class="line"><span class="keyword">WHERE</span> tb.order_num <span class="operator">=</span> o.order_num</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> o.cust_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> total_ordered <span class="keyword">DESC</span>;</span><br><span class="line"></span><br><span class="line"># 写法 <span class="number">2</span>：连接表</span><br><span class="line"><span class="keyword">SELECT</span> b.cust_id, <span class="built_in">Sum</span>(a.quantity <span class="operator">*</span> a.item_price) <span class="keyword">AS</span> total_ordered</span><br><span class="line"><span class="keyword">FROM</span> OrderItems a,Orders b</span><br><span class="line"><span class="keyword">WHERE</span> a.order_num <span class="operator">=</span> b.order_num</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> cust_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> total_ordered <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>

<p>关于写法一详细介绍可以参考： <a href="https://github.com/Snailclimb/JavaGuide/issues/2402">issue#2402：写法 1 存在的错误以及修改方法</a>。</p>
<h3 id="从-Products-表中检索所有的产品名称以及对应的销售总数"><a href="#从-Products-表中检索所有的产品名称以及对应的销售总数" class="headerlink" title="从 Products 表中检索所有的产品名称以及对应的销售总数"></a>从 Products 表中检索所有的产品名称以及对应的销售总数</h3><p><code>Products</code> 表中检索所有的产品名称：<code>prod_name</code>、产品 id：<code>prod_id</code></p>
<table>
<thead>
<tr>
<th>prod_id</th>
<th>prod_name</th>
</tr>
</thead>
<tbody><tr>
<td>a0001</td>
<td>egg</td>
</tr>
<tr>
<td>a0002</td>
<td>sockets</td>
</tr>
<tr>
<td>a0013</td>
<td>coffee</td>
</tr>
<tr>
<td>a0003</td>
<td>cola</td>
</tr>
</tbody></table>
<p><code>OrderItems</code> 代表订单商品表，订单产品：<code>prod_id</code>、售出数量：<code>quantity</code></p>
<table>
<thead>
<tr>
<th>prod_id</th>
<th>quantity</th>
</tr>
</thead>
<tbody><tr>
<td>a0001</td>
<td>105</td>
</tr>
<tr>
<td>a0002</td>
<td>1100</td>
</tr>
<tr>
<td>a0002</td>
<td>200</td>
</tr>
<tr>
<td>a0013</td>
<td>1121</td>
</tr>
<tr>
<td>a0003</td>
<td>10</td>
</tr>
<tr>
<td>a0003</td>
<td>19</td>
</tr>
<tr>
<td>a0003</td>
<td>5</td>
</tr>
</tbody></table>
<p>【问题】</p>
<p>编写 SQL 语句，从 <code>Products</code> 表中检索所有的产品名称（<code>prod_name</code>），以及名为 <code>quant_sold</code> 的计算列，其中包含所售产品的总数（在 <code>OrderItems</code> 表上使用子查询和 <code>SUM(quantity)</code> 检索）。</p>
<p>答案：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 写法 <span class="number">1</span>：子查询</span><br><span class="line"><span class="keyword">SELECT</span> p.prod_name, tb.quant_sold</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> prod_id, <span class="built_in">Sum</span>(quantity) <span class="keyword">AS</span> quant_sold</span><br><span class="line">    <span class="keyword">FROM</span> OrderItems</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> prod_id) <span class="keyword">AS</span> tb,</span><br><span class="line">  Products p</span><br><span class="line"><span class="keyword">WHERE</span> tb.prod_id <span class="operator">=</span> p.prod_id</span><br><span class="line"></span><br><span class="line"># 写法 <span class="number">2</span>：连接表</span><br><span class="line"><span class="keyword">SELECT</span> p.prod_name, <span class="built_in">Sum</span>(o.quantity) <span class="keyword">AS</span> quant_sold</span><br><span class="line"><span class="keyword">FROM</span> Products p,</span><br><span class="line">  OrderItems o</span><br><span class="line"><span class="keyword">WHERE</span> p.prod_id <span class="operator">=</span> o.prod_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> p.prod_name（这里不能用 p.prod_id，会报错）</span><br></pre></td></tr></table></figure>

<h2 id="连接表"><a href="#连接表" class="headerlink" title="连接表"></a>连接表</h2><p>JOIN 是“连接”的意思，顾名思义，SQL JOIN 子句用于将两个或者多个表联合起来进行查询。</p>
<p>连接表时需要在每个表中选择一个字段，并对这些字段的值进行比较，值相同的两条记录将合并为一条。<strong>连接表的本质就是将不同表的记录合并起来，形成一张新表。当然，这张新表只是临时的，它仅存在于本次查询期间</strong>。</p>
<p>使用 <code>JOIN</code> 连接两个表的基本语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> table1.column1, table2.column2...</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">JOIN</span> table2</span><br><span class="line"><span class="keyword">ON</span> table1.common_column1 <span class="operator">=</span> table2.common_column2;</span><br></pre></td></tr></table></figure>

<p><code>table1.common_column1 = table2.common_column2</code> 是连接条件，只有满足此条件的记录才会合并为一行。您可以使用多个运算符来连接表，例如 &#x3D;、&gt;、&lt;、&lt;&gt;、&lt;&#x3D;、&gt;&#x3D;、!&#x3D;、<code>between</code>、<code>like</code> 或者 <code>not</code>，但是最常见的是使用 &#x3D;。</p>
<p>当两个表中有同名的字段时，为了帮助数据库引擎区分是哪个表的字段，在书写同名字段名时需要加上表名。当然，如果书写的字段名在两个表中是唯一的，也可以不使用以上格式，只写字段名即可。</p>
<p>另外，如果两张表的关联字段名相同，也可以使用 <code>USING</code>子句来代替 <code>ON</code>，举个例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># join....on</span><br><span class="line"><span class="keyword">SELECT</span> c.cust_name, o.order_num</span><br><span class="line"><span class="keyword">FROM</span> Customers c</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> Orders o</span><br><span class="line"><span class="keyword">ON</span> c.cust_id <span class="operator">=</span> o.cust_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> c.cust_name</span><br><span class="line"></span><br><span class="line"># 如果两张表的关联字段名相同，也可以使用<span class="keyword">USING</span>子句：JOIN....USING()</span><br><span class="line"><span class="keyword">SELECT</span> c.cust_name, o.order_num</span><br><span class="line"><span class="keyword">FROM</span> Customers c</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> Orders o</span><br><span class="line"><span class="keyword">USING</span>(cust_id)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> c.cust_name</span><br></pre></td></tr></table></figure>

<p><strong><code>ON</code> 和 <code>WHERE</code> 的区别</strong>：</p>
<ul>
<li>连接表时，SQL 会根据连接条件生成一张新的临时表。<code>ON</code> 就是连接条件，它决定临时表的生成。</li>
<li><code>WHERE</code> 是在临时表生成以后，再对临时表中的数据进行过滤，生成最终的结果集，这个时候已经没有 JOIN-ON 了。</li>
</ul>
<p>所以总结来说就是：<strong>SQL 先根据 ON 生成一张临时表，然后再根据 WHERE 对临时表进行筛选</strong>。</p>
<p>SQL 允许在 <code>JOIN</code> 左边加上一些修饰性的关键词，从而形成不同类型的连接，如下表所示：</p>
<table>
<thead>
<tr>
<th>连接类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>INNER JOIN 内连接</td>
<td>（默认连接方式）只有当两个表都存在满足条件的记录时才会返回行。</td>
</tr>
<tr>
<td>LEFT JOIN &#x2F; LEFT OUTER JOIN 左(外)连接</td>
<td>返回左表中的所有行，即使右表中没有满足条件的行也是如此。</td>
</tr>
<tr>
<td>RIGHT JOIN &#x2F; RIGHT OUTER JOIN 右(外)连接</td>
<td>返回右表中的所有行，即使左表中没有满足条件的行也是如此。</td>
</tr>
<tr>
<td>FULL JOIN &#x2F; FULL OUTER JOIN 全(外)连接</td>
<td>只要其中有一个表存在满足条件的记录，就返回行。</td>
</tr>
<tr>
<td>SELF JOIN</td>
<td>将一个表连接到自身，就像该表是两个表一样。为了区分两个表，在 SQL 语句中需要至少重命名一个表。</td>
</tr>
<tr>
<td>CROSS JOIN</td>
<td>交叉连接，从两个或者多个连接表中返回记录集的笛卡尔积。</td>
</tr>
</tbody></table>
<p>下图展示了 LEFT JOIN、RIGHT JOIN、INNER JOIN、OUTER JOIN 相关的 7 种用法。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/csdn/d1794312b448516831369f869814ab39.png"></p>
<p>如果不加任何修饰词，只写 <code>JOIN</code>，那么默认为 <code>INNER JOIN</code></p>
<p>对于 <code>INNER JOIN</code> 来说，还有一种隐式的写法，称为 “<strong>隐式内连接</strong>”，也就是没有 <code>INNER JOIN</code> 关键字，使用 <code>WHERE</code> 语句实现内连接的功能</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 隐式内连接</span><br><span class="line"><span class="keyword">SELECT</span> c.cust_name, o.order_num</span><br><span class="line"><span class="keyword">FROM</span> Customers c,Orders o</span><br><span class="line"><span class="keyword">WHERE</span> c.cust_id <span class="operator">=</span> o.cust_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> c.cust_name</span><br><span class="line"></span><br><span class="line"># 显式内连接</span><br><span class="line"><span class="keyword">SELECT</span> c.cust_name, o.order_num</span><br><span class="line"><span class="keyword">FROM</span> Customers c</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> Orders o</span><br><span class="line"><span class="keyword">USING</span>(cust_id)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> c.cust_name;</span><br></pre></td></tr></table></figure>

<h3 id="返回顾客名称和相关订单号"><a href="#返回顾客名称和相关订单号" class="headerlink" title="返回顾客名称和相关订单号"></a>返回顾客名称和相关订单号</h3><p><code>Customers</code> 表有字段顾客名称 <code>cust_name</code>、顾客 id <code>cust_id</code></p>
<table>
<thead>
<tr>
<th>cust_id</th>
<th>cust_name</th>
</tr>
</thead>
<tbody><tr>
<td>cust10</td>
<td>andy</td>
</tr>
<tr>
<td>cust1</td>
<td>ben</td>
</tr>
<tr>
<td>cust2</td>
<td>tony</td>
</tr>
<tr>
<td>cust22</td>
<td>tom</td>
</tr>
<tr>
<td>cust221</td>
<td>an</td>
</tr>
<tr>
<td>cust2217</td>
<td>hex</td>
</tr>
</tbody></table>
<p><code>Orders</code> 订单信息表，含有字段 <code>order_num</code> 订单号、<code>cust_id</code> 顾客 id</p>
<table>
<thead>
<tr>
<th>order_num</th>
<th>cust_id</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>cust10</td>
</tr>
<tr>
<td>a2</td>
<td>cust1</td>
</tr>
<tr>
<td>a3</td>
<td>cust2</td>
</tr>
<tr>
<td>a4</td>
<td>cust22</td>
</tr>
<tr>
<td>a5</td>
<td>cust221</td>
</tr>
<tr>
<td>a7</td>
<td>cust2217</td>
</tr>
</tbody></table>
<p>【问题】编写 SQL 语句，返回 <code>Customers</code> 表中的顾客名称（<code>cust_name</code>）和 <code>Orders</code> 表中的相关订单号（<code>order_num</code>），并按顾客名称再按订单号对结果进行升序排序。你可以尝试用两个不同的写法，一个使用简单的等连接语法，另外一个使用 INNER JOIN。</p>
<p>答案：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 隐式内连接</span><br><span class="line"><span class="keyword">SELECT</span> c.cust_name, o.order_num</span><br><span class="line"><span class="keyword">FROM</span> Customers c,Orders o</span><br><span class="line"><span class="keyword">WHERE</span> c.cust_id <span class="operator">=</span> o.cust_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> c.cust_name,o.order_num</span><br><span class="line"></span><br><span class="line"># 显式内连接</span><br><span class="line"><span class="keyword">SELECT</span> c.cust_name, o.order_num</span><br><span class="line"><span class="keyword">FROM</span> Customers c</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> Orders o</span><br><span class="line"><span class="keyword">USING</span>(cust_id)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> c.cust_name,o.order_num;</span><br></pre></td></tr></table></figure>

<h3 id="返回顾客名称和相关订单号以及每个订单的总价"><a href="#返回顾客名称和相关订单号以及每个订单的总价" class="headerlink" title="返回顾客名称和相关订单号以及每个订单的总价"></a>返回顾客名称和相关订单号以及每个订单的总价</h3><p><code>Customers</code> 表有字段，顾客名称：<code>cust_name</code>、顾客 id：<code>cust_id</code></p>
<table>
<thead>
<tr>
<th>cust_id</th>
<th>cust_name</th>
</tr>
</thead>
<tbody><tr>
<td>cust10</td>
<td>andy</td>
</tr>
<tr>
<td>cust1</td>
<td>ben</td>
</tr>
<tr>
<td>cust2</td>
<td>tony</td>
</tr>
<tr>
<td>cust22</td>
<td>tom</td>
</tr>
<tr>
<td>cust221</td>
<td>an</td>
</tr>
<tr>
<td>cust2217</td>
<td>hex</td>
</tr>
</tbody></table>
<p><code>Orders</code> 订单信息表，含有字段，订单号：<code>order_num</code>、顾客 id：<code>cust_id</code></p>
<table>
<thead>
<tr>
<th>order_num</th>
<th>cust_id</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>cust10</td>
</tr>
<tr>
<td>a2</td>
<td>cust1</td>
</tr>
<tr>
<td>a3</td>
<td>cust2</td>
</tr>
<tr>
<td>a4</td>
<td>cust22</td>
</tr>
<tr>
<td>a5</td>
<td>cust221</td>
</tr>
<tr>
<td>a7</td>
<td>cust2217</td>
</tr>
</tbody></table>
<p><code>OrderItems</code> 表有字段，商品订单号：<code>order_num</code>、商品数量：<code>quantity</code>、商品价格：<code>item_price</code></p>
<table>
<thead>
<tr>
<th>order_num</th>
<th>quantity</th>
<th>item_price</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>1000</td>
<td>10</td>
</tr>
<tr>
<td>a2</td>
<td>200</td>
<td>10</td>
</tr>
<tr>
<td>a3</td>
<td>10</td>
<td>15</td>
</tr>
<tr>
<td>a4</td>
<td>25</td>
<td>50</td>
</tr>
<tr>
<td>a5</td>
<td>15</td>
<td>25</td>
</tr>
<tr>
<td>a7</td>
<td>7</td>
<td>7</td>
</tr>
</tbody></table>
<p>【问题】除了返回顾客名称和订单号，返回 <code>Customers</code> 表中的顾客名称（<code>cust_name</code>）和 <code>Orders</code> 表中的相关订单号（<code>order_num</code>），添加第三列 <code>OrderTotal</code>，其中包含每个订单的总价，并按顾客名称再按订单号对结果进行升序排序。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 简单的等连接语法</span><br><span class="line"><span class="keyword">SELECT</span> c.cust_name, o.order_num, <span class="built_in">SUM</span>(quantity <span class="operator">*</span> item_price) <span class="keyword">AS</span> OrderTotal</span><br><span class="line"><span class="keyword">FROM</span> Customers c,Orders o,OrderItems oi</span><br><span class="line"><span class="keyword">WHERE</span> c.cust_id <span class="operator">=</span> o.cust_id <span class="keyword">AND</span> o.order_num <span class="operator">=</span> oi.order_num</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> c.cust_name, o.order_num</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> c.cust_name, o.order_num</span><br></pre></td></tr></table></figure>

<p>注意，可能有小伙伴会这样写：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c.cust_name, o.order_num, <span class="built_in">SUM</span>(quantity <span class="operator">*</span> item_price) <span class="keyword">AS</span> OrderTotal</span><br><span class="line"><span class="keyword">FROM</span> Customers c,Orders o,OrderItems oi</span><br><span class="line"><span class="keyword">WHERE</span> c.cust_id <span class="operator">=</span> o.cust_id <span class="keyword">AND</span> o.order_num <span class="operator">=</span> oi.order_num</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> c.cust_name</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> c.cust_name,o.order_num</span><br></pre></td></tr></table></figure>

<p>这是错误的！只对 <code>cust_name</code> 进行聚类确实符合题意，但是不符合 <code>GROUP BY</code> 的语法。</p>
<p>select 语句中，如果没有 <code>GROUP BY</code> 语句，那么 <code>cust_name</code>、<code>order_num</code> 会返回若干个值，而 <code>sum(quantity * item_price)</code> 只返回一个值，通过 <code>group by</code> <code>cust_name</code> 可以让 <code>cust_name</code> 和 <code>sum(quantity * item_price)</code> 一一对应起来，或者说<strong>聚类</strong>，所以同样的，也要对 <code>order_num</code> 进行聚类。</p>
<blockquote>
<p><strong>一句话，select 中的字段要么都聚类，要么都不聚类</strong></p>
</blockquote>
<h3 id="确定哪些订单购买了-prod-id-为-BR01-的产品（二）"><a href="#确定哪些订单购买了-prod-id-为-BR01-的产品（二）" class="headerlink" title="确定哪些订单购买了 prod_id 为 BR01 的产品（二）"></a>确定哪些订单购买了 prod_id 为 BR01 的产品（二）</h3><p>表 <code>OrderItems</code> 代表订单商品信息表，<code>prod_id</code> 为产品 id；<code>Orders</code> 表代表订单表有 <code>cust_id</code> 代表顾客 id 和订单日期 <code>order_date</code></p>
<p><code>OrderItems</code> 表：</p>
<table>
<thead>
<tr>
<th>prod_id</th>
<th>order_num</th>
</tr>
</thead>
<tbody><tr>
<td>BR01</td>
<td>a0001</td>
</tr>
<tr>
<td>BR01</td>
<td>a0002</td>
</tr>
<tr>
<td>BR02</td>
<td>a0003</td>
</tr>
<tr>
<td>BR02</td>
<td>a0013</td>
</tr>
</tbody></table>
<p><code>Orders</code> 表：</p>
<table>
<thead>
<tr>
<th>order_num</th>
<th>cust_id</th>
<th>order_date</th>
</tr>
</thead>
<tbody><tr>
<td>a0001</td>
<td>cust10</td>
<td>2022-01-01 00:00:00</td>
</tr>
<tr>
<td>a0002</td>
<td>cust1</td>
<td>2022-01-01 00:01:00</td>
</tr>
<tr>
<td>a0003</td>
<td>cust1</td>
<td>2022-01-02 00:00:00</td>
</tr>
<tr>
<td>a0013</td>
<td>cust2</td>
<td>2022-01-01 00:20:00</td>
</tr>
</tbody></table>
<p>【问题】</p>
<p>编写 SQL 语句，使用子查询来确定哪些订单（在 <code>OrderItems</code> 中）购买了 <code>prod_id</code> 为 “BR01” 的产品，然后从 <code>Orders</code> 表中返回每个产品对应的顾客 ID（<code>cust_id</code>）和订单日期（<code>order_date</code>），按订购日期对结果进行升序排序。</p>
<p>提示：这一次使用连接和简单的等连接语法。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 写法 <span class="number">1</span>：子查询</span><br><span class="line"><span class="keyword">SELECT</span> cust_id, order_date</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> order_num <span class="keyword">IN</span> (<span class="keyword">SELECT</span> order_num</span><br><span class="line">    <span class="keyword">FROM</span> OrderItems</span><br><span class="line">    <span class="keyword">WHERE</span> prod_id <span class="operator">=</span> <span class="string">&#x27;BR01&#x27;</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> order_date</span><br><span class="line"></span><br><span class="line"># 写法 <span class="number">2</span>：连接表 <span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_id, order_date</span><br><span class="line"><span class="keyword">FROM</span> Orders o <span class="keyword">INNER</span> <span class="keyword">JOIN</span></span><br><span class="line">  (<span class="keyword">SELECT</span> order_num</span><br><span class="line">    <span class="keyword">FROM</span> OrderItems</span><br><span class="line">    <span class="keyword">WHERE</span> prod_id <span class="operator">=</span> <span class="string">&#x27;BR01&#x27;</span>) tb <span class="keyword">ON</span> o.order_num <span class="operator">=</span> tb.order_num</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> order_date</span><br><span class="line"></span><br><span class="line"># 写法 <span class="number">3</span>：写法 <span class="number">2</span> 的简化版</span><br><span class="line"><span class="keyword">SELECT</span> cust_id, order_date</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> OrderItems <span class="keyword">USING</span>(order_num)</span><br><span class="line"><span class="keyword">WHERE</span> OrderItems.prod_id <span class="operator">=</span> <span class="string">&#x27;BR01&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> order_date</span><br></pre></td></tr></table></figure>

<h3 id="返回购买-prod-id-为-BR01-的产品的所有顾客的电子邮件（二）"><a href="#返回购买-prod-id-为-BR01-的产品的所有顾客的电子邮件（二）" class="headerlink" title="返回购买 prod_id 为 BR01 的产品的所有顾客的电子邮件（二）"></a>返回购买 prod_id 为 BR01 的产品的所有顾客的电子邮件（二）</h3><p>有表 <code>OrderItems</code> 代表订单商品信息表，<code>prod_id</code> 为产品 id；<code>Orders</code> 表代表订单表有 <code>cust_id</code> 代表顾客 id 和订单日期 <code>order_date</code>；<code>Customers</code> 表含有 <code>cust_email</code> 顾客邮件和 cust_id 顾客 id</p>
<p><code>OrderItems</code> 表：</p>
<table>
<thead>
<tr>
<th>prod_id</th>
<th>order_num</th>
</tr>
</thead>
<tbody><tr>
<td>BR01</td>
<td>a0001</td>
</tr>
<tr>
<td>BR01</td>
<td>a0002</td>
</tr>
<tr>
<td>BR02</td>
<td>a0003</td>
</tr>
<tr>
<td>BR02</td>
<td>a0013</td>
</tr>
</tbody></table>
<p><code>Orders</code> 表：</p>
<table>
<thead>
<tr>
<th>order_num</th>
<th>cust_id</th>
<th>order_date</th>
</tr>
</thead>
<tbody><tr>
<td>a0001</td>
<td>cust10</td>
<td>2022-01-01 00:00:00</td>
</tr>
<tr>
<td>a0002</td>
<td>cust1</td>
<td>2022-01-01 00:01:00</td>
</tr>
<tr>
<td>a0003</td>
<td>cust1</td>
<td>2022-01-02 00:00:00</td>
</tr>
<tr>
<td>a0013</td>
<td>cust2</td>
<td>2022-01-01 00:20:00</td>
</tr>
</tbody></table>
<p><code>Customers</code> 表代表顾客信息，<code>cust_id</code> 为顾客 id，<code>cust_email</code> 为顾客 email</p>
<table>
<thead>
<tr>
<th>cust_id</th>
<th>cust_email</th>
</tr>
</thead>
<tbody><tr>
<td>cust10</td>
<td><a href="mailto:&#x63;&#x75;&#115;&#x74;&#49;&#x30;&#x40;&#x63;&#117;&#x73;&#x74;&#46;&#99;&#111;&#109;">&#x63;&#x75;&#115;&#x74;&#49;&#x30;&#x40;&#x63;&#117;&#x73;&#x74;&#46;&#99;&#111;&#109;</a></td>
</tr>
<tr>
<td>cust1</td>
<td><a href="mailto:&#x63;&#117;&#115;&#116;&#x31;&#x40;&#99;&#x75;&#115;&#x74;&#46;&#99;&#x6f;&#x6d;">&#x63;&#117;&#115;&#116;&#x31;&#x40;&#99;&#x75;&#115;&#x74;&#46;&#99;&#x6f;&#x6d;</a></td>
</tr>
<tr>
<td>cust2</td>
<td><a href="mailto:&#x63;&#117;&#x73;&#116;&#x32;&#x40;&#x63;&#117;&#x73;&#x74;&#x2e;&#x63;&#x6f;&#109;">&#x63;&#117;&#x73;&#116;&#x32;&#x40;&#x63;&#117;&#x73;&#x74;&#x2e;&#x63;&#x6f;&#109;</a></td>
</tr>
</tbody></table>
<p>【问题】返回购买 <code>prod_id</code> 为 BR01 的产品的所有顾客的电子邮件（<code>Customers</code> 表中的 <code>cust_email</code>），结果无需排序。</p>
<p>提示：涉及到 <code>SELECT</code> 语句，最内层的从 <code>OrderItems</code> 表返回 <code>order_num</code>，中间的从 <code>Customers</code> 表返回 <code>cust_id</code>，但是必须使用 INNER JOIN 语法。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_email</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> Orders <span class="keyword">using</span>(cust_id)</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> OrderItems <span class="keyword">using</span>(order_num)</span><br><span class="line"><span class="keyword">WHERE</span> OrderItems.prod_id <span class="operator">=</span> <span class="string">&#x27;BR01&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="确定最佳顾客的另一种方式（二）"><a href="#确定最佳顾客的另一种方式（二）" class="headerlink" title="确定最佳顾客的另一种方式（二）"></a>确定最佳顾客的另一种方式（二）</h3><p><code>OrderItems</code> 表代表订单信息，确定最佳顾客的另一种方式是看他们花了多少钱，<code>OrderItems</code> 表有订单号 <code>order_num</code> 和 <code>item_price</code> 商品售出价格、<code>quantity</code> 商品数量</p>
<table>
<thead>
<tr>
<th>order_num</th>
<th>item_price</th>
<th>quantity</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>10</td>
<td>105</td>
</tr>
<tr>
<td>a2</td>
<td>1</td>
<td>1100</td>
</tr>
<tr>
<td>a2</td>
<td>1</td>
<td>200</td>
</tr>
<tr>
<td>a4</td>
<td>2</td>
<td>1121</td>
</tr>
<tr>
<td>a5</td>
<td>5</td>
<td>10</td>
</tr>
<tr>
<td>a2</td>
<td>1</td>
<td>19</td>
</tr>
<tr>
<td>a7</td>
<td>7</td>
<td>5</td>
</tr>
</tbody></table>
<p><code>Orders</code> 表含有字段 <code>order_num</code> 订单号、<code>cust_id</code> 顾客 id</p>
<table>
<thead>
<tr>
<th>order_num</th>
<th>cust_id</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>cust10</td>
</tr>
<tr>
<td>a2</td>
<td>cust1</td>
</tr>
<tr>
<td>a3</td>
<td>cust2</td>
</tr>
<tr>
<td>a4</td>
<td>cust22</td>
</tr>
<tr>
<td>a5</td>
<td>cust221</td>
</tr>
<tr>
<td>a7</td>
<td>cust2217</td>
</tr>
</tbody></table>
<p>顾客表 <code>Customers</code> 有字段 <code>cust_id</code> 客户 id、<code>cust_name</code> 客户姓名</p>
<table>
<thead>
<tr>
<th>cust_id</th>
<th>cust_name</th>
</tr>
</thead>
<tbody><tr>
<td>cust10</td>
<td>andy</td>
</tr>
<tr>
<td>cust1</td>
<td>ben</td>
</tr>
<tr>
<td>cust2</td>
<td>tony</td>
</tr>
<tr>
<td>cust22</td>
<td>tom</td>
</tr>
<tr>
<td>cust221</td>
<td>an</td>
</tr>
<tr>
<td>cust2217</td>
<td>hex</td>
</tr>
</tbody></table>
<p>【问题】编写 SQL 语句，返回订单总价不小于 1000 的客户名称和总额（<code>OrderItems</code> 表中的 <code>order_num</code>）。</p>
<p>提示：需要计算总和（<code>item_price</code> 乘以 <code>quantity</code>）。按总额对结果进行排序，请使用 <code>INNER JOIN</code>语法。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, <span class="built_in">SUM</span>(item_price <span class="operator">*</span> quantity) <span class="keyword">AS</span> total_price</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> Orders <span class="keyword">USING</span>(cust_id)</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> OrderItems <span class="keyword">USING</span>(order_num)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> cust_name</span><br><span class="line"><span class="keyword">HAVING</span> total_price <span class="operator">&gt;=</span> <span class="number">1000</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> total_price</span><br></pre></td></tr></table></figure>

<h2 id="创建高级连接"><a href="#创建高级连接" class="headerlink" title="创建高级连接"></a>创建高级连接</h2><h3 id="检索每个顾客的名称和所有的订单号（一）"><a href="#检索每个顾客的名称和所有的订单号（一）" class="headerlink" title="检索每个顾客的名称和所有的订单号（一）"></a>检索每个顾客的名称和所有的订单号（一）</h3><p><code>Customers</code> 表代表顾客信息含有顾客 id <code>cust_id</code> 和 顾客名称 <code>cust_name</code></p>
<table>
<thead>
<tr>
<th>cust_id</th>
<th>cust_name</th>
</tr>
</thead>
<tbody><tr>
<td>cust10</td>
<td>andy</td>
</tr>
<tr>
<td>cust1</td>
<td>ben</td>
</tr>
<tr>
<td>cust2</td>
<td>tony</td>
</tr>
<tr>
<td>cust22</td>
<td>tom</td>
</tr>
<tr>
<td>cust221</td>
<td>an</td>
</tr>
<tr>
<td>cust2217</td>
<td>hex</td>
</tr>
</tbody></table>
<p><code>Orders</code> 表代表订单信息含有订单号 <code>order_num</code> 和顾客 id <code>cust_id</code></p>
<table>
<thead>
<tr>
<th>order_num</th>
<th>cust_id</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>cust10</td>
</tr>
<tr>
<td>a2</td>
<td>cust1</td>
</tr>
<tr>
<td>a3</td>
<td>cust2</td>
</tr>
<tr>
<td>a4</td>
<td>cust22</td>
</tr>
<tr>
<td>a5</td>
<td>cust221</td>
</tr>
<tr>
<td>a7</td>
<td>cust2217</td>
</tr>
</tbody></table>
<p>【问题】使用 INNER JOIN 编写 SQL 语句，检索每个顾客的名称（<code>Customers</code> 表中的 <code>cust_name</code>）和所有的订单号（<code>Orders</code> 表中的 <code>order_num</code>），最后根据顾客姓名 <code>cust_name</code> 升序返回。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, order_num</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> Orders</span><br><span class="line"><span class="keyword">USING</span>(cust_id)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cust_name</span><br></pre></td></tr></table></figure>

<h3 id="检索每个顾客的名称和所有的订单号（二）"><a href="#检索每个顾客的名称和所有的订单号（二）" class="headerlink" title="检索每个顾客的名称和所有的订单号（二）"></a>检索每个顾客的名称和所有的订单号（二）</h3><p><code>Orders</code> 表代表订单信息含有订单号 <code>order_num</code> 和顾客 id <code>cust_id</code></p>
<table>
<thead>
<tr>
<th>order_num</th>
<th>cust_id</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>cust10</td>
</tr>
<tr>
<td>a2</td>
<td>cust1</td>
</tr>
<tr>
<td>a3</td>
<td>cust2</td>
</tr>
<tr>
<td>a4</td>
<td>cust22</td>
</tr>
<tr>
<td>a5</td>
<td>cust221</td>
</tr>
<tr>
<td>a7</td>
<td>cust2217</td>
</tr>
</tbody></table>
<p><code>Customers</code> 表代表顾客信息含有顾客 id <code>cust_id</code> 和 顾客名称 <code>cust_name</code></p>
<table>
<thead>
<tr>
<th>cust_id</th>
<th>cust_name</th>
</tr>
</thead>
<tbody><tr>
<td>cust10</td>
<td>andy</td>
</tr>
<tr>
<td>cust1</td>
<td>ben</td>
</tr>
<tr>
<td>cust2</td>
<td>tony</td>
</tr>
<tr>
<td>cust22</td>
<td>tom</td>
</tr>
<tr>
<td>cust221</td>
<td>an</td>
</tr>
<tr>
<td>cust2217</td>
<td>hex</td>
</tr>
<tr>
<td>cust40</td>
<td>ace</td>
</tr>
</tbody></table>
<p>【问题】检索每个顾客的名称（<code>Customers</code> 表中的 <code>cust_name</code>）和所有的订单号（Orders 表中的 <code>order_num</code>），列出所有的顾客，即使他们没有下过订单。最后根据顾客姓名 <code>cust_name</code> 升序返回。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, order_num</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> Orders</span><br><span class="line"><span class="keyword">USING</span>(cust_id)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cust_name</span><br></pre></td></tr></table></figure>

<h3 id="返回产品名称和与之相关的订单号"><a href="#返回产品名称和与之相关的订单号" class="headerlink" title="返回产品名称和与之相关的订单号"></a>返回产品名称和与之相关的订单号</h3><p><code>Products</code> 表为产品信息表含有字段 <code>prod_id</code> 产品 id、<code>prod_name</code> 产品名称</p>
<table>
<thead>
<tr>
<th>prod_id</th>
<th>prod_name</th>
</tr>
</thead>
<tbody><tr>
<td>a0001</td>
<td>egg</td>
</tr>
<tr>
<td>a0002</td>
<td>sockets</td>
</tr>
<tr>
<td>a0013</td>
<td>coffee</td>
</tr>
<tr>
<td>a0003</td>
<td>cola</td>
</tr>
<tr>
<td>a0023</td>
<td>soda</td>
</tr>
</tbody></table>
<p><code>OrderItems</code> 表为订单信息表含有字段 <code>order_num</code> 订单号和产品 id <code>prod_id</code></p>
<table>
<thead>
<tr>
<th>prod_id</th>
<th>order_num</th>
</tr>
</thead>
<tbody><tr>
<td>a0001</td>
<td>a105</td>
</tr>
<tr>
<td>a0002</td>
<td>a1100</td>
</tr>
<tr>
<td>a0002</td>
<td>a200</td>
</tr>
<tr>
<td>a0013</td>
<td>a1121</td>
</tr>
<tr>
<td>a0003</td>
<td>a10</td>
</tr>
<tr>
<td>a0003</td>
<td>a19</td>
</tr>
<tr>
<td>a0003</td>
<td>a5</td>
</tr>
</tbody></table>
<p>【问题】使用外连接（left join、 right join、full join）联结 <code>Products</code> 表和 <code>OrderItems</code> 表，返回产品名称（<code>prod_name</code>）和与之相关的订单号（<code>order_num</code>）的列表，并按照产品名称升序排序。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name, order_num</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> OrderItems</span><br><span class="line"><span class="keyword">USING</span>(prod_id)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name</span><br></pre></td></tr></table></figure>

<h3 id="返回产品名称和每一项产品的总订单数"><a href="#返回产品名称和每一项产品的总订单数" class="headerlink" title="返回产品名称和每一项产品的总订单数"></a>返回产品名称和每一项产品的总订单数</h3><p><code>Products</code> 表为产品信息表含有字段 <code>prod_id</code> 产品 id、<code>prod_name</code> 产品名称</p>
<table>
<thead>
<tr>
<th>prod_id</th>
<th>prod_name</th>
</tr>
</thead>
<tbody><tr>
<td>a0001</td>
<td>egg</td>
</tr>
<tr>
<td>a0002</td>
<td>sockets</td>
</tr>
<tr>
<td>a0013</td>
<td>coffee</td>
</tr>
<tr>
<td>a0003</td>
<td>cola</td>
</tr>
<tr>
<td>a0023</td>
<td>soda</td>
</tr>
</tbody></table>
<p><code>OrderItems</code> 表为订单信息表含有字段 <code>order_num</code> 订单号和产品 id <code>prod_id</code></p>
<table>
<thead>
<tr>
<th>prod_id</th>
<th>order_num</th>
</tr>
</thead>
<tbody><tr>
<td>a0001</td>
<td>a105</td>
</tr>
<tr>
<td>a0002</td>
<td>a1100</td>
</tr>
<tr>
<td>a0002</td>
<td>a200</td>
</tr>
<tr>
<td>a0013</td>
<td>a1121</td>
</tr>
<tr>
<td>a0003</td>
<td>a10</td>
</tr>
<tr>
<td>a0003</td>
<td>a19</td>
</tr>
<tr>
<td>a0003</td>
<td>a5</td>
</tr>
</tbody></table>
<p>【问题】</p>
<p>使用 OUTER JOIN 联结 <code>Products</code> 表和 <code>OrderItems</code> 表，返回产品名称（<code>prod_name</code>）和每一项产品的总订单数（不是订单号），并按产品名称升序排序。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name, <span class="built_in">COUNT</span>(order_num) <span class="keyword">AS</span> orders</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> OrderItems</span><br><span class="line"><span class="keyword">USING</span>(prod_id)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> prod_name</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name</span><br></pre></td></tr></table></figure>

<h3 id="列出供应商及其可供产品的数量"><a href="#列出供应商及其可供产品的数量" class="headerlink" title="列出供应商及其可供产品的数量"></a>列出供应商及其可供产品的数量</h3><p>有 <code>Vendors</code> 表含有 <code>vend_id</code> （供应商 id）</p>
<table>
<thead>
<tr>
<th>vend_id</th>
</tr>
</thead>
<tbody><tr>
<td>a0002</td>
</tr>
<tr>
<td>a0013</td>
</tr>
<tr>
<td>a0003</td>
</tr>
<tr>
<td>a0010</td>
</tr>
</tbody></table>
<p>有 <code>Products</code> 表含有 <code>vend_id</code>（供应商 id）和 prod_id（供应产品 id）</p>
<table>
<thead>
<tr>
<th>vend_id</th>
<th>prod_id</th>
</tr>
</thead>
<tbody><tr>
<td>a0001</td>
<td>egg</td>
</tr>
<tr>
<td>a0002</td>
<td>prod_id_iphone</td>
</tr>
<tr>
<td>a00113</td>
<td>prod_id_tea</td>
</tr>
<tr>
<td>a0003</td>
<td>prod_id_vivo phone</td>
</tr>
<tr>
<td>a0010</td>
<td>prod_id_huawei phone</td>
</tr>
</tbody></table>
<p>【问题】列出供应商（<code>Vendors</code> 表中的 <code>vend_id</code>）及其可供产品的数量，包括没有产品的供应商。你需要使用 OUTER JOIN 和 COUNT()聚合函数来计算 <code>Products</code> 表中每种产品的数量，最后根据 vend_id 升序排序。</p>
<p>注意：<code>vend_id</code> 列会显示在多个表中，因此在每次引用它时都需要完全限定它。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> v.vend_id, <span class="built_in">COUNT</span>(prod_id) <span class="keyword">AS</span> prod_id</span><br><span class="line"><span class="keyword">FROM</span> Vendors v</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> Products p</span><br><span class="line"><span class="keyword">USING</span>(vend_id)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> v.vend_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> v.vend_id</span><br></pre></td></tr></table></figure>

<h2 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h2><p><code>UNION</code> 运算符将两个或更多查询的结果组合起来，并生成一个结果集，其中包含来自 <code>UNION</code> 中参与查询的提取行。</p>
<p><code>UNION</code> 基本规则：</p>
<ul>
<li>所有查询的列数和列顺序必须相同。</li>
<li>每个查询中涉及表的列的数据类型必须相同或兼容。</li>
<li>通常返回的列名取自第一个查询。</li>
</ul>
<p>默认地，<code>UNION</code> 操作符选取不同的值。如果允许重复的值，请使用 <code>UNION ALL</code>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> table2;</span><br></pre></td></tr></table></figure>

<p><code>UNION</code> 结果集中的列名总是等于 <code>UNION</code> 中第一个 <code>SELECT</code> 语句中的列名。</p>
<p><code>JOIN</code> vs <code>UNION</code>：</p>
<ul>
<li><code>JOIN</code> 中连接表的列可能不同，但在 <code>UNION</code> 中，所有查询的列数和列顺序必须相同。</li>
<li><code>UNION</code> 将查询之后的行放在一起（垂直放置），但 <code>JOIN</code> 将查询之后的列放在一起（水平放置），即它构成一个笛卡尔积。</li>
</ul>
<h3 id="将两个-SELECT-语句结合起来（一）"><a href="#将两个-SELECT-语句结合起来（一）" class="headerlink" title="将两个 SELECT 语句结合起来（一）"></a>将两个 SELECT 语句结合起来（一）</h3><p>表 <code>OrderItems</code> 包含订单产品信息，字段 <code>prod_id</code> 代表产品 id、<code>quantity</code> 代表产品数量</p>
<table>
<thead>
<tr>
<th>prod_id</th>
<th>quantity</th>
</tr>
</thead>
<tbody><tr>
<td>a0001</td>
<td>105</td>
</tr>
<tr>
<td>a0002</td>
<td>100</td>
</tr>
<tr>
<td>a0002</td>
<td>200</td>
</tr>
<tr>
<td>a0013</td>
<td>1121</td>
</tr>
<tr>
<td>a0003</td>
<td>10</td>
</tr>
<tr>
<td>a0003</td>
<td>19</td>
</tr>
<tr>
<td>a0003</td>
<td>5</td>
</tr>
<tr>
<td>BNBG</td>
<td>10002</td>
</tr>
</tbody></table>
<p>【问题】将两个 <code>SELECT</code> 语句结合起来，以便从 <code>OrderItems</code> 表中检索产品 id（<code>prod_id</code>）和 <code>quantity</code>。其中，一个 <code>SELECT</code> 语句过滤数量为 100 的行，另一个 <code>SELECT</code> 语句过滤 id 以 BNBG 开头的产品，最后按产品 id 对结果进行升序排序。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, quantity</span><br><span class="line"><span class="keyword">FROM</span> OrderItems</span><br><span class="line"><span class="keyword">WHERE</span> quantity <span class="operator">=</span> <span class="number">100</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> prod_id, quantity</span><br><span class="line"><span class="keyword">FROM</span> OrderItems</span><br><span class="line"><span class="keyword">WHERE</span> prod_id <span class="keyword">LIKE</span> <span class="string">&#x27;BNBG%&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="将两个-SELECT-语句结合起来（二）"><a href="#将两个-SELECT-语句结合起来（二）" class="headerlink" title="将两个 SELECT 语句结合起来（二）"></a>将两个 SELECT 语句结合起来（二）</h3><p>表 <code>OrderItems</code> 包含订单产品信息，字段 <code>prod_id</code> 代表产品 id、<code>quantity</code> 代表产品数量。</p>
<table>
<thead>
<tr>
<th>prod_id</th>
<th>quantity</th>
</tr>
</thead>
<tbody><tr>
<td>a0001</td>
<td>105</td>
</tr>
<tr>
<td>a0002</td>
<td>100</td>
</tr>
<tr>
<td>a0002</td>
<td>200</td>
</tr>
<tr>
<td>a0013</td>
<td>1121</td>
</tr>
<tr>
<td>a0003</td>
<td>10</td>
</tr>
<tr>
<td>a0003</td>
<td>19</td>
</tr>
<tr>
<td>a0003</td>
<td>5</td>
</tr>
<tr>
<td>BNBG</td>
<td>10002</td>
</tr>
</tbody></table>
<p>【问题】将两个 <code>SELECT</code> 语句结合起来，以便从 <code>OrderItems</code> 表中检索产品 id（<code>prod_id</code>）和 <code>quantity</code>。其中，一个 <code>SELECT</code> 语句过滤数量为 100 的行，另一个 <code>SELECT</code> 语句过滤 id 以 BNBG 开头的产品，最后按产品 id 对结果进行升序排序。 注意：<strong>这次仅使用单个 SELECT 语句。</strong></p>
<p>答案：</p>
<p>要求只用一条 select 语句，那就用 <code>or</code> 不用 <code>union</code> 了。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, quantity</span><br><span class="line"><span class="keyword">FROM</span> OrderItems</span><br><span class="line"><span class="keyword">WHERE</span> quantity <span class="operator">=</span> <span class="number">100</span> <span class="keyword">OR</span> prod_id <span class="keyword">LIKE</span> <span class="string">&#x27;BNBG%&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="组合-Products-表中的产品名称和-Customers-表中的顾客名称"><a href="#组合-Products-表中的产品名称和-Customers-表中的顾客名称" class="headerlink" title="组合 Products 表中的产品名称和 Customers 表中的顾客名称"></a>组合 Products 表中的产品名称和 Customers 表中的顾客名称</h3><p><code>Products</code> 表含有字段 <code>prod_name</code> 代表产品名称</p>
<table>
<thead>
<tr>
<th>prod_name</th>
</tr>
</thead>
<tbody><tr>
<td>flower</td>
</tr>
<tr>
<td>rice</td>
</tr>
<tr>
<td>ring</td>
</tr>
<tr>
<td>umbrella</td>
</tr>
</tbody></table>
<p>Customers 表代表顾客信息，cust_name 代表顾客名称</p>
<table>
<thead>
<tr>
<th>cust_name</th>
</tr>
</thead>
<tbody><tr>
<td>andy</td>
</tr>
<tr>
<td>ben</td>
</tr>
<tr>
<td>tony</td>
</tr>
<tr>
<td>tom</td>
</tr>
<tr>
<td>an</td>
</tr>
<tr>
<td>lee</td>
</tr>
<tr>
<td>hex</td>
</tr>
</tbody></table>
<p>【问题】编写 SQL 语句，组合 <code>Products</code> 表中的产品名称（<code>prod_name</code>）和 <code>Customers</code> 表中的顾客名称（<code>cust_name</code>）并返回，然后按产品名称对结果进行升序排序。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">UNION</span> 结果集中的列名总是等于 <span class="keyword">UNION</span> 中第一个 <span class="keyword">SELECT</span> 语句中的列名。</span><br><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_name</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name</span><br></pre></td></tr></table></figure>

<h3 id="检查-SQL-语句-3"><a href="#检查-SQL-语句-3" class="headerlink" title="检查 SQL 语句"></a>检查 SQL 语句</h3><p>表 <code>Customers</code> 含有字段 <code>cust_name</code> 顾客名、<code>cust_contact</code> 顾客联系方式、<code>cust_state</code> 顾客州、<code>cust_email</code> 顾客 <code>email</code></p>
<table>
<thead>
<tr>
<th>cust_name</th>
<th>cust_contact</th>
<th>cust_state</th>
<th>cust_email</th>
</tr>
</thead>
<tbody><tr>
<td>cust10</td>
<td>8695192</td>
<td>MI</td>
<td><a href="mailto:&#x63;&#117;&#x73;&#116;&#49;&#48;&#64;&#x63;&#x75;&#115;&#x74;&#46;&#x63;&#111;&#x6d;">&#x63;&#117;&#x73;&#116;&#49;&#48;&#64;&#x63;&#x75;&#115;&#x74;&#46;&#x63;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>cust1</td>
<td>8695193</td>
<td>MI</td>
<td><a href="mailto:&#99;&#x75;&#x73;&#x74;&#x31;&#x40;&#99;&#117;&#x73;&#x74;&#x2e;&#x63;&#111;&#x6d;">&#99;&#x75;&#x73;&#x74;&#x31;&#x40;&#99;&#117;&#x73;&#x74;&#x2e;&#x63;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>cust2</td>
<td>8695194</td>
<td>IL</td>
<td><a href="mailto:&#99;&#117;&#x73;&#116;&#x32;&#x40;&#99;&#117;&#x73;&#116;&#x2e;&#x63;&#x6f;&#x6d;">&#99;&#117;&#x73;&#116;&#x32;&#x40;&#99;&#117;&#x73;&#116;&#x2e;&#x63;&#x6f;&#x6d;</a></td>
</tr>
</tbody></table>
<p>【问题】修正下面错误的 SQL</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact, cust_email</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_state <span class="operator">=</span> <span class="string">&#x27;MI&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cust_name;</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact, cust_email</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_state <span class="operator">=</span> <span class="string">&#x27;IL&#x27;</span><span class="keyword">ORDER</span> <span class="keyword">BY</span> cust_name;</span><br></pre></td></tr></table></figure>

<p>修正后：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact, cust_email</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_state <span class="operator">=</span> <span class="string">&#x27;MI&#x27;</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact, cust_email</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_state <span class="operator">=</span> <span class="string">&#x27;IL&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cust_name;</span><br></pre></td></tr></table></figure>

<p>使用 <code>union</code> 组合查询时，只能使用一条 <code>order by</code> 字句，他必须位于最后一条 <code>select</code> 语句之后</p>
<p>或者直接用 <code>or</code> 来做：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact, cust_email</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_state <span class="operator">=</span> <span class="string">&#x27;MI&#x27;</span> <span class="keyword">or</span> cust_state <span class="operator">=</span> <span class="string">&#x27;IL&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cust_name;</span><br></pre></td></tr></table></figure>

<!-- @include: @article-footer.snippet.md -->

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2024/10/23/classical-algorithm-problems-recommendations/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/10/23/classical-algorithm-problems-recommendations/" itemprop="url">经典算法思想总结（含LeetCode题目推荐）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-10-23T20:13:39+08:00">
                2024-10-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2024/10/23/classical-algorithm-problems-recommendations/" class="leancloud_visitors" data-flag-title="经典算法思想总结（含LeetCode题目推荐）">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  814 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  3 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>贪心的本质是选择每一阶段的局部最优，从而达到全局最优。</p>
<h3 id="一般解题步骤"><a href="#一般解题步骤" class="headerlink" title="一般解题步骤"></a>一般解题步骤</h3><ul>
<li>将问题分解为若干个子问题</li>
<li>找出适合的贪心策略</li>
<li>求解每一个子问题的最优解</li>
<li>将局部最优解堆叠成全局最优解</li>
</ul>
<h3 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h3><p>455.分发饼干：<a href="https://leetcode.cn/problems/assign-cookies/">https://leetcode.cn/problems/assign-cookies/</a></p>
<p>121.买卖股票的最佳时机：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/</a></p>
<p>122.买卖股票的最佳时机 II：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/</a></p>
<p>55.跳跃游戏：<a href="https://leetcode.cn/problems/jump-game/">https://leetcode.cn/problems/jump-game/</a></p>
<p>45.跳跃游戏 II：<a href="https://leetcode.cn/problems/jump-game-ii/">https://leetcode.cn/problems/jump-game-ii/</a></p>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>动态规划中每一个状态一定是由上一个状态推导出来的，这一点就区分于贪心，贪心没有状态推导，而是从局部直接选最优的。</p>
<p>经典题目：01 背包、完全背包</p>
<h3 id="一般解题步骤-1"><a href="#一般解题步骤-1" class="headerlink" title="一般解题步骤"></a>一般解题步骤</h3><ul>
<li>确定 dp 数组（dp table）以及下标的含义</li>
<li>确定递推公式</li>
<li>dp 数组如何初始化</li>
<li>确定遍历顺序</li>
<li>举例推导 dp 数组</li>
</ul>
<h3 id="LeetCode-1"><a href="#LeetCode-1" class="headerlink" title="LeetCode"></a>LeetCode</h3><p>509.斐波那契数：<a href="https://leetcode.cn/problems/fibonacci-number/">https://leetcode.cn/problems/fibonacci-number/</a></p>
<p>746.使用最小花费爬楼梯：<a href="https://leetcode.cn/problems/min-cost-climbing-stairs/">https://leetcode.cn/problems/min-cost-climbing-stairs/</a></p>
<p>416.分割等和子集：<a href="https://leetcode.cn/problems/partition-equal-subset-sum/">https://leetcode.cn/problems/partition-equal-subset-sum/</a></p>
<p>518.零钱兑换：<a href="https://leetcode.cn/problems/coin-change-ii/">https://leetcode.cn/problems/coin-change-ii/</a></p>
<p>647.回文子串：<a href="https://leetcode.cn/problems/palindromic-substrings/">https://leetcode.cn/problems/palindromic-substrings/</a></p>
<p>516.最长回文子序列：<a href="https://leetcode.cn/problems/longest-palindromic-subsequence/">https://leetcode.cn/problems/longest-palindromic-subsequence/</a></p>
<h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><h3 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h3><p>回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条</p>
<p>件时，就“回溯”返回，尝试别的路径。其本质就是穷举。</p>
<p>经典题目：8 皇后</p>
<h3 id="一般解题步骤-2"><a href="#一般解题步骤-2" class="headerlink" title="一般解题步骤"></a>一般解题步骤</h3><ul>
<li>针对所给问题，定义问题的解空间，它至少包含问题的一个（最优）解。</li>
<li>确定易于搜索的解空间结构,使得能用回溯法方便地搜索整个解空间 。</li>
<li>以深度优先的方式搜索解空间，并且在搜索过程中用剪枝函数避免无效搜索。</li>
</ul>
<h3 id="leetcode"><a href="#leetcode" class="headerlink" title="leetcode"></a>leetcode</h3><p>77.组合：<a href="https://leetcode.cn/problems/combinations/">https://leetcode.cn/problems/combinations/</a></p>
<p>39.组合总和：<a href="https://leetcode.cn/problems/combination-sum/">https://leetcode.cn/problems/combination-sum/</a></p>
<p>40.组合总和 II：<a href="https://leetcode.cn/problems/combination-sum-ii/">https://leetcode.cn/problems/combination-sum-ii/</a></p>
<p>78.子集：<a href="https://leetcode.cn/problems/subsets/">https://leetcode.cn/problems/subsets/</a></p>
<p>90.子集 II：<a href="https://leetcode.cn/problems/subsets-ii/">https://leetcode.cn/problems/subsets-ii/</a></p>
<p>51.N 皇后：<a href="https://leetcode.cn/problems/n-queens/">https://leetcode.cn/problems/n-queens/</a></p>
<h2 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h2><h3 id="算法思想-3"><a href="#算法思想-3" class="headerlink" title="算法思想"></a>算法思想</h3><p>将一个规模为 N 的问题分解为 K 个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。</p>
<p>经典题目：二分查找、汉诺塔问题</p>
<h3 id="一般解题步骤-3"><a href="#一般解题步骤-3" class="headerlink" title="一般解题步骤"></a>一般解题步骤</h3><ul>
<li>将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；</li>
<li>若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题</li>
<li>将各个子问题的解合并为原问题的解。</li>
</ul>
<h3 id="LeetCode-2"><a href="#LeetCode-2" class="headerlink" title="LeetCode"></a>LeetCode</h3><p>108.将有序数组转换成二叉搜索数：<a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/</a></p>
<p>148.排序列表：<a href="https://leetcode.cn/problems/sort-list/">https://leetcode.cn/problems/sort-list/</a></p>
<p>23.合并 k 个升序链表：<a href="https://leetcode.cn/problems/merge-k-sorted-lists/">https://leetcode.cn/problems/merge-k-sorted-lists/</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2024/10/18/heap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/10/18/heap/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-10-18T19:29:46+08:00">
                2024-10-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2024/10/18/heap/" class="leancloud_visitors" data-flag-title="">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.5k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  8 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h2><p>堆是一种满足以下条件的树：</p>
<p>堆中的每一个节点值都大于等于（或小于等于）子树中所有节点的值。或者说，任意一个节点的值都大于等于（或小于等于）所有子节点的值。</p>
<blockquote>
<p>大家可以把堆(最大堆)理解为一个公司,这个公司很公平,谁能力强谁就当老大,不存在弱的人当老大,老大手底下的人一定不会比他强。这样有助于理解后续堆的操作。</p>
</blockquote>
<p><strong>!!!特别提示：</strong></p>
<ul>
<li>很多博客说堆是完全二叉树，其实并非如此，<strong>堆不一定是完全二叉树</strong>，只是为了方便存储和索引，我们通常用完全二叉树的形式来表示堆，事实上，广为人知的斐波那契堆和二项堆就不是完全二叉树,它们甚至都不是二叉树。</li>
<li>（<strong>二叉</strong>）堆是一个数组，它可以被看成是一个 <strong>近似的完全二叉树</strong>。——《算法导论》第三版</li>
</ul>
<p>大家可以尝试判断下面给出的图是否是堆？</p>
<p><img src="/./pictures/%E5%A0%86/%E5%A0%861.png"></p>
<p>第 1 个和第 2 个是堆。第 1 个是最大堆，每个节点都比子树中所有节点大。第 2 个是最小堆，每个节点都比子树中所有节点小。</p>
<p>第 3 个不是，第三个中，根结点 1 比 2 和 15 小，而 15 却比 3 大，19 比 5 大，不满足堆的性质。</p>
<h2 id="堆的用途"><a href="#堆的用途" class="headerlink" title="堆的用途"></a>堆的用途</h2><p>当我们只关心所有数据中的最大值或者最小值，存在多次获取最大值或者最小值，多次插入或删除数据时，就可以使用堆。</p>
<p>有小伙伴可能会想到用有序数组，初始化一个有序数组时间复杂度是 <code>O(nlog(n))</code>，查找最大值或者最小值时间复杂度都是 <code>O(1)</code>，但是，涉及到更新（插入或删除）数据时，时间复杂度为 <code>O(n)</code>，即使是使用复杂度为 <code>O(log(n))</code> 的二分法找到要插入或者删除的数据，在移动数据时也需要 <code>O(n)</code> 的时间复杂度。</p>
<p><strong>相对于有序数组而言，堆的主要优势在于插入和删除数据效率较高。</strong> 因为堆是基于完全二叉树实现的，所以在插入和删除数据时，只需要在二叉树中上下移动节点，时间复杂度为 <code>O(log(n))</code>，相比有序数组的 <code>O(n)</code>，效率更高。</p>
<p>不过，需要注意的是：Heap 初始化的时间复杂度为 <code>O(n)</code>，而非<code>O(nlogn)</code>。</p>
<h2 id="堆的分类"><a href="#堆的分类" class="headerlink" title="堆的分类"></a>堆的分类</h2><p>堆分为 <strong>最大堆</strong> 和 <strong>最小堆</strong>。二者的区别在于节点的排序方式。</p>
<ul>
<li><strong>最大堆</strong>：堆中的每一个节点的值都大于等于子树中所有节点的值</li>
<li><strong>最小堆</strong>：堆中的每一个节点的值都小于等于子树中所有节点的值</li>
</ul>
<p>如下图所示，图 1 是最大堆，图 2 是最小堆</p>
<p><img src="/./pictures/%E5%A0%86/%E5%A0%862.png"></p>
<h2 id="堆的存储"><a href="#堆的存储" class="headerlink" title="堆的存储"></a>堆的存储</h2><p>之前介绍树的时候说过，由于完全二叉树的优秀性质，利用数组存储二叉树即节省空间，又方便索引（若根结点的序号为 1，那么对于树中任意节点 i，其左子节点序号为 <code>2*i</code>，右子节点序号为 <code>2*i+1</code>）。</p>
<p>为了方便存储和索引，（二叉）堆可以用完全二叉树的形式进行存储。存储的方式如下图所示：</p>
<p><img src="/./pictures/%E5%A0%86/%E5%A0%86%E7%9A%84%E5%AD%98%E5%82%A8.png" alt="堆的存储"></p>
<h2 id="堆的操作"><a href="#堆的操作" class="headerlink" title="堆的操作"></a>堆的操作</h2><p>堆的更新操作主要包括两种 : <strong>插入元素</strong> 和 <strong>删除堆顶元素</strong>。操作过程需要着重掌握和理解。</p>
<blockquote>
<p>在进入正题之前，再重申一遍，堆是一个公平的公司，有能力的人自然会走到与他能力所匹配的位置</p>
</blockquote>
<h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><blockquote>
<p>插入元素，作为一个新入职的员工，初来乍到，这个员工需要从基层做起</p>
</blockquote>
<p><strong>1.将要插入的元素放到最后</strong></p>
<p><img src="/./pictures/%E5%A0%86/%E5%A0%86-%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A01.png" alt="堆-插入元素-1"></p>
<blockquote>
<p>有能力的人会逐渐升职加薪，是金子总会发光的！！！</p>
</blockquote>
<p><strong>2.从底向上，如果父结点比该元素小，则该节点和父结点交换，直到无法交换</strong></p>
<p><img src="/./pictures/%E5%A0%86/%E5%A0%86-%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A02.png" alt="堆-插入元素2"></p>
<p><img src="/./pictures/%E5%A0%86/%E5%A0%86-%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A03.png" alt="堆-插入元素3"></p>
<h3 id="删除堆顶元素"><a href="#删除堆顶元素" class="headerlink" title="删除堆顶元素"></a>删除堆顶元素</h3><p>根据堆的性质可知，最大堆的堆顶元素为所有元素中最大的，最小堆的堆顶元素是所有元素中最小的。当我们需要多次查找最大元素或者最小元素的时候，可以利用堆来实现。</p>
<p>删除堆顶元素后，为了保持堆的性质，需要对堆的结构进行调整，我们将这个过程称之为”<strong>堆化</strong>“，堆化的方法分为两种：</p>
<ul>
<li>一种是自底向上的堆化，上述的插入元素所使用的就是自底向上的堆化，元素从最底部向上移动。</li>
<li>另一种是自顶向下堆化，元素由最顶部向下移动。在讲解删除堆顶元素的方法时，我将阐述这两种操作的过程，大家可以体会一下二者的不同。</li>
</ul>
<h4 id="自底向上堆化"><a href="#自底向上堆化" class="headerlink" title="自底向上堆化"></a>自底向上堆化</h4><blockquote>
<p>在堆这个公司中，会出现老大离职的现象，老大离职之后，他的位置就空出来了</p>
</blockquote>
<p>首先删除堆顶元素，使得数组中下标为 1 的位置空出。</p>
<p><img src="/./pictures/%E5%A0%86/%E5%88%A0%E9%99%A4%E5%A0%86%E9%A1%B6%E5%85%83%E7%B4%A01.png" alt="删除堆顶元素1"></p>
<blockquote>
<p>那么他的位置由谁来接替呢，当然是他的直接下属了，谁能力强就让谁上呗</p>
</blockquote>
<p>比较根结点的左子节点和右子节点，也就是下标为 2,3 的数组元素，将较大的元素填充到根结点(下标为 1)的位置。</p>
<p><img src="/./pictures/%E5%A0%86/%E5%88%A0%E9%99%A4%E5%A0%86%E9%A1%B6%E5%85%83%E7%B4%A02.png" alt="删除堆顶元素2"></p>
<blockquote>
<p>这个时候又空出一个位置了，老规矩，谁有能力谁上</p>
</blockquote>
<p>一直循环比较空出位置的左右子节点，并将较大者移至空位，直到堆的最底部</p>
<p><img src="/./pictures/%E5%A0%86/%E5%88%A0%E9%99%A4%E5%A0%86%E9%A1%B6%E5%85%83%E7%B4%A03.png" alt="删除堆顶元素3"></p>
<p>这个时候已经完成了自底向上的堆化，没有元素可以填补空缺了，但是，我们可以看到数组中出现了“气泡”，这会导致存储空间的浪费。接下来我们试试自顶向下堆化。</p>
<h4 id="自顶向下堆化"><a href="#自顶向下堆化" class="headerlink" title="自顶向下堆化"></a>自顶向下堆化</h4><p>自顶向下的堆化用一个词形容就是“石沉大海”，那么第一件事情，就是把石头抬起来，从海面扔下去。这个石头就是堆的最后一个元素，我们将最后一个元素移动到堆顶。</p>
<p><img src="/./pictures/%E5%A0%86/%E5%88%A0%E9%99%A4%E5%A0%86%E9%A1%B6%E5%85%83%E7%B4%A04.png" alt="删除堆顶元素4"></p>
<p>然后开始将这个石头沉入海底，不停与左右子节点的值进行比较，和较大的子节点交换位置，直到无法交换位置。</p>
<p><img src="/./pictures/%E5%A0%86/%E5%88%A0%E9%99%A4%E5%A0%86%E9%A1%B6%E5%85%83%E7%B4%A05.png" alt="删除堆顶元素5"></p>
<p><img src="/./pictures/%E5%A0%86/%E5%88%A0%E9%99%A4%E5%A0%86%E9%A1%B6%E5%85%83%E7%B4%A06.png" alt="删除堆顶元素6"></p>
<h3 id="堆的操作总结"><a href="#堆的操作总结" class="headerlink" title="堆的操作总结"></a>堆的操作总结</h3><ul>
<li><strong>插入元素</strong>：先将元素放至数组末尾，再自底向上堆化，将末尾元素上浮</li>
<li><strong>删除堆顶元素</strong>：删除堆顶元素，将末尾元素放至堆顶，再自顶向下堆化，将堆顶元素下沉。也可以自底向上堆化，只是会产生“气泡”，浪费存储空间。最好采用自顶向下堆化的方式。</li>
</ul>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序的过程分为两步：</p>
<ul>
<li>第一步是建堆，将一个无序的数组建立为一个堆</li>
<li>第二步是排序，将堆顶元素取出，然后对剩下的元素进行堆化，反复迭代，直到所有元素被取出为止。</li>
</ul>
<h3 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h3><p>如果你已经足够了解堆化的过程，那么建堆的过程掌握起来就比较容易了。建堆的过程就是一个对所有非叶节点的自顶向下堆化过程。</p>
<p>首先要了解哪些是非叶节点，最后一个节点的父结点及它之前的元素，都是非叶节点。也就是说，如果节点个数为 n，那么我们需要对 n&#x2F;2 到 1 的节点进行自顶向下（沉底）堆化。</p>
<p>具体过程如下图：</p>
<p><img src="/./pictures/%E5%A0%86/%E5%BB%BA%E5%A0%861.png" alt="建堆1"></p>
<p>将初始的无序数组抽象为一棵树，图中的节点个数为 6，所以 4,5,6 节点为叶节点，1,2,3 节点为非叶节点，所以要对 1-3 号节点进行自顶向下（沉底）堆化，注意，顺序是从后往前堆化，从 3 号节点开始，一直到 1 号节点。<br>3 号节点堆化结果：</p>
<p><img src="/./pictures/%E5%A0%86/%E5%BB%BA%E5%A0%862.png" alt="建堆1"></p>
<p>2 号节点堆化结果：</p>
<p><img src="/./pictures/%E5%A0%86/%E5%BB%BA%E5%A0%863.png" alt="建堆1"></p>
<p>1 号节点堆化结果：</p>
<p><img src="/./pictures/%E5%A0%86/%E5%BB%BA%E5%A0%864.png" alt="建堆1"></p>
<p>至此，数组所对应的树已经成为了一个最大堆，建堆完成！</p>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>由于堆顶元素是所有元素中最大的，所以我们重复取出堆顶元素，将这个最大的堆顶元素放至数组末尾，并对剩下的元素进行堆化即可。</p>
<p>现在思考两个问题：</p>
<ul>
<li>删除堆顶元素后需要执行自顶向下（沉底）堆化还是自底向上（上浮）堆化？</li>
<li>取出的堆顶元素存在哪，新建一个数组存？</li>
</ul>
<p>先回答第一个问题，我们需要执行自顶向下（沉底）堆化，这个堆化一开始要将末尾元素移动至堆顶，这个时候末尾的位置就空出来了，由于堆中元素已经减小，这个位置不会再被使用，所以我们可以将取出的元素放在末尾。</p>
<p>机智的小伙伴已经发现了，这其实是做了一次交换操作，将堆顶和末尾元素调换位置，从而将取出堆顶元素和堆化的第一步(将末尾元素放至根结点位置)进行合并。</p>
<p>详细过程如下图所示：</p>
<p>取出第一个元素并堆化：</p>
<p><img src="/./pictures/%E5%A0%86/%E5%A0%86%E6%8E%92%E5%BA%8F1.png" alt="堆排序1"></p>
<p>取出第二个元素并堆化：</p>
<p><img src="/./pictures/%E5%A0%86/%E5%A0%86%E6%8E%92%E5%BA%8F2.png" alt="堆排序2"></p>
<p>取出第三个元素并堆化：</p>
<p><img src="/./pictures/%E5%A0%86/%E5%A0%86%E6%8E%92%E5%BA%8F3.png" alt="堆排序3"></p>
<p>取出第四个元素并堆化：</p>
<p><img src="/./pictures/%E5%A0%86/%E5%A0%86%E6%8E%92%E5%BA%8F4.png" alt="堆排序4"></p>
<p>取出第五个元素并堆化：</p>
<p><img src="/./pictures/%E5%A0%86/%E5%A0%86%E6%8E%92%E5%BA%8F5.png" alt="堆排序5"></p>
<p>取出第六个元素并堆化：</p>
<p><img src="/./pictures/%E5%A0%86/%E5%A0%86%E6%8E%92%E5%BA%8F6.png" alt="堆排序6"></p>
<p>堆排序完成！</p>
<!-- @include: @article-footer.snippet.md -->

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2024/10/18/common-data-structures-leetcode-recommendations/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/10/18/common-data-structures-leetcode-recommendations/" itemprop="url">常见数据结构经典LeetCode题目推荐</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-10-18T18:37:45+08:00">
                2024-10-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2024/10/18/common-data-structures-leetcode-recommendations/" class="leancloud_visitors" data-flag-title="常见数据结构经典LeetCode题目推荐">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  402 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>704.二分查找：<a href="https://leetcode.cn/problems/binary-search/">https://leetcode.cn/problems/binary-search/</a></p>
<p>80.删除有序数组中的重复项 II：<a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii">https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii</a></p>
<p>977.有序数组的平方：<a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">https://leetcode.cn/problems/squares-of-a-sorted-array/</a></p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>707.设计链表：<a href="https://leetcode.cn/problems/design-linked-list/">https://leetcode.cn/problems/design-linked-list/</a></p>
<p>206.反转链表：<a href="https://leetcode.cn/problems/reverse-linked-list/">https://leetcode.cn/problems/reverse-linked-list/</a></p>
<p>92.反转链表 II：<a href="https://leetcode.cn/problems/reverse-linked-list-ii/">https://leetcode.cn/problems/reverse-linked-list-ii/</a></p>
<p>61.旋转链表：<a href="https://leetcode.cn/problems/rotate-list/">https://leetcode.cn/problems/rotate-list/</a></p>
<h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><p>232.用栈实现队列：<a href="https://leetcode.cn/problems/implement-queue-using-stacks/">https://leetcode.cn/problems/implement-queue-using-stacks/</a></p>
<p>225.用队列实现栈：<a href="https://leetcode.cn/problems/implement-stack-using-queues/">https://leetcode.cn/problems/implement-stack-using-queues/</a></p>
<p>347.前 K 个高频元素：<a href="https://leetcode.cn/problems/top-k-frequent-elements/">https://leetcode.cn/problems/top-k-frequent-elements/</a></p>
<p>239.滑动窗口最大值：<a href="https://leetcode.cn/problems/sliding-window-maximum/">https://leetcode.cn/problems/sliding-window-maximum/</a></p>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>105.从前序与中序遍历构造二叉树：<a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</a></p>
<p>117.填充每个节点的下一个右侧节点指针 II：<a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii">https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii</a></p>
<p>236.二叉树的最近公共祖先：<a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/</a></p>
<p>129.求根节点到叶节点数字之和：<a href="https://leetcode.cn/problems/sum-root-to-leaf-numbers/">https://leetcode.cn/problems/sum-root-to-leaf-numbers/</a></p>
<p>102.二叉树的层序遍历：<a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">https://leetcode.cn/problems/binary-tree-level-order-traversal/</a></p>
<p>530.二叉搜索树的最小绝对差：<a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">https://leetcode.cn/problems/minimum-absolute-difference-in-bst/</a></p>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>200.岛屿数量：<a href="https://leetcode.cn/problems/number-of-islands/">https://leetcode.cn/problems/number-of-islands/</a></p>
<p>207.课程表：<a href="https://leetcode.cn/problems/course-schedule/">https://leetcode.cn/problems/course-schedule/</a></p>
<p>210.课程表 II：<a href="https://leetcode.cn/problems/course-schedule-ii/">https://leetcode.cn/problems/course-schedule-ii/</a></p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>215.数组中的第 K 个最大元素:<a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">https://leetcode.cn/problems/kth-largest-element-in-an-array/</a></p>
<p>216.数据流的中位数:<a href="https://leetcode.cn/problems/find-median-from-data-stream/">https://leetcode.cn/problems/find-median-from-data-stream/</a></p>
<p>217.前 K 个高频元素：<a href="https://leetcode.cn/problems/top-k-frequent-elements/">https://leetcode.cn/problems/top-k-frequent-elements/</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2024/10/09/sql-questions-02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/10/09/sql-questions-02/" itemprop="url">SQL常见面试题总结（2）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-10-09T23:57:38+08:00">
                2024-10-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/" itemprop="url" rel="index">
                    <span itemprop="name">面试问题</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2024/10/09/sql-questions-02/" class="leancloud_visitors" data-flag-title="SQL常见面试题总结（2）">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4.2k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  17 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>题目来源于：<a href="https://www.nowcoder.com/exam/oj?page=1&tab=SQL%E7%AF%87&topicId=240">牛客题霸 - SQL 进阶挑战</a></p>
</blockquote>
<h2 id="增删改操作"><a href="#增删改操作" class="headerlink" title="增删改操作"></a>增删改操作</h2><p>SQL 插入记录的方式汇总：</p>
<ul>
<li><strong>普通插入（全字段）</strong> ：<code>INSERT INTO table_name VALUES (value1, value2, ...)</code></li>
<li><strong>普通插入（限定字段）</strong> ：<code>INSERT INTO table_name (column1, column2, ...) VALUES (value1, value2, ...)</code></li>
<li><strong>多条一次性插入</strong> ：<code>INSERT INTO table_name (column1, column2, ...) VALUES (value1_1, value1_2, ...), (value2_1, value2_2, ...), ...</code></li>
<li><strong>从另一个表导入</strong> ：<code>INSERT INTO table_name SELECT * FROM table_name2 [WHERE key=value]</code></li>
<li><strong>带更新的插入</strong> ：<code>REPLACE INTO table_name VALUES (value1, value2, ...)</code>（注意这种原理是检测到主键或唯一性索引键重复就删除原记录后重新插入）</li>
</ul>
<h3 id="插入记录（一）"><a href="#插入记录（一）" class="headerlink" title="插入记录（一）"></a>插入记录（一）</h3><p><strong>描述</strong>：牛客后台会记录每个用户的试卷作答记录到 <code>exam_record</code> 表，现在有两个用户的作答记录详情如下：</p>
<ul>
<li>用户 1001 在 2021 年 9 月 1 日晚上 10 点 11 分 12 秒开始作答试卷 9001，并在 50 分钟后提交，得了 90 分；</li>
<li>用户 1002 在 2021 年 9 月 4 日上午 7 点 1 分 2 秒开始作答试卷 9002，并在 10 分钟后退出了平台。</li>
</ul>
<p>试卷作答记录表<code>exam_record</code>中，表已建好，其结构如下，请用一条语句将这两条记录插入表中。</p>
<table>
<thead>
<tr>
<th>Filed</th>
<th>Type</th>
<th>Null</th>
<th>Key</th>
<th>Extra</th>
<th>Default</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>int(11)</td>
<td>NO</td>
<td>PRI</td>
<td>auto_increment</td>
<td>(NULL)</td>
<td>自增 ID</td>
</tr>
<tr>
<td>uid</td>
<td>int(11)</td>
<td>NO</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>用户 ID</td>
</tr>
<tr>
<td>exam_id</td>
<td>int(11)</td>
<td>NO</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>试卷 ID</td>
</tr>
<tr>
<td>start_time</td>
<td>datetime</td>
<td>NO</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>开始时间</td>
</tr>
<tr>
<td>submit_time</td>
<td>datetime</td>
<td>YES</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>提交时间</td>
</tr>
<tr>
<td>score</td>
<td>tinyint(4)</td>
<td>YES</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>得分</td>
</tr>
</tbody></table>
<p><strong>答案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 存在自增主键，无需手动赋值</span><br><span class="line"><span class="keyword">INSERT INTO</span> exam_record (uid, exam_id, start_time, submit_time, score) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1001</span>, <span class="number">9001</span>, <span class="string">&#x27;2021-09-01 22:11:12&#x27;</span>, <span class="string">&#x27;2021-09-01 23:01:12&#x27;</span>, <span class="number">90</span>),</span><br><span class="line">(<span class="number">1002</span>, <span class="number">9002</span>, <span class="string">&#x27;2021-09-04 07:01:02&#x27;</span>, <span class="keyword">NULL</span>, <span class="keyword">NULL</span>);</span><br></pre></td></tr></table></figure>

<h3 id="插入记录（二）"><a href="#插入记录（二）" class="headerlink" title="插入记录（二）"></a>插入记录（二）</h3><p><strong>描述</strong>：现有一张试卷作答记录表<code>exam_record</code>，结构如下表，其中包含多年来的用户作答试卷记录，由于数据越来越多，维护难度越来越大，需要对数据表内容做精简，历史数据做备份。</p>
<p>表<code>exam_record</code>：</p>
<table>
<thead>
<tr>
<th>Filed</th>
<th>Type</th>
<th>Null</th>
<th>Key</th>
<th>Extra</th>
<th>Default</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>int(11)</td>
<td>NO</td>
<td>PRI</td>
<td>auto_increment</td>
<td>(NULL)</td>
<td>自增 ID</td>
</tr>
<tr>
<td>uid</td>
<td>int(11)</td>
<td>NO</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>用户 ID</td>
</tr>
<tr>
<td>exam_id</td>
<td>int(11)</td>
<td>NO</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>试卷 ID</td>
</tr>
<tr>
<td>start_time</td>
<td>datetime</td>
<td>NO</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>开始时间</td>
</tr>
<tr>
<td>submit_time</td>
<td>datetime</td>
<td>YES</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>提交时间</td>
</tr>
<tr>
<td>score</td>
<td>tinyint(4)</td>
<td>YES</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>得分</td>
</tr>
</tbody></table>
<p>我们已经创建了一张新表<code>exam_record_before_2021</code>用来备份 2021 年之前的试题作答记录，结构和<code>exam_record</code>表一致，请将 2021 年之前的已完成了的试题作答纪录导入到该表。</p>
<p><strong>答案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> exam_record_before_2021 (uid, exam_id, start_time, submit_time, score)</span><br><span class="line"><span class="keyword">SELECT</span> uid,exam_id,start_time,submit_time,score</span><br><span class="line"><span class="keyword">FROM</span> exam_record</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">YEAR</span>(submit_time) <span class="operator">&lt;</span> <span class="number">2021</span>;</span><br></pre></td></tr></table></figure>

<h3 id="插入记录（三）"><a href="#插入记录（三）" class="headerlink" title="插入记录（三）"></a>插入记录（三）</h3><p><strong>描述</strong>：现在有一套 ID 为 9003 的高难度 SQL 试卷，时长为一个半小时，请你将 2021-01-01 00:00:00 作为发布时间插入到试题信息表<code>examination_info</code>，不管该 ID 试卷是否存在，都要插入成功，请尝试插入它。</p>
<p>试题信息表<code>examination_info</code>：</p>
<table>
<thead>
<tr>
<th>Filed</th>
<th>Type</th>
<th>Null</th>
<th>Key</th>
<th>Extra</th>
<th>Default</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>int(11)</td>
<td>NO</td>
<td>PRI</td>
<td>auto_increment</td>
<td>(NULL)</td>
<td>自增 ID</td>
</tr>
<tr>
<td>exam_id</td>
<td>int(11)</td>
<td>NO</td>
<td>UNI</td>
<td></td>
<td>(NULL)</td>
<td>试卷 ID</td>
</tr>
<tr>
<td>tag</td>
<td>varchar(32)</td>
<td>YES</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>类别标签</td>
</tr>
<tr>
<td>difficulty</td>
<td>varchar(8)</td>
<td>YES</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>难度</td>
</tr>
<tr>
<td>duration</td>
<td>int(11)</td>
<td>NO</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>时长(分钟数)</td>
</tr>
<tr>
<td>release_time</td>
<td>datetime</td>
<td>YES</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>发布时间</td>
</tr>
</tbody></table>
<p><strong>答案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">REPLACE <span class="keyword">INTO</span> examination_info <span class="keyword">VALUES</span></span><br><span class="line"> (<span class="keyword">NULL</span>, <span class="number">9003</span>, &quot;SQL&quot;, &quot;hard&quot;, <span class="number">90</span>, &quot;2021-01-01 00:00:00&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="更新记录（一）"><a href="#更新记录（一）" class="headerlink" title="更新记录（一）"></a>更新记录（一）</h3><p><strong>描述</strong>：现在有一张试卷信息表 <code>examination_info</code>, 表结构如下图所示：</p>
<table>
<thead>
<tr>
<th>Filed</th>
<th>Type</th>
<th>Null</th>
<th>Key</th>
<th>Extra</th>
<th>Default</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>int(11)</td>
<td>NO</td>
<td>PRI</td>
<td>auto_increment</td>
<td>(NULL)</td>
<td>自增 ID</td>
</tr>
<tr>
<td>exam_id</td>
<td>int(11)</td>
<td>NO</td>
<td>UNI</td>
<td></td>
<td>(NULL)</td>
<td>试卷 ID</td>
</tr>
<tr>
<td>tag</td>
<td>char(32)</td>
<td>YES</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>类别标签</td>
</tr>
<tr>
<td>difficulty</td>
<td>char(8)</td>
<td>YES</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>难度</td>
</tr>
<tr>
<td>duration</td>
<td>int(11)</td>
<td>NO</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>时长</td>
</tr>
<tr>
<td>release_time</td>
<td>datetime</td>
<td>YES</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>发布时间</td>
</tr>
</tbody></table>
<p>请把<strong>examination_info</strong>表中<code>tag</code>为<code>PYTHON</code>的<code>tag</code>字段全部修改为<code>Python</code>。</p>
<p><strong>思路</strong>：这题有两种解题思路，最容易想到的是直接<code>update + where</code>来指定条件更新，第二种就是根据要修改的字段进行查找替换</p>
<p><strong>答案一</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> examination_info <span class="keyword">SET</span> tag <span class="operator">=</span> <span class="string">&#x27;Python&#x27;</span> <span class="keyword">WHERE</span> tag<span class="operator">=</span><span class="string">&#x27;PYTHON&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>答案二</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> examination_info</span><br><span class="line"><span class="keyword">SET</span> tag <span class="operator">=</span> REPLACE(tag,<span class="string">&#x27;PYTHON&#x27;</span>,<span class="string">&#x27;Python&#x27;</span>)</span><br><span class="line"></span><br><span class="line"># REPLACE (目标字段，&quot;查找内容&quot;,&quot;替换内容&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="更新记录（二）"><a href="#更新记录（二）" class="headerlink" title="更新记录（二）"></a>更新记录（二）</h3><p><strong>描述</strong>：现有一张试卷作答记录表 exam_record，其中包含多年来的用户作答试卷记录，结构如下表：作答记录表 <code>exam_record</code>： <strong><code>submit_time</code></strong> 为 完成时间 （注意这句话）</p>
<table>
<thead>
<tr>
<th>Filed</th>
<th>Type</th>
<th>Null</th>
<th>Key</th>
<th>Extra</th>
<th>Default</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>int(11)</td>
<td>NO</td>
<td>PRI</td>
<td>auto_increment</td>
<td>(NULL)</td>
<td>自增 ID</td>
</tr>
<tr>
<td>uid</td>
<td>int(11)</td>
<td>NO</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>用户 ID</td>
</tr>
<tr>
<td>exam_id</td>
<td>int(11)</td>
<td>NO</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>试卷 ID</td>
</tr>
<tr>
<td>start_time</td>
<td>datetime</td>
<td>NO</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>开始时间</td>
</tr>
<tr>
<td>submit_time</td>
<td>datetime</td>
<td>YES</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>提交时间</td>
</tr>
<tr>
<td>score</td>
<td>tinyint(4)</td>
<td>YES</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>得分</td>
</tr>
</tbody></table>
<p><strong>题目要求</strong>：请把 <code>exam_record</code> 表中 2021 年 9 月 1 日&#x3D;&#x3D;之前&#x3D;&#x3D;开始作答的&#x3D;&#x3D;未完成&#x3D;&#x3D;记录全部改为被动完成，即：将完成时间改为’2099-01-01 00:00:00’，分数改为 0。</p>
<p><strong>思路</strong>：注意题干中的关键字(已经高亮) <code>&quot; xxx 时间 &quot;</code>之前这个条件， 那么这里马上就要想到要进行时间的比较 可以直接 <code>xxx_time &lt; &quot;2021-09-01 00:00:00&quot;,</code> 也可以采用<code>date()</code>函数来进行比较；第二个条件就是 <code>&quot;未完成&quot;</code>， 即完成时间为 NULL，也就是题目中的提交时间 —– <code>submit_time 为 NULL</code>。</p>
<p><strong>答案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> exam_record <span class="keyword">SET</span> submit_time <span class="operator">=</span> <span class="string">&#x27;2099-01-01 00:00:00&#x27;</span>, score <span class="operator">=</span> <span class="number">0</span> <span class="keyword">WHERE</span> <span class="type">DATE</span>(start_time) <span class="operator">&lt;</span> &quot;2021-09-01&quot; <span class="keyword">AND</span> submit_time <span class="keyword">IS</span> <span class="keyword">null</span></span><br></pre></td></tr></table></figure>

<h3 id="删除记录（一）"><a href="#删除记录（一）" class="headerlink" title="删除记录（一）"></a>删除记录（一）</h3><p><strong>描述</strong>：现有一张试卷作答记录表 <code>exam_record</code>，其中包含多年来的用户作答试卷记录，结构如下表：</p>
<p>作答记录表<code>exam_record：</code> <strong><code>start_time</code></strong> 是试卷开始时间<code>submit_time</code> 是交卷，即结束时间。</p>
<table>
<thead>
<tr>
<th>Filed</th>
<th>Type</th>
<th>Null</th>
<th>Key</th>
<th>Extra</th>
<th>Default</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>int(11)</td>
<td>NO</td>
<td>PRI</td>
<td>auto_increment</td>
<td>(NULL)</td>
<td>自增 ID</td>
</tr>
<tr>
<td>uid</td>
<td>int(11)</td>
<td>NO</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>用户 ID</td>
</tr>
<tr>
<td>exam_id</td>
<td>int(11)</td>
<td>NO</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>试卷 ID</td>
</tr>
<tr>
<td>start_time</td>
<td>datetime</td>
<td>NO</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>开始时间</td>
</tr>
<tr>
<td>submit_time</td>
<td>datetime</td>
<td>YES</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>提交时间</td>
</tr>
<tr>
<td>score</td>
<td>tinyint(4)</td>
<td>YES</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>得分</td>
</tr>
</tbody></table>
<p><strong>要求</strong>：请删除<code>exam_record</code>表中作答时间小于 5 分钟整且分数不及格（及格线为 60 分）的记录；</p>
<p><strong>思路</strong>：这一题虽然是练习删除，仔细看确是考察对时间函数的用法，这里提及的分钟数比较，常用的函数有 <strong><code>TIMEDIFF</code><strong>和</strong><code>TIMESTAMPDIFF</code></strong> ，两者用法稍有区别，后者更为灵活，这都是看个人习惯。</p>
<p>1.　 <code>TIMEDIFF</code>：两个时间之间的差值</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TIMEDIFF(time1, time2)</span><br></pre></td></tr></table></figure>

<p>两者参数都是必须的，都是一个时间或者日期时间表达式。如果指定的参数不合法或者是 NULL，那么函数将返回 NULL。</p>
<p>对于这题而言，可以用在 minute 函数里面，因为 TIMEDIFF 计算出来的是时间的差值，在外面套一个 MINUTE 函数，计算出来的就是分钟数。</p>
<ol start="2">
<li><code>TIMESTAMPDIFF</code>：用于计算两个日期的时间差</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">TIMESTAMPDIFF(unit,datetime_expr1,datetime_expr2)</span><br><span class="line"># 参数说明</span><br><span class="line">#unit: 日期比较返回的时间差单位，常用可选值如下:</span><br><span class="line"><span class="keyword">SECOND</span>：秒</span><br><span class="line"><span class="keyword">MINUTE</span>：分钟</span><br><span class="line"><span class="keyword">HOUR</span>：小时</span><br><span class="line"><span class="keyword">DAY</span>：天</span><br><span class="line">WEEK：星期</span><br><span class="line"><span class="keyword">MONTH</span>：月</span><br><span class="line">QUARTER：季度</span><br><span class="line"><span class="keyword">YEAR</span>：年</span><br><span class="line"># TIMESTAMPDIFF函数返回datetime_expr2 <span class="operator">-</span> datetime_expr1的结果（人话： 后面的 <span class="operator">-</span> 前面的  即<span class="number">2</span><span class="number">-1</span>），其中datetime_expr1和datetime_expr2可以是<span class="type">DATE</span>或DATETIME类型值（人话：可以是“<span class="number">2023</span><span class="number">-01</span><span class="number">-01</span>”， 也可以是“<span class="number">2023</span><span class="number">-01</span><span class="number">-01</span><span class="operator">-</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>”）</span><br></pre></td></tr></table></figure>

<p>这题需要进行分钟的比较，那么就是 TIMESTAMPDIFF(MINUTE, 开始时间， 结束时间) &lt; 5</p>
<p><strong>答案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> exam_record <span class="keyword">WHERE</span> <span class="keyword">MINUTE</span> (TIMEDIFF(submit_time , start_time)) <span class="operator">&lt;</span> <span class="number">5</span> <span class="keyword">AND</span> score <span class="operator">&lt;</span> <span class="number">60</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> exam_record <span class="keyword">WHERE</span> TIMESTAMPDIFF(<span class="keyword">MINUTE</span>, start_time, submit_time) <span class="operator">&lt;</span> <span class="number">5</span> <span class="keyword">AND</span> score <span class="operator">&lt;</span> <span class="number">60</span></span><br></pre></td></tr></table></figure>

<h3 id="删除记录（二）"><a href="#删除记录（二）" class="headerlink" title="删除记录（二）"></a>删除记录（二）</h3><p><strong>描述</strong>：现有一张试卷作答记录表<code>exam_record</code>，其中包含多年来的用户作答试卷记录，结构如下表：</p>
<p>作答记录表<code>exam_record</code>：<code>start_time</code> 是试卷开始时间，<code>submit_time</code> 是交卷时间，即结束时间，如果未完成的话，则为空。</p>
<table>
<thead>
<tr>
<th>Filed</th>
<th>Type</th>
<th align="center">Null</th>
<th>Key</th>
<th>Extra</th>
<th>Default</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>int(11)</td>
<td align="center">NO</td>
<td>PRI</td>
<td>auto_increment</td>
<td>(NULL)</td>
<td>自增 ID</td>
</tr>
<tr>
<td>uid</td>
<td>int(11)</td>
<td align="center">NO</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>用户 ID</td>
</tr>
<tr>
<td>exam_id</td>
<td>int(11)</td>
<td align="center">NO</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>试卷 ID</td>
</tr>
<tr>
<td>start_time</td>
<td>datetime</td>
<td align="center">NO</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>开始时间</td>
</tr>
<tr>
<td>submit_time</td>
<td>datetime</td>
<td align="center">YES</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>提交时间</td>
</tr>
<tr>
<td>score</td>
<td>tinyint(4)</td>
<td align="center">YES</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>分数</td>
</tr>
</tbody></table>
<p><strong>要求</strong>：请删除<code>exam_record</code>表中未完成作答&#x3D;&#x3D;或&#x3D;&#x3D;作答时间小于 5 分钟整的记录中，开始作答时间最早的 3 条记录。</p>
<p><strong>思路</strong>：这题比较简单，但是要注意题干中给出的信息，结束时间，如果未完成的话，则为空，这个其实就是一个条件</p>
<p>还有一个条件就是小于 5 分钟，跟上题类似，但是这里是<strong>或</strong>，即两个条件满足一个就行；另外就是稍微考察到了排序和 limit 的用法。</p>
<p><strong>答案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> exam_record <span class="keyword">WHERE</span> submit_time <span class="keyword">IS</span> <span class="keyword">null</span> <span class="keyword">OR</span> TIMESTAMPDIFF(<span class="keyword">MINUTE</span>, start_time, submit_time) <span class="operator">&lt;</span> <span class="number">5</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> start_time</span><br><span class="line">LIMIT <span class="number">3</span></span><br><span class="line"># 默认就是<span class="keyword">asc</span>， <span class="keyword">desc</span>是降序排列</span><br></pre></td></tr></table></figure>

<h3 id="删除记录（三）"><a href="#删除记录（三）" class="headerlink" title="删除记录（三）"></a>删除记录（三）</h3><p><strong>描述</strong>：现有一张试卷作答记录表 exam_record，其中包含多年来的用户作答试卷记录，结构如下表：</p>
<table>
<thead>
<tr>
<th>Filed</th>
<th>Type</th>
<th align="center">Null</th>
<th>Key</th>
<th>Extra</th>
<th>Default</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>int(11)</td>
<td align="center">NO</td>
<td>PRI</td>
<td>auto_increment</td>
<td>(NULL)</td>
<td>自增 ID</td>
</tr>
<tr>
<td>uid</td>
<td>int(11)</td>
<td align="center">NO</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>用户 ID</td>
</tr>
<tr>
<td>exam_id</td>
<td>int(11)</td>
<td align="center">NO</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>试卷 ID</td>
</tr>
<tr>
<td>start_time</td>
<td>datetime</td>
<td align="center">NO</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>开始时间</td>
</tr>
<tr>
<td>submit_time</td>
<td>datetime</td>
<td align="center">YES</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>提交时间</td>
</tr>
<tr>
<td>score</td>
<td>tinyint(4)</td>
<td align="center">YES</td>
<td></td>
<td></td>
<td>(NULL)</td>
<td>分数</td>
</tr>
</tbody></table>
<p><strong>要求</strong>：请删除<code>exam_record</code>表中所有记录，&#x3D;&#x3D;并重置自增主键&#x3D;&#x3D;</p>
<p><strong>思路</strong>：这题考察对三种删除语句的区别，注意高亮部分，要求重置主键；</p>
<ul>
<li><code>DROP</code>: 清空表，删除表结构，不可逆</li>
<li><code>TRUNCATE</code>: 格式化表，不删除表结构，不可逆</li>
<li><code>DELETE</code>：删除数据，可逆</li>
</ul>
<p>这里选用<code>TRUNCATE</code>的原因是：TRUNCATE 只能作用于表；<code>TRUNCATE</code>会清空表中的所有行，但表结构及其约束、索引等保持不变；<code>TRUNCATE</code>会重置表的自增值；使用<code>TRUNCATE</code>后会使表和索引所占用的空间会恢复到初始大小。</p>
<p>这题也可以采用<code>DELETE</code>来做，但是在删除后，还需要手动<code>ALTER</code>表结构来设置主键初始值；</p>
<p>同理也可以采用<code>DROP</code>来做，直接删除整张表，包括表结构，然后再新建表即可。</p>
<p><strong>答案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span>  exam_record;</span><br></pre></td></tr></table></figure>

<h2 id="表与索引操作"><a href="#表与索引操作" class="headerlink" title="表与索引操作"></a>表与索引操作</h2><h3 id="创建一张新表"><a href="#创建一张新表" class="headerlink" title="创建一张新表"></a>创建一张新表</h3><p><strong>描述</strong>：现有一张用户信息表，其中包含多年来在平台注册过的用户信息，随着牛客平台的不断壮大，用户量飞速增长，为了高效地为高活跃用户提供服务，现需要将部分用户拆分出一张新表。</p>
<p>原来的用户信息表：</p>
<table>
<thead>
<tr>
<th>Filed</th>
<th>Type</th>
<th>Null</th>
<th>Key</th>
<th>Default</th>
<th>Extra</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>int(11)</td>
<td>NO</td>
<td>PRI</td>
<td>(NULL)</td>
<td>auto_increment</td>
<td>自增 ID</td>
</tr>
<tr>
<td>uid</td>
<td>int(11)</td>
<td>NO</td>
<td>UNI</td>
<td>(NULL)</td>
<td></td>
<td>用户 ID</td>
</tr>
<tr>
<td>nick_name</td>
<td>varchar(64)</td>
<td>YES</td>
<td></td>
<td>(NULL)</td>
<td></td>
<td>昵称</td>
</tr>
<tr>
<td>achievement</td>
<td>int(11)</td>
<td>YES</td>
<td></td>
<td>0</td>
<td></td>
<td>成就值</td>
</tr>
<tr>
<td>level</td>
<td>int(11)</td>
<td>YES</td>
<td></td>
<td>(NULL)</td>
<td></td>
<td>用户等级</td>
</tr>
<tr>
<td>job</td>
<td>varchar(32)</td>
<td>YES</td>
<td></td>
<td>(NULL)</td>
<td></td>
<td>职业方向</td>
</tr>
<tr>
<td>register_time</td>
<td>datetime</td>
<td>YES</td>
<td></td>
<td>CURRENT_TIMESTAMP</td>
<td></td>
<td>注册时间</td>
</tr>
</tbody></table>
<p>作为数据分析师，请<strong>创建一张优质用户信息表 user_info_vip</strong>，表结构和用户信息表一致。</p>
<p>你应该返回的输出如下表格所示，请写出建表语句将表格中所有限制和说明记录到表里。</p>
<table>
<thead>
<tr>
<th>Filed</th>
<th>Type</th>
<th>Null</th>
<th>Key</th>
<th>Default</th>
<th>Extra</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>int(11)</td>
<td>NO</td>
<td>PRI</td>
<td>(NULL)</td>
<td>auto_increment</td>
<td>自增 ID</td>
</tr>
<tr>
<td>uid</td>
<td>int(11)</td>
<td>NO</td>
<td>UNI</td>
<td>(NULL)</td>
<td></td>
<td>用户 ID</td>
</tr>
<tr>
<td>nick_name</td>
<td>varchar(64)</td>
<td>YES</td>
<td></td>
<td>(NULL)</td>
<td></td>
<td>昵称</td>
</tr>
<tr>
<td>achievement</td>
<td>int(11)</td>
<td>YES</td>
<td></td>
<td>0</td>
<td></td>
<td>成就值</td>
</tr>
<tr>
<td>level</td>
<td>int(11)</td>
<td>YES</td>
<td></td>
<td>(NULL)</td>
<td></td>
<td>用户等级</td>
</tr>
<tr>
<td>job</td>
<td>varchar(32)</td>
<td>YES</td>
<td></td>
<td>(NULL)</td>
<td></td>
<td>职业方向</td>
</tr>
<tr>
<td>register_time</td>
<td>datetime</td>
<td>YES</td>
<td></td>
<td>CURRENT_TIMESTAMP</td>
<td></td>
<td>注册时间</td>
</tr>
</tbody></table>
<p><strong>思路</strong>：如果这题给出了旧表的名称，可直接<code>create table 新表 as select * from 旧表;</code> 但是这题并没有给出旧表名称，所以需要自己创建，注意默认值和键的创建即可，比较简单。（注意：如果是在牛客网上面执行，请注意 comment 中要和题目中的 comment 保持一致，包括大小写，否则不通过，还有字符也要设置）</p>
<p>答案：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> user_info_vip(</span><br><span class="line">    id <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT COMMENT<span class="string">&#x27;自增ID&#x27;</span>,</span><br><span class="line">    uid <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">UNIQUE</span> <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;用户ID&#x27;</span>,</span><br><span class="line">    nick_name <span class="type">VARCHAR</span>(<span class="number">64</span>) COMMENT<span class="string">&#x27;昵称&#x27;</span>,</span><br><span class="line">    achievement <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;成就值&#x27;</span>,</span><br><span class="line">    `level` <span class="type">INT</span>(<span class="number">11</span>) COMMENT <span class="string">&#x27;用户等级&#x27;</span>,</span><br><span class="line">    job <span class="type">VARCHAR</span>(<span class="number">32</span>) COMMENT <span class="string">&#x27;职业方向&#x27;</span>,</span><br><span class="line">    register_time DATETIME <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;注册时间&#x27;</span></span><br><span class="line">)<span class="keyword">CHARACTER SET</span> UTF8</span><br></pre></td></tr></table></figure>

<h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h3><p><strong>描述</strong>： 现有一张用户信息表<code>user_info</code>，其中包含多年来在平台注册过的用户信息。</p>
<p><strong>用户信息表 <code>user_info</code>：</strong></p>
<table>
<thead>
<tr>
<th>Filed</th>
<th>Type</th>
<th>Null</th>
<th>Key</th>
<th>Default</th>
<th>Extra</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>int(11)</td>
<td>NO</td>
<td>PRI</td>
<td>(NULL)</td>
<td>auto_increment</td>
<td>自增 ID</td>
</tr>
<tr>
<td>uid</td>
<td>int(11)</td>
<td>NO</td>
<td>UNI</td>
<td>(NULL)</td>
<td></td>
<td>用户 ID</td>
</tr>
<tr>
<td>nick_name</td>
<td>varchar(64)</td>
<td>YES</td>
<td></td>
<td>(NULL)</td>
<td></td>
<td>昵称</td>
</tr>
<tr>
<td>achievement</td>
<td>int(11)</td>
<td>YES</td>
<td></td>
<td>0</td>
<td></td>
<td>成就值</td>
</tr>
<tr>
<td>level</td>
<td>int(11)</td>
<td>YES</td>
<td></td>
<td>(NULL)</td>
<td></td>
<td>用户等级</td>
</tr>
<tr>
<td>job</td>
<td>varchar(32)</td>
<td>YES</td>
<td></td>
<td>(NULL)</td>
<td></td>
<td>职业方向</td>
</tr>
<tr>
<td>register_time</td>
<td>datetime</td>
<td>YES</td>
<td></td>
<td>CURRENT_TIMESTAMP</td>
<td></td>
<td>注册时间</td>
</tr>
</tbody></table>
<p><strong>要求：</strong>请在用户信息表，字段 <code>level</code> 的后面增加一列最多可保存 15 个汉字的字段 <code>school</code>；并将表中 <code>job</code> 列名改为 <code>profession</code>，同时 <code>varchar</code> 字段长度变为 10；<code>achievement</code> 的默认值设置为 0。</p>
<p><strong>思路</strong>：首先做这题之前，需要了解 ALTER 语句的基本用法：</p>
<ul>
<li>添加一列：<code>ALTER TABLE 表名 ADD COLUMN 列名 类型 【first | after 字段名】;</code>（first ： 在某列之前添加，after 反之）</li>
<li>修改列的类型或约束：<code>ALTER TABLE 表名 MODIFY COLUMN 列名 新类型 【新约束】;</code></li>
<li>修改列名：<code>ALTER TABLE 表名 change COLUMN 旧列名 新列名 类型;</code></li>
<li>删除列：<code>ALTER TABLE 表名 drop COLUMN 列名;</code></li>
<li>修改表名：<code>ALTER TABLE 表名 rename 【to】 新表名;</code></li>
<li>将某一列放到第一列：<code>ALTER TABLE 表名 MODIFY COLUMN 列名 类型 first;</code></li>
</ul>
<p><code>COLUMN</code> 关键字其实可以省略不写，这里基于规范还是罗列出来了。</p>
<p>在修改时，如果有多个修改项，可以写到一起，但要注意格式</p>
<p><strong>答案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> user_info</span><br><span class="line">    <span class="keyword">ADD</span> school <span class="type">VARCHAR</span>(<span class="number">15</span>) AFTER level,</span><br><span class="line">    CHANGE job profession <span class="type">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">    MODIFY achievement <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><p><strong>描述</strong>：现有一张试卷作答记录表 <code>exam_record</code>，其中包含多年来的用户作答试卷记录。一般每年都会为 <code>exam_record</code> 表建立一张备份表 <code>exam_record_&#123;YEAR&#125;，&#123;YEAR&#125;</code> 为对应年份。</p>
<p>现在随着数据越来越多，存储告急，请你把很久前的（2011 到 2014 年）备份表都删掉（如果存在的话）。</p>
<p><strong>思路</strong>：这题很简单，直接删就行，如果嫌麻烦，可以将要删除的表用逗号隔开，写到一行；这里肯定会有小伙伴问：如果要删除很多张表呢？放心，如果要删除很多张表，可以写脚本来进行删除。</p>
<p><strong>答案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> exam_record_2011;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> exam_record_2012;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> exam_record_2013;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> exam_record_2014;</span><br></pre></td></tr></table></figure>

<h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><p><strong>描述</strong>：现有一张试卷信息表 <code>examination_info</code>，其中包含各种类型试卷的信息。为了对表更方便快捷地查询，需要在 <code>examination_info</code> 表创建以下索引，</p>
<p>规则如下：在 <code>duration</code> 列创建普通索引 <code>idx_duration</code>、在 <code>exam_id</code> 列创建唯一性索引 <code>uniq_idx_exam_id</code>、在 <code>tag</code> 列创建全文索引 <code>full_idx_tag</code>。</p>
<p>根据题意，将返回如下结果：</p>
<table>
<thead>
<tr>
<th>examination_info</th>
<th>0</th>
<th>PRIMARY</th>
<th>1</th>
<th>id</th>
<th>A</th>
<th>0</th>
<th></th>
<th></th>
<th></th>
<th>BTREE</th>
</tr>
</thead>
<tbody><tr>
<td>examination_info</td>
<td>0</td>
<td>uniq_idx_exam_id</td>
<td>1</td>
<td>exam_id</td>
<td>A</td>
<td>0</td>
<td></td>
<td></td>
<td>YES</td>
<td>BTREE</td>
</tr>
<tr>
<td>examination_info</td>
<td>1</td>
<td>idx_duration</td>
<td>1</td>
<td>duration</td>
<td>A</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td>BTREE</td>
</tr>
<tr>
<td>examination_info</td>
<td>1</td>
<td>full_idx_tag</td>
<td>1</td>
<td>tag</td>
<td></td>
<td>0</td>
<td></td>
<td></td>
<td>YES</td>
<td>FULLTEXT</td>
</tr>
</tbody></table>
<p>备注：后台会通过 <code>SHOW INDEX FROM examination_info</code> 语句来对比输出结果</p>
<p><strong>思路</strong>：做这题首先需要了解常见的索引类型：</p>
<ul>
<li>B-Tree 索引：B-Tree（或称为平衡树）索引是最常见和默认的索引类型。它适用于各种查询条件，可以快速定位到符合条件的数据。B-Tree 索引适用于普通的查找操作，支持等值查询、范围查询和排序。</li>
<li>唯一索引：唯一索引与普通的 B-Tree 索引类似，不同之处在于它要求被索引的列的值是唯一的。这意味着在插入或更新数据时，MySQL 会验证索引列的唯一性。</li>
<li>主键索引：主键索引是一种特殊的唯一索引，它用于唯一标识表中的每一行数据。每个表只能有一个主键索引，它可以帮助提高数据的访问速度和数据完整性。</li>
<li>全文索引：全文索引用于在文本数据中进行全文搜索。它支持在文本字段中进行关键字搜索，而不仅仅是简单的等值或范围查找。全文索引适用于需要进行全文搜索的应用场景。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 示例：</span></span><br><span class="line"><span class="comment">-- 添加B-Tree索引：</span></span><br><span class="line">	<span class="keyword">CREATE</span> INDEX idx_name(索引名) <span class="keyword">ON</span> 表名 (字段名);   <span class="comment">-- idx_name为索引名，以下都是</span></span><br><span class="line"><span class="comment">-- 创建唯一索引：</span></span><br><span class="line">	<span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX idx_name <span class="keyword">ON</span> 表名 (字段名);</span><br><span class="line"><span class="comment">-- 创建一个主键索引：</span></span><br><span class="line">	<span class="keyword">ALTER TABLE</span> 表名 <span class="keyword">ADD</span> <span class="keyword">PRIMARY KEY</span> (字段名);</span><br><span class="line"><span class="comment">-- 创建一个全文索引</span></span><br><span class="line">	<span class="keyword">ALTER TABLE</span> 表名 <span class="keyword">ADD</span> FULLTEXT INDEX idx_name (字段名);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 通过以上示例，可以看出create 和 alter 都可以添加索引</span></span><br></pre></td></tr></table></figure>

<p>有了以上的基础知识之后，该题答案也就浮出水面了。</p>
<p><strong>答案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> examination_info</span><br><span class="line">    <span class="keyword">ADD</span> INDEX idx_duration(duration),</span><br><span class="line">    <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> INDEX uniq_idx_exam_id(exam_id),</span><br><span class="line">    <span class="keyword">ADD</span> FULLTEXT INDEX full_idx_tag(tag);</span><br></pre></td></tr></table></figure>

<h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><p><strong>描述</strong>：请删除<code>examination_info</code>表上的唯一索引 uniq_idx_exam_id 和全文索引 full_idx_tag。</p>
<p><strong>思路</strong>：该题考察删除索引的基本语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用 DROP INDEX 删除索引</span></span><br><span class="line"><span class="keyword">DROP</span> INDEX idx_name <span class="keyword">ON</span> 表名;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 ALTER TABLE 删除索引</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> employees <span class="keyword">DROP</span> INDEX idx_email;</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是：在 MySQL 中，一次删除多个索引的操作是不支持的。每次删除索引时，只能指定一个索引名称进行删除。</p>
<p>而且 <strong>DROP</strong> 命令需要慎用！！！</p>
<p><strong>答案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX uniq_idx_exam_id <span class="keyword">ON</span> examination_info;</span><br><span class="line"><span class="keyword">DROP</span> INDEX full_idx_tag <span class="keyword">ON</span> examination_info;</span><br></pre></td></tr></table></figure>

<!-- @include: @article-footer.snippet.md -->

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2024/10/02/disruptor-questions/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/10/02/disruptor-questions/" itemprop="url">Disruptor常见问题总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-10-02T22:06:36+08:00">
                2024-10-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" itemprop="url" rel="index">
                    <span itemprop="name">消息队列</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2024/10/02/disruptor-questions/" class="leancloud_visitors" data-flag-title="Disruptor常见问题总结">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.7k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  9 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Disruptor 是一个相对冷门一些的知识点，不过，如果你的项目经历中用到了 Disruptor 的话，那面试中就很可能会被问到。</p>
<p>一位球友之前投稿的面经（社招）中就涉及一些 Disruptor 的问题，文章传送门：<a href="https://mp.weixin.qq.com/s/C5QMjwEb6pzXACqZsyqC4A">圆梦！顺利拿到字节、淘宝、拼多多等大厂 offer！</a> 。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/disruptor-interview-questions.png"></p>
<p>这篇文章可以看作是对 Disruptor 做的一个简单总结，每个问题都不会扯太深入，主要针对面试或者速览 Disruptor。</p>
<h2 id="Disruptor-是什么？"><a href="#Disruptor-是什么？" class="headerlink" title="Disruptor 是什么？"></a>Disruptor 是什么？</h2><p>Disruptor 是一个开源的高性能内存队列，诞生初衷是为了解决内存队列的性能和内存安全问题，由英国外汇交易公司 LMAX 开发。</p>
<p>根据 Disruptor 官方介绍，基于 Disruptor 开发的系统 LMAX（新的零售金融交易平台），单线程就能支撑每秒 600 万订单。Martin Fowler 在 2011 年写的一篇文章 <a href="https://martinfowler.com/articles/lmax.html">The LMAX Architecture</a> 中专门介绍过这个 LMAX 系统的架构，感兴趣的可以看看这篇文章。。</p>
<p>LMAX 公司 2010 年在 QCon 演讲后，Disruptor 获得了业界关注，并获得了 2011 年的 Oracle 官方的 Duke’s Choice Awards(Duke 选择大奖)。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/640.png"></p>
<blockquote>
<p>“Duke 选择大奖”旨在表彰过去一年里全球个人或公司开发的、最具影响力的 Java 技术应用，由甲骨文公司主办。含金量非常高！</p>
</blockquote>
<p>我专门找到了 Oracle 官方当年颁布获得 Duke’s Choice Awards 项目的那篇文章（文章地址：<a href="https://blogs.oracle.com/java/post/and-the-winners-arethe-dukes-choice-award%EF%BC%89">https://blogs.oracle.com/java/post/and-the-winners-arethe-dukes-choice-award）</a> 。从文中可以看出，同年获得此大奖荣誉的还有大名鼎鼎的 Netty、JRebel 等项目。</p>
<p><img src="https://oss.javaguide.cn/javaguide/image-20211015152323898.png" alt="2011 年的 Oracle 官方的 Duke&#39;s Choice Awards"></p>
<p>Disruptor 提供的功能优点类似于 Kafka、RocketMQ 这类分布式队列，不过，其作为范围是 JVM(内存)。</p>
<ul>
<li>Github 地址：<a href="https://github.com/LMAX-Exchange/disruptor">https://github.com/LMAX-Exchange/disruptor</a></li>
<li>官方教程： <a href="https://lmax-exchange.github.io/disruptor/user-guide/index.html">https://lmax-exchange.github.io/disruptor/user-guide/index.html</a></li>
</ul>
<p>关于如何在 Spring Boot 项目中使用 Disruptor，可以看这篇文章：<a href="https://mp.weixin.qq.com/s/0iG5brK3bYF0BgSjX4jRiA">Spring Boot + Disruptor 实战入门</a> 。</p>
<h2 id="为什么要用-Disruptor？"><a href="#为什么要用-Disruptor？" class="headerlink" title="为什么要用 Disruptor？"></a>为什么要用 Disruptor？</h2><p>Disruptor 主要解决了 JDK 内置线程安全队列的性能和内存安全问题。</p>
<p><strong>JDK 中常见的线程安全的队列如下</strong>：</p>
<table>
<thead>
<tr>
<th>队列名字</th>
<th>锁</th>
<th>是否有界</th>
</tr>
</thead>
<tbody><tr>
<td><code>ArrayBlockingQueue</code></td>
<td>加锁（<code>ReentrantLock</code>）</td>
<td>有界</td>
</tr>
<tr>
<td><code>LinkedBlockingQueue</code></td>
<td>加锁（<code>ReentrantLock</code>）</td>
<td>有界</td>
</tr>
<tr>
<td><code>LinkedTransferQueue</code></td>
<td>无锁（<code>CAS</code>）</td>
<td>无界</td>
</tr>
<tr>
<td><code>ConcurrentLinkedQueue</code></td>
<td>无锁（<code>CAS</code>）</td>
<td>无界</td>
</tr>
</tbody></table>
<p>从上表中可以看出：这些队列要不就是加锁有界，要不就是无锁无界。而加锁的的队列势必会影响性能，无界的队列又存在内存溢出的风险。</p>
<p>因此，一般情况下，我们都是不建议使用 JDK 内置线程安全队列。</p>
<p><strong>Disruptor 就不一样了！它在无锁的情况下还能保证队列有界，并且还是线程安全的。</strong></p>
<p>下面这张图是 Disruptor 官网提供的 Disruptor 和 ArrayBlockingQueue 的延迟直方图对比。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/disruptor-latency-histogram.png" alt="disruptor-latency-histogram"></p>
<p>Disruptor 真的很快，关于它为什么这么快这个问题，会在后文介绍到。</p>
<p>此外，Disruptor 还提供了丰富的扩展功能比如支持批量操作、支持多种等待策略。</p>
<h2 id="Kafka-和-Disruptor-什么区别？"><a href="#Kafka-和-Disruptor-什么区别？" class="headerlink" title="Kafka 和 Disruptor 什么区别？"></a>Kafka 和 Disruptor 什么区别？</h2><ul>
<li><strong>Kafka</strong>：分布式消息队列，一般用在系统或者服务之间的消息传递，还可以被用作流式处理平台。</li>
<li><strong>Disruptor</strong>：内存级别的消息队列，一般用在系统内部中线程间的消息传递。</li>
</ul>
<h2 id="哪些组件用到了-Disruptor？"><a href="#哪些组件用到了-Disruptor？" class="headerlink" title="哪些组件用到了 Disruptor？"></a>哪些组件用到了 Disruptor？</h2><p>用到 Disruptor 的开源项目还是挺多的，这里简单举几个例子：</p>
<ul>
<li><strong>Log4j2</strong>：Log4j2 是一款常用的日志框架，它基于 Disruptor 来实现异步日志。</li>
<li><strong>SOFATracer</strong>：SOFATracer 是蚂蚁金服开源的分布式应用链路追踪工具，它基于 Disruptor 来实现异步日志。</li>
<li><strong>Storm</strong> : Storm 是一个开源的分布式实时计算系统，它基于 Disruptor 来实现工作进程内发生的消息传递（同一 Storm 节点上的线程间，无需网络通信）。</li>
<li><strong>HBase</strong>：HBase 是一个分布式列存储数据库系统，它基于 Disruptor 来提高写并发性能。</li>
<li>……</li>
</ul>
<h2 id="Disruptor-核心概念有哪些？"><a href="#Disruptor-核心概念有哪些？" class="headerlink" title="Disruptor 核心概念有哪些？"></a>Disruptor 核心概念有哪些？</h2><ul>
<li><strong>Event</strong>：你可以把 Event 理解为存放在队列中等待消费的消息对象。</li>
<li><strong>EventFactory</strong>：事件工厂用于生产事件，我们在初始化 <code>Disruptor</code> 类的时候需要用到。</li>
<li><strong>EventHandler</strong>：Event 在对应的 Handler 中被处理，你可以将其理解为生产消费者模型中的消费者。</li>
<li><strong>EventProcessor</strong>：EventProcessor 持有特定消费者(Consumer)的 Sequence，并提供用于调用事件处理实现的事件循环(Event Loop)。</li>
<li><strong>Disruptor</strong>：事件的生产和消费需要用到 <code>Disruptor</code> 对象。</li>
<li><strong>RingBuffer</strong>：RingBuffer（环形数组）用于保存事件。</li>
<li><strong>WaitStrategy</strong>：等待策略。决定了没有事件可以消费的时候，事件消费者如何等待新事件的到来。</li>
<li><strong>Producer</strong>：生产者，只是泛指调用 <code>Disruptor</code> 对象发布事件的用户代码，Disruptor 没有定义特定接口或类型。</li>
<li><strong>ProducerType</strong>：指定是单个事件发布者模式还是多个事件发布者模式（发布者和生产者的意思类似，我个人比较喜欢用发布者）。</li>
<li><strong>Sequencer</strong>：Sequencer 是 Disruptor 的真正核心。此接口有两个实现类 <code>SingleProducerSequencer</code>、<code>MultiProducerSequencer</code> ，它们定义在生产者和消费者之间快速、正确地传递数据的并发算法。</li>
</ul>
<p>下面这张图摘自 Disruptor 官网，展示了 LMAX 系统使用 Disruptor 的示例。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/disruptor-models.png" alt="LMAX 系统使用 Disruptor 的示例"></p>
<h2 id="Disruptor-等待策略有哪些？"><a href="#Disruptor-等待策略有哪些？" class="headerlink" title="Disruptor 等待策略有哪些？"></a>Disruptor 等待策略有哪些？</h2><p><strong>等待策略（WaitStrategy）</strong> 决定了没有事件可以消费的时候，事件消费者如何等待新事件的到来。</p>
<p>常见的等待策略有下面这些：</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/DisruptorWaitStrategy.png" alt="Disruptor 等待策略"></p>
<ul>
<li><code>BlockingWaitStrategy</code>：基于 <code>ReentrantLock</code>+<code>Condition</code> 来实现等待和唤醒操作，实现代码非常简单，是 Disruptor 默认的等待策略。虽然最慢，但也是 CPU 使用率最低和最稳定的选项生产环境推荐使用；</li>
<li><code>BusySpinWaitStrategy</code>：性能很好，存在持续自旋的风险，使用不当会造成 CPU 负载 100%，慎用；</li>
<li><code>LiteBlockingWaitStrategy</code>：基于 <code>BlockingWaitStrategy</code> 的轻量级等待策略，在没有锁竞争的时候会省去唤醒操作，但是作者说测试不充分，因此不建议使用;</li>
<li><code>TimeoutBlockingWaitStrategy</code>：带超时的等待策略，超时后会执行业务指定的处理逻辑;</li>
<li><code>LiteTimeoutBlockingWaitStrategy</code>：基于<code>TimeoutBlockingWaitStrategy</code>的策略，当没有锁竞争的时候会省去唤醒操作;</li>
<li><code>SleepingWaitStrategy</code>：三段式策略，第一阶段自旋，第二阶段执行 Thread.yield 让出 CPU，第三阶段睡眠执行时间，反复的睡眠；</li>
<li><code>YieldingWaitStrategy</code>：二段式策略，第一阶段自旋，第二阶段执行 Thread.yield 交出 CPU;</li>
<li><code>PhasedBackoffWaitStrategy</code>：四段式策略，第一阶段自旋指定次数，第二阶段自旋指定时间，第三阶段执行 <code>Thread.yield</code> 交出 CPU，第四阶段调用成员变量的<code>waitFor</code>方法，该成员变量可以被设置为<code>BlockingWaitStrategy</code>、<code>LiteBlockingWaitStrategy</code>、<code>SleepingWaitStrategy</code>三个中的一个。</li>
</ul>
<h2 id="Disruptor-为什么这么快？"><a href="#Disruptor-为什么这么快？" class="headerlink" title="Disruptor 为什么这么快？"></a>Disruptor 为什么这么快？</h2><ul>
<li><strong>RingBuffer（环形数组）</strong> : Disruptor 内部的 RingBuffer 是通过数组实现的。由于这个数组中的所有元素在初始化时一次性全部创建，因此这些元素的内存地址一般来说是连续的。这样做的好处是，当生产者不断往 RingBuffer 中插入新的事件对象时，这些事件对象的内存地址就能够保持连续，从而利用 CPU 缓存的局部性原理，将相邻的事件对象一起加载到缓存中，提高程序的性能。这类似于 MySQL 的预读机制，将连续的几个页预读到内存里。除此之外，RingBuffer 基于数组还支持批量操作（一次处理多个元素）、还可以避免频繁的内存分配和垃圾回收（RingBuffer 是一个固定大小的数组，当向数组中添加新元素时，如果数组已满，则新元素将覆盖掉最旧的元素）。</li>
<li><strong>避免了伪共享问题</strong>：CPU 缓存内部是按照 Cache Line（缓存行）管理的，一般的 Cache Line 大小在 64 字节左右。Disruptor 为了确保目标字段独占一个 Cache Line，会在目标字段前后增加字节填充（前 56 个字节和后 56 个字节），这样可以避免 Cache Line 的伪共享（False Sharing）问题。同时，为了让 RingBuffer 存放数据的数组独占缓存行，数组的设计为 无效填充（128 字节）+ 有效数据。</li>
<li><strong>无锁设计</strong>：Disruptor 采用无锁设计，避免了传统锁机制带来的竞争和延迟。Disruptor 的无锁实现起来比较复杂，主要是基于 CAS、内存屏障（Memory Barrier）、RingBuffer 等技术实现的。</li>
</ul>
<p>综上所述，Disruptor 之所以能够如此快，是基于一系列优化策略的综合作用，既充分利用了现代 CPU 缓存结构的特点，又避免了常见的并发问题和性能瓶颈。</p>
<p>关于 Disruptor 高性能队列原理的详细介绍，可以查看这篇文章：<a href="https://qin.news/disruptor/">Disruptor 高性能队列原理浅析</a> （参考了美团技术团队的<a href="https://tech.meituan.com/2016/11/18/disruptor.html">高性能队列——Disruptor</a>这篇文章）。</p>
<p>🌈 这里额外补充一点：<strong>数组中对象元素地址连续为什么可以提高性能？</strong></p>
<p>CPU 缓存是通过将最近使用的数据存储在高速缓存中来实现更快的读取速度，并使用预取机制提前加载相邻内存的数据以利用局部性原理。</p>
<p>在计算机系统中，CPU 主要访问高速缓存和内存。高速缓存是一种速度非常快、容量相对较小的内存，通常被分为多级缓存，其中 L1、L2、L3 分别表示一级缓存、二级缓存、三级缓存。越靠近 CPU 的缓存，速度越快，容量也越小。相比之下，内存容量相对较大，但速度较慢。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/concurrent/cpu-cache.png" alt="CPU 缓存模型示意图"></p>
<p>为了加速数据的读取过程，CPU 会先将数据从内存中加载到高速缓存中，如果下一次需要访问相同的数据，就可以直接从高速缓存中读取，而不需要再次访问内存。这就是所谓的 <strong>缓存命中</strong> 。另外，为了利用 <strong>局部性原理</strong> ，CPU 还会根据之前访问的内存地址预取相邻的内存数据，因为在程序中，连续的内存地址通常会被频繁访问到，这样做可以提高数据的缓存命中率，进而提高程序的性能。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>Disruptor 高性能之道-等待策略：&lt;<a href="http://wuwenliang.net/2022/02/28/Disruptor">http://wuwenliang.net/2022/02/28/Disruptor</a> 高性能之道-等待策略&#x2F;&gt;</li>
<li>《Java 并发编程实战》- 40 | 案例分析（三）：高性能队列 Disruptor：<a href="https://time.geekbang.org/column/article/98134">https://time.geekbang.org/column/article/98134</a></li>
</ul>
<!-- @include: @article-footer.snippet.md -->

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2024/09/25/sso-intro/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/09/25/sso-intro/" itemprop="url">SSO 单点登录详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-09-25T21:36:02+08:00">
                2024-09-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/WEB/" itemprop="url" rel="index">
                    <span itemprop="name">WEB</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2024/09/25/sso-intro/" class="leancloud_visitors" data-flag-title="SSO 单点登录详解">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.2k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  4 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本文授权转载自：<a href="https://ken.io/note/sso-design-implement">https://ken.io/note/sso-design-implement</a> 作者：ken.io</p>
</blockquote>
<h2 id="SSO-介绍"><a href="#SSO-介绍" class="headerlink" title="SSO 介绍"></a>SSO 介绍</h2><h3 id="什么是-SSO？"><a href="#什么是-SSO？" class="headerlink" title="什么是 SSO？"></a>什么是 SSO？</h3><p>SSO 英文全称 Single Sign On，单点登录。SSO 是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。</p>
<p>例如你登录网易账号中心（<a href="https://reg.163.com/">https://reg.163.com/</a> ）之后访问以下站点都是登录状态。</p>
<ul>
<li>网易直播 <a href="https://v.163.com/">https://v.163.com</a></li>
<li>网易博客 <a href="https://blog.163.com/">https://blog.163.com</a></li>
<li>网易花田 <a href="https://love.163.com/">https://love.163.com</a></li>
<li>网易考拉 <a href="https://www.kaola.com/">https://www.kaola.com</a></li>
<li>网易 Lofter <a href="http://www.lofter.com/">http://www.lofter.com</a></li>
</ul>
<h3 id="SSO-有什么好处？"><a href="#SSO-有什么好处？" class="headerlink" title="SSO 有什么好处？"></a>SSO 有什么好处？</h3><ol>
<li><strong>用户角度</strong> :用户能够做到一次登录多次使用，无需记录多套用户名和密码，省心。</li>
<li><strong>系统管理员角度</strong> : 管理员只需维护好一个统一的账号中心就可以了，方便。</li>
<li><strong>新系统开发角度:</strong> 新系统开发时只需直接对接统一的账号中心即可，简化开发流程，省时。</li>
</ol>
<h2 id="SSO-设计与实现"><a href="#SSO-设计与实现" class="headerlink" title="SSO 设计与实现"></a>SSO 设计与实现</h2><p>本篇文章也主要是为了探讨如何设计&amp;实现一个 SSO 系统</p>
<p>以下为需要实现的核心功能：</p>
<ul>
<li>单点登录</li>
<li>单点登出</li>
<li>支持跨域单点登录</li>
<li>支持跨域单点登出</li>
</ul>
<h3 id="核心应用与依赖"><a href="#核心应用与依赖" class="headerlink" title="核心应用与依赖"></a>核心应用与依赖</h3><p><img src="https://oss.javaguide.cn/github/javaguide/system-design/security/sso/sso-system.png-kblb.png" alt="单点登录（SSO）设计"></p>
<table>
<thead>
<tr>
<th>应用&#x2F;模块&#x2F;对象</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>前台站点</td>
<td>需要登录的站点</td>
</tr>
<tr>
<td>SSO 站点-登录</td>
<td>提供登录的页面</td>
</tr>
<tr>
<td>SSO 站点-登出</td>
<td>提供注销登录的入口</td>
</tr>
<tr>
<td>SSO 服务-登录</td>
<td>提供登录服务</td>
</tr>
<tr>
<td>SSO 服务-登录状态</td>
<td>提供登录状态校验&#x2F;登录信息查询的服务</td>
</tr>
<tr>
<td>SSO 服务-登出</td>
<td>提供用户注销登录的服务</td>
</tr>
<tr>
<td>数据库</td>
<td>存储用户账户信息</td>
</tr>
<tr>
<td>缓存</td>
<td>存储用户的登录信息，通常使用 Redis</td>
</tr>
</tbody></table>
<h3 id="用户登录状态的存储与校验"><a href="#用户登录状态的存储与校验" class="headerlink" title="用户登录状态的存储与校验"></a>用户登录状态的存储与校验</h3><p>常见的 Web 框架对于 Session 的实现都是生成一个 SessionId 存储在浏览器 Cookie 中。然后将 Session 内容存储在服务器端内存中，这个 <a href="https://ken.io/">ken.io</a> 在之前<a href="https://ken.io/note/session-principle-skill">Session 工作原理</a>中也提到过。整体也是借鉴这个思路。</p>
<p>用户登录成功之后，生成 AuthToken 交给客户端保存。如果是浏览器，就保存在 Cookie 中。如果是手机 App 就保存在 App 本地缓存中。本篇主要探讨基于 Web 站点的 SSO。</p>
<p>用户在浏览需要登录的页面时，客户端将 AuthToken 提交给 SSO 服务校验登录状态&#x2F;获取用户登录信息</p>
<p>对于登录信息的存储，建议采用 Redis，使用 Redis 集群来存储登录信息，既可以保证高可用，又可以线性扩充。同时也可以让 SSO 服务满足负载均衡&#x2F;可伸缩的需求。</p>
<table>
<thead>
<tr>
<th>对象</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>AuthToken</td>
<td>直接使用 UUID&#x2F;GUID 即可，如果有验证 AuthToken 合法性需求，可以将 UserName+时间戳加密生成，服务端解密之后验证合法性</td>
</tr>
<tr>
<td>登录信息</td>
<td>通常是将 UserId，UserName 缓存起来</td>
</tr>
</tbody></table>
<h3 id="用户登录-登录校验"><a href="#用户登录-登录校验" class="headerlink" title="用户登录&#x2F;登录校验"></a>用户登录&#x2F;登录校验</h3><p><strong>登录时序图</strong></p>
<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/security/sso/sso-login-sequence.png-kbrb.png" alt="SSO系统设计-登录时序图"></p>
<p>按照上图，用户登录后 AuthToken 保存在 Cookie 中。 domain&#x3D;test.com<br>浏览器会将 domain 设置成 .test.com，</p>
<p>这样访问所有 *.test.com 的 web 站点，都会将 AuthToken 携带到服务器端。<br>然后通过 SSO 服务，完成对用户状态的校验&#x2F;用户登录信息的获取</p>
<p><strong>登录信息获取&#x2F;登录状态校验</strong></p>
<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/security/sso/sso-logincheck-sequence.png-kbrb.png" alt="SSO系统设计-登录信息获取/登录状态校验"></p>
<h3 id="用户登出"><a href="#用户登出" class="headerlink" title="用户登出"></a>用户登出</h3><p>用户登出时要做的事情很简单：</p>
<ol>
<li>服务端清除缓存（Redis）中的登录状态</li>
<li>客户端清除存储的 AuthToken</li>
</ol>
<p><strong>登出时序图</strong></p>
<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/security/sso/sso-logout-sequence.png-kbrb.png" alt="SSO系统设计-用户登出"></p>
<h3 id="跨域登录、登出"><a href="#跨域登录、登出" class="headerlink" title="跨域登录、登出"></a>跨域登录、登出</h3><p>前面提到过，核心思路是客户端存储 AuthToken，服务器端通过 Redis 存储登录信息。由于客户端是将 AuthToken 存储在 Cookie 中的。所以跨域要解决的问题，就是如何解决 Cookie 的跨域读写问题。</p>
<p>解决跨域的核心思路就是：</p>
<ul>
<li>登录完成之后通过回调的方式，将 AuthToken 传递给主域名之外的站点，该站点自行将 AuthToken 保存在当前域下的 Cookie 中。</li>
<li>登出完成之后通过回调的方式，调用非主域名站点的登出页面，完成设置 Cookie 中的 AuthToken 过期的操作。</li>
</ul>
<p><strong>跨域登录（主域名已登录）</strong></p>
<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/security/sso/sso-crossdomain-login-loggedin-sequence.png-kbrb.png" alt="SSO系统设计-跨域登录（主域名已登录）"></p>
<p><strong>跨域登录（主域名未登录）</strong></p>
<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/security/sso/sso-crossdomain-login-unlogin-sequence.png-kbrb.png" alt="SSO系统设计-跨域登录（主域名未登录）"></p>
<p><strong>跨域登出</strong></p>
<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/security/sso/sso-crossdomain-logout-sequence.png-kbrb.png" alt="SSO系统设计-跨域登出"></p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul>
<li>关于方案：这次设计方案更多是提供实现思路。如果涉及到 APP 用户登录等情况，在访问 SSO 服务时，增加对 APP 的签名验证就好了。当然，如果有无线网关，验证签名不是问题。</li>
<li>关于时序图：时序图中并没有包含所有场景，只列举了核心&#x2F;主要场景，另外对于一些不影响理解思路的消息能省就省了。</li>
</ul>
<!-- @include: @article-footer.snippet.md -->

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2024/09/23/sql-questions-04/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/09/23/sql-questions-04/" itemprop="url">SQL常见面试题总结（4）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-09-23T18:26:08+08:00">
                2024-09-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/" itemprop="url" rel="index">
                    <span itemprop="name">面试问题</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2024/09/23/sql-questions-04/" class="leancloud_visitors" data-flag-title="SQL常见面试题总结（4）">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  6.6k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  31 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>题目来源于：<a href="https://www.nowcoder.com/exam/oj?page=1&tab=SQL%E7%AF%87&topicId=240">牛客题霸 - SQL 进阶挑战</a></p>
</blockquote>
<p>较难或者困难的题目可以根据自身实际情况和面试需要来决定是否要跳过。</p>
<h2 id="专用窗口函数"><a href="#专用窗口函数" class="headerlink" title="专用窗口函数"></a>专用窗口函数</h2><p>MySQL 8.0 版本引入了窗口函数的支持，下面是 MySQL 中常见的窗口函数及其用法：</p>
<ol>
<li><code>ROW_NUMBER()</code>: 为查询结果集中的每一行分配一个唯一的整数值。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col1, col2, <span class="built_in">ROW_NUMBER</span>() <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> col1) <span class="keyword">AS</span> row_num</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">table</span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>RANK()</code>: 计算每一行在排序结果中的排名。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col1, col2, <span class="built_in">RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> col1 <span class="keyword">DESC</span>) <span class="keyword">AS</span> ranking</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">table</span>;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>DENSE_RANK()</code>: 计算每一行在排序结果中的排名，保留相同的排名。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col1, col2, <span class="built_in">DENSE_RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> col1 <span class="keyword">DESC</span>) <span class="keyword">AS</span> ranking</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">table</span>;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><code>NTILE(n)</code>: 将结果分成 n 个基本均匀的桶，并为每个桶分配一个标识号。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col1, col2, <span class="built_in">NTILE</span>(<span class="number">4</span>) <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> col1) <span class="keyword">AS</span> bucket</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">table</span>;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><code>SUM()</code>, <code>AVG()</code>,<code>COUNT()</code>, <code>MIN()</code>, <code>MAX()</code>: 这些聚合函数也可以与窗口函数结合使用，计算窗口内指定列的汇总、平均值、计数、最小值和最大值。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col1, col2, <span class="built_in">SUM</span>(col1) <span class="keyword">OVER</span> () <span class="keyword">AS</span> sum_col</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">table</span>;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><code>LEAD()</code> 和 <code>LAG()</code>: LEAD 函数用于获取当前行之后的某个偏移量的行的值，而 LAG 函数用于获取当前行之前的某个偏移量的行的值。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col1, col2, <span class="built_in">LEAD</span>(col1, <span class="number">1</span>) <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> col1) <span class="keyword">AS</span> next_col1,</span><br><span class="line">                 <span class="built_in">LAG</span>(col1, <span class="number">1</span>) <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> col1) <span class="keyword">AS</span> prev_col1</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">table</span>;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li><code>FIRST_VALUE()</code> 和 <code>LAST_VALUE()</code>: FIRST_VALUE 函数用于获取窗口内指定列的第一个值，LAST_VALUE 函数用于获取窗口内指定列的最后一个值。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col1, col2, <span class="built_in">FIRST_VALUE</span>(col2) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> col1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> col2) <span class="keyword">AS</span> first_val,</span><br><span class="line">                 <span class="built_in">LAST_VALUE</span>(col2) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> col1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> col2) <span class="keyword">AS</span> last_val</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">table</span>;</span><br></pre></td></tr></table></figure>

<p>窗口函数通常需要配合 OVER 子句一起使用，用于定义窗口的大小、排序规则和分组方式。</p>
<h3 id="每类试卷得分前三名"><a href="#每类试卷得分前三名" class="headerlink" title="每类试卷得分前三名"></a>每类试卷得分前三名</h3><p><strong>描述</strong>：</p>
<p>现有试卷信息表 <code>examination_info</code>（<code>exam_id</code> 试卷 ID, <code>tag</code> 试卷类别, <code>difficulty</code> 试卷难度, <code>duration</code> 考试时长, <code>release_time</code> 发布时间）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>exam_id</th>
<th>tag</th>
<th>difficulty</th>
<th>duration</th>
<th>release_time</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>9001</td>
<td>SQL</td>
<td>hard</td>
<td>60</td>
<td>2021-09-01 06:00:00</td>
</tr>
<tr>
<td>2</td>
<td>9002</td>
<td>SQL</td>
<td>hard</td>
<td>60</td>
<td>2021-09-01 06:00:00</td>
</tr>
<tr>
<td>3</td>
<td>9003</td>
<td>算法</td>
<td>medium</td>
<td>80</td>
<td>2021-09-01 10:00:00</td>
</tr>
</tbody></table>
<p>试卷作答记录表 <code>exam_record</code>（<code>uid</code> 用户 ID, <code>exam_id</code> 试卷 ID, <code>start_time</code> 开始作答时间, <code>submit_time</code> 交卷时间, score 得分）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>uid</th>
<th>exam_id</th>
<th>start_time</th>
<th>submit_time</th>
<th>score</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1001</td>
<td>9001</td>
<td>2021-09-01 09:01:01</td>
<td>2021-09-01 09:31:00</td>
<td>78</td>
</tr>
<tr>
<td>2</td>
<td>1002</td>
<td>9001</td>
<td>2021-09-01 09:01:01</td>
<td>2021-09-01 09:31:00</td>
<td>81</td>
</tr>
<tr>
<td>3</td>
<td>1002</td>
<td>9002</td>
<td>2021-09-01 12:01:01</td>
<td>2021-09-01 12:31:01</td>
<td>81</td>
</tr>
<tr>
<td>4</td>
<td>1003</td>
<td>9001</td>
<td>2021-09-01 19:01:01</td>
<td>2021-09-01 19:40:01</td>
<td>86</td>
</tr>
<tr>
<td>5</td>
<td>1003</td>
<td>9002</td>
<td>2021-09-01 12:01:01</td>
<td>2021-09-01 12:31:51</td>
<td>89</td>
</tr>
<tr>
<td>6</td>
<td>1004</td>
<td>9001</td>
<td>2021-09-01 19:01:01</td>
<td>2021-09-01 19:30:01</td>
<td>85</td>
</tr>
<tr>
<td>7</td>
<td>1005</td>
<td>9003</td>
<td>2021-09-01 12:01:01</td>
<td>2021-09-01 12:31:02</td>
<td>85</td>
</tr>
<tr>
<td>8</td>
<td>1006</td>
<td>9003</td>
<td>2021-09-07 10:01:01</td>
<td>2021-09-07 10:21:01</td>
<td>84</td>
</tr>
<tr>
<td>9</td>
<td>1003</td>
<td>9003</td>
<td>2021-09-08 12:01:01</td>
<td>2021-09-08 12:11:01</td>
<td>40</td>
</tr>
<tr>
<td>10</td>
<td>1003</td>
<td>9002</td>
<td>2021-09-01 14:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
</tbody></table>
<p>找到每类试卷得分的前 3 名，如果两人最大分数相同，选择最小分数大者，如果还相同，选择 uid 大者。由示例数据结果输出如下：</p>
<table>
<thead>
<tr>
<th>tid</th>
<th>uid</th>
<th>ranking</th>
</tr>
</thead>
<tbody><tr>
<td>SQL</td>
<td>1003</td>
<td>1</td>
</tr>
<tr>
<td>SQL</td>
<td>1004</td>
<td>2</td>
</tr>
<tr>
<td>SQL</td>
<td>1002</td>
<td>3</td>
</tr>
<tr>
<td>算法</td>
<td>1005</td>
<td>1</td>
</tr>
<tr>
<td>算法</td>
<td>1006</td>
<td>2</td>
</tr>
<tr>
<td>算法</td>
<td>1003</td>
<td>3</td>
</tr>
</tbody></table>
<p><strong>解释</strong>：有作答得分记录的试卷 tag 有 SQL 和算法，SQL 试卷用户 1001、1002、1003、1004 有作答得分，最高得分分别为 81、81、89、85，最低得分分别为 78、81、86、40，因此先按最高得分排名再按最低得分排名取前三为 1003、1004、1002。</p>
<p><strong>答案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> tag,</span><br><span class="line">       UID,</span><br><span class="line">       ranking</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  (<span class="keyword">SELECT</span> b.tag <span class="keyword">AS</span> tag,</span><br><span class="line">          a.uid <span class="keyword">AS</span> UID,</span><br><span class="line">          <span class="built_in">ROW_NUMBER</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> b.tag</span><br><span class="line">                             <span class="keyword">ORDER</span> <span class="keyword">BY</span> b.tag,</span><br><span class="line">                                      <span class="built_in">max</span>(a.score) <span class="keyword">DESC</span>,</span><br><span class="line">                                      <span class="built_in">min</span>(a.score) <span class="keyword">DESC</span>,</span><br><span class="line">                                      a.uid <span class="keyword">DESC</span>) <span class="keyword">AS</span> ranking</span><br><span class="line">   <span class="keyword">FROM</span> exam_record a</span><br><span class="line">   <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> examination_info b <span class="keyword">ON</span> a.exam_id <span class="operator">=</span> b.exam_id</span><br><span class="line">   <span class="keyword">GROUP</span> <span class="keyword">BY</span> b.tag,</span><br><span class="line">            a.uid) t</span><br><span class="line"><span class="keyword">WHERE</span> ranking <span class="operator">&lt;=</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h3 id="第二快-慢用时之差大于试卷时长一半的试卷（较难）"><a href="#第二快-慢用时之差大于试卷时长一半的试卷（较难）" class="headerlink" title="第二快&#x2F;慢用时之差大于试卷时长一半的试卷（较难）"></a>第二快&#x2F;慢用时之差大于试卷时长一半的试卷（较难）</h3><p><strong>描述</strong>：</p>
<p>现有试卷信息表 <code>examination_info</code>（<code>exam_id</code> 试卷 ID, <code>tag</code> 试卷类别, <code>difficulty</code> 试卷难度, <code>duration</code> 考试时长, <code>release_time</code> 发布时间）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>exam_id</th>
<th>tag</th>
<th>difficulty</th>
<th>duration</th>
<th>release_time</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>9001</td>
<td>SQL</td>
<td>hard</td>
<td>60</td>
<td>2021-09-01 06:00:00</td>
</tr>
<tr>
<td>2</td>
<td>9002</td>
<td>C++</td>
<td>hard</td>
<td>60</td>
<td>2021-09-01 06:00:00</td>
</tr>
<tr>
<td>3</td>
<td>9003</td>
<td>算法</td>
<td>medium</td>
<td>80</td>
<td>2021-09-01 10:00:00</td>
</tr>
</tbody></table>
<p>试卷作答记录表 <code>exam_record</code>（<code>uid</code> 用户 ID, <code>exam_id</code> 试卷 ID, <code>start_time</code> 开始作答时间, <code>submit_time</code> 交卷时间, <code>score</code> 得分）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>uid</th>
<th>exam_id</th>
<th>start_time</th>
<th>submit_time</th>
<th>score</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1001</td>
<td>9001</td>
<td>2021-09-01 09:01:01</td>
<td>2021-09-01 09:51:01</td>
<td>78</td>
</tr>
<tr>
<td>2</td>
<td>1001</td>
<td>9002</td>
<td>2021-09-01 09:01:01</td>
<td>2021-09-01 09:31:00</td>
<td>81</td>
</tr>
<tr>
<td>3</td>
<td>1002</td>
<td>9002</td>
<td>2021-09-01 12:01:01</td>
<td>2021-09-01 12:31:01</td>
<td>81</td>
</tr>
<tr>
<td>4</td>
<td>1003</td>
<td>9001</td>
<td>2021-09-01 19:01:01</td>
<td>2021-09-01 19:59:01</td>
<td>86</td>
</tr>
<tr>
<td>5</td>
<td>1003</td>
<td>9002</td>
<td>2021-09-01 12:01:01</td>
<td>2021-09-01 12:31:51</td>
<td>89</td>
</tr>
<tr>
<td>6</td>
<td>1004</td>
<td>9002</td>
<td>2021-09-01 19:01:01</td>
<td>2021-09-01 19:30:01</td>
<td>85</td>
</tr>
<tr>
<td>7</td>
<td>1005</td>
<td>9001</td>
<td>2021-09-01 12:01:01</td>
<td>2021-09-01 12:31:02</td>
<td>85</td>
</tr>
<tr>
<td>8</td>
<td>1006</td>
<td>9001</td>
<td>2021-09-07 10:02:01</td>
<td>2021-09-07 10:21:01</td>
<td>84</td>
</tr>
<tr>
<td>9</td>
<td>1003</td>
<td>9001</td>
<td>2021-09-08 12:01:01</td>
<td>2021-09-08 12:11:01</td>
<td>40</td>
</tr>
<tr>
<td>10</td>
<td>1003</td>
<td>9002</td>
<td>2021-09-01 14:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>11</td>
<td>1005</td>
<td>9001</td>
<td>2021-09-01 14:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>12</td>
<td>1003</td>
<td>9003</td>
<td>2021-09-08 15:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
</tbody></table>
<p>找到第二快和第二慢用时之差大于试卷时长的一半的试卷信息，按试卷 ID 降序排序。由示例数据结果输出如下：</p>
<table>
<thead>
<tr>
<th>exam_id</th>
<th>duration</th>
<th>release_time</th>
</tr>
</thead>
<tbody><tr>
<td>9001</td>
<td>60</td>
<td>2021-09-01 06:00:00</td>
</tr>
</tbody></table>
<p><strong>解释</strong>：试卷 9001 被作答用时有 50 分钟、58 分钟、30 分 1 秒、19 分钟、10 分钟，第二快和第二慢用时之差为 50 分钟-19 分钟&#x3D;31 分钟，试卷时长为 60 分钟，因此满足大于试卷时长一半的条件，输出试卷 ID、时长、发布时间。</p>
<p><strong>思路：</strong></p>
<p>第一步，找到每张试卷完成时间的顺序排名和倒序排名 也就是表 a；</p>
<p>第二步，与通过试卷信息表 b 建立内连接，并根据试卷 id 分组，利用<code>having</code>筛选排名为第二个数据，将秒转化为分钟并进行比较，最后再根据试卷 id 倒序排序就行</p>
<p><strong>答案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.exam_id,</span><br><span class="line">       b.duration,</span><br><span class="line">       b.release_time</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  (<span class="keyword">SELECT</span> exam_id,</span><br><span class="line">          <span class="built_in">row_number</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> exam_id</span><br><span class="line">                             <span class="keyword">ORDER</span> <span class="keyword">BY</span> timestampdiff(<span class="keyword">SECOND</span>, start_time, submit_time) <span class="keyword">DESC</span>) rn1,</span><br><span class="line">          <span class="built_in">row_number</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> exam_id</span><br><span class="line">                            <span class="keyword">ORDER</span> <span class="keyword">BY</span> timestampdiff(<span class="keyword">SECOND</span>, start_time, submit_time) <span class="keyword">ASC</span>) rn2,</span><br><span class="line">                                              timestampdiff(<span class="keyword">SECOND</span>, start_time, submit_time) timex</span><br><span class="line">   <span class="keyword">FROM</span> exam_record</span><br><span class="line">   <span class="keyword">WHERE</span> score <span class="keyword">IS</span> <span class="keyword">NOT NULL</span> ) a</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> examination_info b <span class="keyword">ON</span> a.exam_id <span class="operator">=</span> b.exam_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> a.exam_id</span><br><span class="line"><span class="keyword">HAVING</span> (<span class="built_in">max</span>(IF (rn1 <span class="operator">=</span> <span class="number">2</span>, a.timex, <span class="number">0</span>))<span class="operator">-</span> <span class="built_in">max</span>(IF (rn2 <span class="operator">=</span> <span class="number">2</span>, a.timex, <span class="number">0</span>)))<span class="operator">/</span> <span class="number">60</span> <span class="operator">&gt;</span> b.duration <span class="operator">/</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> a.exam_id <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>

<h3 id="连续两次作答试卷的最大时间窗（较难）"><a href="#连续两次作答试卷的最大时间窗（较难）" class="headerlink" title="连续两次作答试卷的最大时间窗（较难）"></a>连续两次作答试卷的最大时间窗（较难）</h3><p><strong>描述</strong></p>
<p>现有试卷作答记录表 <code>exam_record</code>（<code>uid</code> 用户 ID, <code>exam_id</code> 试卷 ID, <code>start_time</code> 开始作答时间, <code>submit_time</code> 交卷时间, <code>score</code> 得分）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>uid</th>
<th>exam_id</th>
<th>start_time</th>
<th>submit_time</th>
<th>score</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1006</td>
<td>9003</td>
<td>2021-09-07 10:01:01</td>
<td>2021-09-07 10:21:02</td>
<td>84</td>
</tr>
<tr>
<td>2</td>
<td>1006</td>
<td>9001</td>
<td>2021-09-01 12:11:01</td>
<td>2021-09-01 12:31:01</td>
<td>89</td>
</tr>
<tr>
<td>3</td>
<td>1006</td>
<td>9002</td>
<td>2021-09-06 10:01:01</td>
<td>2021-09-06 10:21:01</td>
<td>81</td>
</tr>
<tr>
<td>4</td>
<td>1005</td>
<td>9002</td>
<td>2021-09-05 10:01:01</td>
<td>2021-09-05 10:21:01</td>
<td>81</td>
</tr>
<tr>
<td>5</td>
<td>1005</td>
<td>9001</td>
<td>2021-09-05 10:31:01</td>
<td>2021-09-05 10:51:01</td>
<td>81</td>
</tr>
</tbody></table>
<p>请计算在 2021 年至少有两天作答过试卷的人中，计算该年连续两次作答试卷的最大时间窗 <code>days_window</code>，那么根据该年的历史规律他在 <code>days_window</code> 天里平均会做多少套试卷，按最大时间窗和平均做答试卷套数倒序排序。由示例数据结果输出如下：</p>
<table>
<thead>
<tr>
<th>uid</th>
<th>days_window</th>
<th>avg_exam_cnt</th>
</tr>
</thead>
<tbody><tr>
<td>1006</td>
<td>6</td>
<td>2.57</td>
</tr>
</tbody></table>
<p><strong>解释</strong>：用户 1006 分别在 20210901、20210906、20210907 作答过 3 次试卷，连续两次作答最大时间窗为 6 天（1 号到 6 号），他 1 号到 7 号这 7 天里共做了 3 张试卷，平均每天 3&#x2F;7&#x3D;0.428571 张，那么 6 天里平均会做 0.428571*6&#x3D;2.57 张试卷（保留两位小数）；用户 1005 在 20210905 做了两张试卷，但是只有一天的作答记录，过滤掉。</p>
<p><strong>思路：</strong></p>
<p>上面这个解释中提示要对作答记录去重，千万别被骗了，不要去重！去重就通不过测试用例。注意限制时间是 2021 年；</p>
<p>而且要注意时间差要+1 天；还要注意&#x3D;&#x3D;没交卷也算在内&#x3D;&#x3D;！！！！ （反正感觉这题描述不清，出的不是很好）</p>
<p><strong>答案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> UID,</span><br><span class="line">       <span class="built_in">max</span>(datediff(next_time, start_time)) <span class="operator">+</span> <span class="number">1</span> <span class="keyword">AS</span> days_window,</span><br><span class="line">       round(<span class="built_in">count</span>(start_time)<span class="operator">/</span>(datediff(<span class="built_in">max</span>(start_time), <span class="built_in">min</span>(start_time))<span class="operator">+</span> <span class="number">1</span>) <span class="operator">*</span> (<span class="built_in">max</span>(datediff(next_time, start_time))<span class="operator">+</span> <span class="number">1</span>), <span class="number">2</span>) <span class="keyword">AS</span> avg_exam_cnt</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  (<span class="keyword">SELECT</span> UID,</span><br><span class="line">          start_time,</span><br><span class="line">          <span class="built_in">lead</span>(start_time, <span class="number">1</span>) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> UID</span><br><span class="line">                                    <span class="keyword">ORDER</span> <span class="keyword">BY</span> start_time) <span class="keyword">AS</span> next_time</span><br><span class="line">   <span class="keyword">FROM</span> exam_record</span><br><span class="line">   <span class="keyword">WHERE</span> <span class="keyword">YEAR</span> (start_time) <span class="operator">=</span> <span class="string">&#x27;2021&#x27;</span> ) a</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> UID</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">count</span>(<span class="keyword">DISTINCT</span> <span class="type">date</span>(start_time)) <span class="operator">&gt;</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> days_window <span class="keyword">DESC</span>,</span><br><span class="line">         avg_exam_cnt <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>

<h3 id="近三个月未完成为-0-的用户完成情况"><a href="#近三个月未完成为-0-的用户完成情况" class="headerlink" title="近三个月未完成为 0 的用户完成情况"></a>近三个月未完成为 0 的用户完成情况</h3><p><strong>描述</strong>：</p>
<p>现有试卷作答记录表 <code>exam_record</code>（<code>uid</code>:用户 ID, <code>exam_id</code>:试卷 ID, <code>start_time</code>:开始作答时间, <code>submit_time</code>:交卷时间，为空的话则代表未完成, <code>score</code>:得分）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>uid</th>
<th>exam_id</th>
<th>start_time</th>
<th>submit_time</th>
<th>score</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1006</td>
<td>9003</td>
<td>2021-09-06 10:01:01</td>
<td>2021-09-06 10:21:02</td>
<td>84</td>
</tr>
<tr>
<td>2</td>
<td>1006</td>
<td>9001</td>
<td>2021-08-02 12:11:01</td>
<td>2021-08-02 12:31:01</td>
<td>89</td>
</tr>
<tr>
<td>3</td>
<td>1006</td>
<td>9002</td>
<td>2021-06-06 10:01:01</td>
<td>2021-06-06 10:21:01</td>
<td>81</td>
</tr>
<tr>
<td>4</td>
<td>1006</td>
<td>9002</td>
<td>2021-05-06 10:01:01</td>
<td>2021-05-06 10:21:01</td>
<td>81</td>
</tr>
<tr>
<td>5</td>
<td>1006</td>
<td>9001</td>
<td>2021-05-01 12:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>6</td>
<td>1001</td>
<td>9001</td>
<td>2021-09-05 10:31:01</td>
<td>2021-09-05 10:51:01</td>
<td>81</td>
</tr>
<tr>
<td>7</td>
<td>1001</td>
<td>9003</td>
<td>2021-08-01 09:01:01</td>
<td>2021-08-01 09:51:11</td>
<td>78</td>
</tr>
<tr>
<td>8</td>
<td>1001</td>
<td>9002</td>
<td>2021-07-01 09:01:01</td>
<td>2021-07-01 09:31:00</td>
<td>81</td>
</tr>
<tr>
<td>9</td>
<td>1001</td>
<td>9002</td>
<td>2021-07-01 12:01:01</td>
<td>2021-07-01 12:31:01</td>
<td>81</td>
</tr>
<tr>
<td>10</td>
<td>1001</td>
<td>9002</td>
<td>2021-07-01 12:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
</tbody></table>
<p>找到每个人近三个有试卷作答记录的月份中没有试卷是未完成状态的用户的试卷作答完成数，按试卷完成数和用户 ID 降序排名。由示例数据结果输出如下：</p>
<table>
<thead>
<tr>
<th>uid</th>
<th>exam_complete_cnt</th>
</tr>
</thead>
<tbody><tr>
<td>1006</td>
<td>3</td>
</tr>
</tbody></table>
<p><strong>解释</strong>：用户 1006 近三个有作答试卷的月份为 202109、202108、202106，作答试卷数为 3，全部完成；用户 1001 近三个有作答试卷的月份为 202109、202108、202107，作答试卷数为 5，完成试卷数为 4，因为有未完成试卷，故过滤掉。</p>
<p><strong>思路:</strong></p>
<ol>
<li><code>找到每个人近三个有试卷作答记录的月份中没有试卷是未完成状态的用户的试卷作答完成数</code>首先看这句话，肯定要先根据人进行分组</li>
<li>最近三个月，可以采用连续重复排名，倒序排列，排名&lt;&#x3D;3</li>
<li>统计作答数</li>
<li>拼装剩余条件</li>
<li>排序</li>
</ol>
<p><strong>答案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> UID,</span><br><span class="line">       <span class="built_in">count</span>(score) exam_complete_cnt</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  (<span class="keyword">SELECT</span> <span class="operator">*</span>, <span class="built_in">DENSE_RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> UID</span><br><span class="line">                             <span class="keyword">ORDER</span> <span class="keyword">BY</span> date_format(start_time, <span class="string">&#x27;%Y%m&#x27;</span>) <span class="keyword">DESC</span>) dr</span><br><span class="line">   <span class="keyword">FROM</span> exam_record) t1</span><br><span class="line"><span class="keyword">WHERE</span> dr <span class="operator">&lt;=</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> UID</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">count</span>(dr)<span class="operator">=</span> <span class="built_in">count</span>(score)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> exam_complete_cnt <span class="keyword">DESC</span>,</span><br><span class="line">         UID <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>

<h3 id="未完成率较高的-50-用户近三个月答卷情况（困难）"><a href="#未完成率较高的-50-用户近三个月答卷情况（困难）" class="headerlink" title="未完成率较高的 50%用户近三个月答卷情况（困难）"></a>未完成率较高的 50%用户近三个月答卷情况（困难）</h3><p><strong>描述</strong>：</p>
<p>现有用户信息表 <code>user_info</code>（<code>uid</code> 用户 ID，<code>nick_name</code> 昵称, <code>achievement</code> 成就值, <code>level</code> 等级, <code>job</code> 职业方向, <code>register_time</code> 注册时间）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>uid</th>
<th>nick_name</th>
<th>achievement</th>
<th>level</th>
<th>job</th>
<th>register_time</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1001</td>
<td>牛客 1 号</td>
<td>3200</td>
<td>7</td>
<td>算法</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>2</td>
<td>1002</td>
<td>牛客 2 号</td>
<td>2500</td>
<td>6</td>
<td>算法</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>3</td>
<td>1003</td>
<td>牛客 3 号 ♂</td>
<td>2200</td>
<td>5</td>
<td>算法</td>
<td>2020-01-01 10:00:00</td>
</tr>
</tbody></table>
<p>试卷信息表 <code>examination_info</code>（<code>exam_id</code> 试卷 ID, <code>tag</code> 试卷类别, <code>difficulty</code> 试卷难度, <code>duration</code> 考试时长, <code>release_time</code> 发布时间）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>exam_id</th>
<th>tag</th>
<th>difficulty</th>
<th>duration</th>
<th>release_time</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>9001</td>
<td>SQL</td>
<td>hard</td>
<td>60</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>2</td>
<td>9002</td>
<td>SQL</td>
<td>hard</td>
<td>80</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>3</td>
<td>9003</td>
<td>算法</td>
<td>hard</td>
<td>80</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>4</td>
<td>9004</td>
<td>PYTHON</td>
<td>medium</td>
<td>70</td>
<td>2020-01-01 10:00:00</td>
</tr>
</tbody></table>
<p>试卷作答记录表 <code>exam_record</code>（<code>uid</code> 用户 ID, <code>exam_id</code> 试卷 ID, <code>start_time</code> 开始作答时间, <code>submit_time</code> 交卷时间, <code>score</code> 得分）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>uid</th>
<th>exam_id</th>
<th>start_time</th>
<th>submit_time</th>
<th>score</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1001</td>
<td>9001</td>
<td>2020-01-01 09:01:01</td>
<td>2020-01-01 09:21:59</td>
<td>90</td>
</tr>
<tr>
<td>15</td>
<td>1002</td>
<td>9001</td>
<td>2020-01-01 18:01:01</td>
<td>2020-01-01 18:59:02</td>
<td>90</td>
</tr>
<tr>
<td>13</td>
<td>1001</td>
<td>9001</td>
<td>2020-01-02 10:01:01</td>
<td>2020-01-02 10:31:01</td>
<td>89</td>
</tr>
<tr>
<td>2</td>
<td>1002</td>
<td>9001</td>
<td>2020-01-20 10:01:01</td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>1002</td>
<td>9001</td>
<td>2020-02-01 12:11:01</td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>1001</td>
<td>9001</td>
<td>2020-03-01 12:01:01</td>
<td></td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>1002</td>
<td>9001</td>
<td>2020-03-01 12:01:01</td>
<td>2020-03-01 12:41:01</td>
<td>90</td>
</tr>
<tr>
<td>4</td>
<td>1003</td>
<td>9001</td>
<td>2020-03-01 19:01:01</td>
<td></td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>1002</td>
<td>9001</td>
<td>2020-05-02 19:01:01</td>
<td>2020-05-02 19:32:00</td>
<td>90</td>
</tr>
<tr>
<td>14</td>
<td>1001</td>
<td>9002</td>
<td>2020-01-01 12:11:01</td>
<td></td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>1001</td>
<td>9002</td>
<td>2020-01-02 19:01:01</td>
<td>2020-01-02 19:59:01</td>
<td>69</td>
</tr>
<tr>
<td>9</td>
<td>1001</td>
<td>9002</td>
<td>2020-02-02 12:01:01</td>
<td>2020-02-02 12:20:01</td>
<td>99</td>
</tr>
<tr>
<td>10</td>
<td>1002</td>
<td>9002</td>
<td>2020-02-02 12:01:01</td>
<td></td>
<td></td>
</tr>
<tr>
<td>11</td>
<td>1002</td>
<td>9002</td>
<td>2020-02-02 12:01:01</td>
<td>2020-02-02 12:43:01</td>
<td>81</td>
</tr>
<tr>
<td>12</td>
<td>1002</td>
<td>9002</td>
<td>2020-03-02 12:11:01</td>
<td></td>
<td></td>
</tr>
<tr>
<td>17</td>
<td>1001</td>
<td>9002</td>
<td>2020-05-05 18:01:01</td>
<td></td>
<td></td>
</tr>
<tr>
<td>16</td>
<td>1002</td>
<td>9003</td>
<td>2020-05-06 12:01:01</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>请统计 SQL 试卷上未完成率较高的 50%用户中，6 级和 7 级用户在有试卷作答记录的近三个月中，每个月的答卷数目和完成数目。按用户 ID、月份升序排序。</p>
<p>由示例数据结果输出如下：</p>
<table>
<thead>
<tr>
<th>uid</th>
<th>start_month</th>
<th>total_cnt</th>
<th>complete_cnt</th>
</tr>
</thead>
<tbody><tr>
<td>1002</td>
<td>202002</td>
<td>3</td>
<td>1</td>
</tr>
<tr>
<td>1002</td>
<td>202003</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>1002</td>
<td>202005</td>
<td>2</td>
<td>1</td>
</tr>
</tbody></table>
<p>解释：各个用户对 SQL 试卷的未完成数、作答总数、未完成率如下：</p>
<table>
<thead>
<tr>
<th>uid</th>
<th>incomplete_cnt</th>
<th>total_cnt</th>
<th>incomplete_rate</th>
</tr>
</thead>
<tbody><tr>
<td>1001</td>
<td>3</td>
<td>7</td>
<td>0.4286</td>
</tr>
<tr>
<td>1002</td>
<td>4</td>
<td>8</td>
<td>0.5000</td>
</tr>
<tr>
<td>1003</td>
<td>1</td>
<td>1</td>
<td>1.0000</td>
</tr>
</tbody></table>
<p>1001、1002、1003 分别排在 1.0、0.5、0.0 的位置，因此较高的 50%用户（排位&lt;&#x3D;0.5）为 1002、1003；</p>
<p>1003 不是 6 级或 7 级；</p>
<p>有试卷作答记录的近三个月为 202005、202003、202002；</p>
<p>这三个月里 1002 的作答题数分别为 3、2、2，完成数目分别为 1、1、1。</p>
<p><strong>思路：</strong></p>
<p>注意点：这题注意求的是所有的答题次数和完成次数，而 sql 类别的试卷是限制未完成率排名，6, 7 级用户限制的是做题记录。</p>
<p>先求出未完成率的排名</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> UID,</span><br><span class="line">       <span class="built_in">count</span>(submit_time <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line">             <span class="keyword">OR</span> <span class="keyword">NULL</span>)<span class="operator">/</span> <span class="built_in">count</span>(start_time) <span class="keyword">AS</span> num,</span><br><span class="line">       <span class="built_in">PERCENT_RANK</span>() <span class="keyword">OVER</span> (</span><br><span class="line">                            <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">count</span>(submit_time <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line">                                           <span class="keyword">OR</span> <span class="keyword">NULL</span>)<span class="operator">/</span> <span class="built_in">count</span>(start_time)) <span class="keyword">AS</span> ranking</span><br><span class="line"><span class="keyword">FROM</span> exam_record</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> examination_info <span class="keyword">USING</span> (exam_id)</span><br><span class="line"><span class="keyword">WHERE</span> tag <span class="operator">=</span> <span class="string">&#x27;SQL&#x27;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> UID</span><br></pre></td></tr></table></figure>

<p>再求出最近三个月的练习记录</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> UID,</span><br><span class="line">       date_format(start_time, <span class="string">&#x27;%Y%m&#x27;</span>) <span class="keyword">AS</span> month_d,</span><br><span class="line">       submit_time,</span><br><span class="line">       exam_id,</span><br><span class="line">       <span class="built_in">dense_rank</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> UID</span><br><span class="line">                          <span class="keyword">ORDER</span> <span class="keyword">BY</span> date_format(start_time, <span class="string">&#x27;%Y%m&#x27;</span>) <span class="keyword">DESC</span>) <span class="keyword">AS</span> ranking</span><br><span class="line"><span class="keyword">FROM</span> exam_record</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> user_info <span class="keyword">USING</span> (UID)</span><br><span class="line"><span class="keyword">WHERE</span> LEVEL <span class="keyword">IN</span> (<span class="number">6</span>,<span class="number">7</span>)</span><br></pre></td></tr></table></figure>

<p><strong>答案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> t1.uid,</span><br><span class="line">       t1.month_d,</span><br><span class="line">       <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">AS</span> total_cnt,</span><br><span class="line">       <span class="built_in">count</span>(t1.submit_time) <span class="keyword">AS</span> complete_cnt</span><br><span class="line"><span class="keyword">FROM</span><span class="comment">-- 先求出未完成率的排名</span></span><br><span class="line"></span><br><span class="line">  (<span class="keyword">SELECT</span> UID,</span><br><span class="line">          <span class="built_in">count</span>(submit_time <span class="keyword">IS</span> <span class="keyword">NULL</span> <span class="keyword">OR</span> <span class="keyword">NULL</span>)<span class="operator">/</span> <span class="built_in">count</span>(start_time) <span class="keyword">AS</span> num,</span><br><span class="line">          <span class="built_in">PERCENT_RANK</span>() <span class="keyword">OVER</span> (</span><br><span class="line">                               <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">count</span>(submit_time <span class="keyword">IS</span> <span class="keyword">NULL</span> <span class="keyword">OR</span> <span class="keyword">NULL</span>)<span class="operator">/</span> <span class="built_in">count</span>(start_time)) <span class="keyword">AS</span> ranking</span><br><span class="line">   <span class="keyword">FROM</span> exam_record</span><br><span class="line">   <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> examination_info <span class="keyword">USING</span> (exam_id)</span><br><span class="line">   <span class="keyword">WHERE</span> tag <span class="operator">=</span> <span class="string">&#x27;SQL&#x27;</span></span><br><span class="line">   <span class="keyword">GROUP</span> <span class="keyword">BY</span> UID) t</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span></span><br><span class="line">  (<span class="comment">-- 再求出近三个月的练习记录</span></span><br><span class="line"> <span class="keyword">SELECT</span> UID,</span><br><span class="line">        date_format(start_time, <span class="string">&#x27;%Y%m&#x27;</span>) <span class="keyword">AS</span> month_d,</span><br><span class="line">        submit_time,</span><br><span class="line">        exam_id,</span><br><span class="line">        <span class="built_in">dense_rank</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> UID</span><br><span class="line">                           <span class="keyword">ORDER</span> <span class="keyword">BY</span> date_format(start_time, <span class="string">&#x27;%Y%m&#x27;</span>) <span class="keyword">DESC</span>) <span class="keyword">AS</span> ranking</span><br><span class="line">   <span class="keyword">FROM</span> exam_record</span><br><span class="line">   <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> user_info <span class="keyword">USING</span> (UID)</span><br><span class="line">   <span class="keyword">WHERE</span> LEVEL <span class="keyword">IN</span> (<span class="number">6</span>,<span class="number">7</span>) ) t1 <span class="keyword">USING</span> (UID)</span><br><span class="line"><span class="keyword">WHERE</span> t1.ranking <span class="operator">&lt;=</span> <span class="number">3</span> <span class="keyword">AND</span> t.ranking <span class="operator">&gt;=</span> <span class="number">0.5</span> <span class="comment">-- 使用限制找到符合条件的记录</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> t1.uid,</span><br><span class="line">         t1.month_d</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> t1.uid,</span><br><span class="line">         t1.month_d</span><br></pre></td></tr></table></figure>

<h3 id="试卷完成数同比-2020-年的增长率及排名变化（困难）"><a href="#试卷完成数同比-2020-年的增长率及排名变化（困难）" class="headerlink" title="试卷完成数同比 2020 年的增长率及排名变化（困难）"></a>试卷完成数同比 2020 年的增长率及排名变化（困难）</h3><p><strong>描述</strong>：</p>
<p>现有试卷信息表 <code>examination_info</code>（<code>exam_id</code> 试卷 ID, <code>tag</code> 试卷类别, <code>difficulty</code> 试卷难度, <code>duration</code> 考试时长, <code>release_time</code> 发布时间）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>exam_id</th>
<th>tag</th>
<th>difficulty</th>
<th>duration</th>
<th>release_time</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>9001</td>
<td>SQL</td>
<td>hard</td>
<td>60</td>
<td>2021-01-01 10:00:00</td>
</tr>
<tr>
<td>2</td>
<td>9002</td>
<td>C++</td>
<td>hard</td>
<td>80</td>
<td>2021-01-01 10:00:00</td>
</tr>
<tr>
<td>3</td>
<td>9003</td>
<td>算法</td>
<td>hard</td>
<td>80</td>
<td>2021-01-01 10:00:00</td>
</tr>
<tr>
<td>4</td>
<td>9004</td>
<td>PYTHON</td>
<td>medium</td>
<td>70</td>
<td>2021-01-01 10:00:00</td>
</tr>
</tbody></table>
<p>试卷作答记录表 <code>exam_record</code>（<code>uid</code> 用户 ID, <code>exam_id</code> 试卷 ID, <code>start_time</code> 开始作答时间, <code>submit_time</code> 交卷时间, <code>score</code> 得分）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>uid</th>
<th>exam_id</th>
<th>start_time</th>
<th>submit_time</th>
<th>score</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1001</td>
<td>9001</td>
<td>2020-08-02 10:01:01</td>
<td>2020-08-02 10:31:01</td>
<td>89</td>
</tr>
<tr>
<td>2</td>
<td>1002</td>
<td>9001</td>
<td>2020-04-01 18:01:01</td>
<td>2020-04-01 18:59:02</td>
<td>90</td>
</tr>
<tr>
<td>3</td>
<td>1001</td>
<td>9001</td>
<td>2020-04-01 09:01:01</td>
<td>2020-04-01 09:21:59</td>
<td>80</td>
</tr>
<tr>
<td>5</td>
<td>1002</td>
<td>9001</td>
<td>2021-03-02 19:01:01</td>
<td>2021-03-02 19:32:00</td>
<td>20</td>
</tr>
<tr>
<td>8</td>
<td>1003</td>
<td>9001</td>
<td>2021-05-02 12:01:01</td>
<td>2021-05-02 12:31:01</td>
<td>98</td>
</tr>
<tr>
<td>13</td>
<td>1003</td>
<td>9001</td>
<td>2020-01-02 10:01:01</td>
<td>2020-01-02 10:31:01</td>
<td>89</td>
</tr>
<tr>
<td>9</td>
<td>1001</td>
<td>9002</td>
<td>2020-02-02 12:01:01</td>
<td>2020-02-02 12:20:01</td>
<td>99</td>
</tr>
<tr>
<td>10</td>
<td>1002</td>
<td>9002</td>
<td>2021-02-02 12:01:01</td>
<td>2020-02-02 12:43:01</td>
<td>81</td>
</tr>
<tr>
<td>11</td>
<td>1001</td>
<td>9002</td>
<td>2020-01-02 19:01:01</td>
<td>2020-01-02 19:59:01</td>
<td>69</td>
</tr>
<tr>
<td>16</td>
<td>1002</td>
<td>9002</td>
<td>2020-02-02 12:01:01</td>
<td></td>
<td></td>
</tr>
<tr>
<td>17</td>
<td>1002</td>
<td>9002</td>
<td>2020-03-02 12:11:01</td>
<td></td>
<td></td>
</tr>
<tr>
<td>18</td>
<td>1001</td>
<td>9002</td>
<td>2021-05-05 18:01:01</td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>1002</td>
<td>9003</td>
<td>2021-01-20 10:01:01</td>
<td>2021-01-20 10:10:01</td>
<td>81</td>
</tr>
<tr>
<td>6</td>
<td>1001</td>
<td>9003</td>
<td>2021-04-02 19:01:01</td>
<td>2021-04-02 19:40:01</td>
<td>89</td>
</tr>
<tr>
<td>15</td>
<td>1002</td>
<td>9003</td>
<td>2021-01-01 18:01:01</td>
<td>2021-01-01 18:59:02</td>
<td>90</td>
</tr>
<tr>
<td>7</td>
<td>1004</td>
<td>9004</td>
<td>2020-05-02 12:01:01</td>
<td>2020-05-02 12:20:01</td>
<td>99</td>
</tr>
<tr>
<td>12</td>
<td>1001</td>
<td>9004</td>
<td>2021-09-02 12:11:01</td>
<td></td>
<td></td>
</tr>
<tr>
<td>14</td>
<td>1002</td>
<td>9004</td>
<td>2020-01-01 12:11:01</td>
<td>2020-01-01 12:31:01</td>
<td>83</td>
</tr>
</tbody></table>
<p>请计算 2021 年上半年各类试卷的做完次数相比 2020 年上半年同期的增长率（百分比格式，保留 1 位小数），以及做完次数排名变化，按增长率和 21 年排名降序输出。</p>
<p>由示例数据结果输出如下：</p>
<table>
<thead>
<tr>
<th>tag</th>
<th>exam_cnt_20</th>
<th>exam_cnt_21</th>
<th>growth_rate</th>
<th>exam_cnt_rank_20</th>
<th>exam_cnt_rank_21</th>
<th>rank_delta</th>
</tr>
</thead>
<tbody><tr>
<td>SQL</td>
<td>3</td>
<td>2</td>
<td>-33.3%</td>
<td>1</td>
<td>2</td>
<td>1</td>
</tr>
</tbody></table>
<p>解释：2020 年上半年有 3 个 tag 有作答完成的记录，分别是 C++、SQL、PYTHON，它们被做完的次数分别是 3、3、2，做完次数排名为 1、1（并列）、3；</p>
<p>2021 年上半年有 2 个 tag 有作答完成的记录，分别是算法、SQL，它们被做完的次数分别是 3、2，做完次数排名为 1、2；具体如下：</p>
<table>
<thead>
<tr>
<th>tag</th>
<th>start_year</th>
<th>exam_cnt</th>
<th>exam_cnt_rank</th>
</tr>
</thead>
<tbody><tr>
<td>C++</td>
<td>2020</td>
<td>3</td>
<td>1</td>
</tr>
<tr>
<td>SQL</td>
<td>2020</td>
<td>3</td>
<td>1</td>
</tr>
<tr>
<td>PYTHON</td>
<td>2020</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>算法</td>
<td>2021</td>
<td>3</td>
<td>1</td>
</tr>
<tr>
<td>SQL</td>
<td>2021</td>
<td>2</td>
<td>2</td>
</tr>
</tbody></table>
<p>因此能输出同比结果的 tag 只有 SQL，从 2020 到 2021 年，做完次数 3&#x3D;&gt;2，减少 33.3%（保留 1 位小数）；排名 1&#x3D;&gt;2，后退 1 名。</p>
<p><strong>思路：</strong></p>
<p>本题难点在于长整型的数据类型要求不能有负号产生，用 cast 函数转换数据类型为 signed。</p>
<p>以及用到的<code>增长率计算公式：(exam_cnt_21-exam_cnt_20)/exam_cnt_20</code></p>
<p>做完次数排名变化（2021 年和 2020 年比排名升了或者降了多少）</p>
<p>计算公式：<code>exam_cnt_rank_21 - exam_cnt_rank_20</code></p>
<p>在 MySQL 中，<code>CAST()</code> 函数用于将一个表达式的数据类型转换为另一个数据类型。它的基本语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CAST</span>(expression <span class="keyword">AS</span> data_type)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将一个字符串转换成整数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CAST</span>(<span class="string">&#x27;123&#x27;</span> <span class="keyword">AS</span> <span class="type">INT</span>);</span><br></pre></td></tr></table></figure>

<p>示例就不一一举例了，这个函数很简单</p>
<p><strong>答案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  tag,</span><br><span class="line">  exam_cnt_20,</span><br><span class="line">  exam_cnt_21,</span><br><span class="line">  concat(</span><br><span class="line">    round(</span><br><span class="line">      <span class="number">100</span> <span class="operator">*</span> (exam_cnt_21 <span class="operator">-</span> exam_cnt_20) <span class="operator">/</span> exam_cnt_20,</span><br><span class="line">      <span class="number">1</span></span><br><span class="line">    ),</span><br><span class="line">    <span class="string">&#x27;%&#x27;</span></span><br><span class="line">  ) <span class="keyword">AS</span> growth_rate,</span><br><span class="line">  exam_cnt_rank_20,</span><br><span class="line">  exam_cnt_rank_21,</span><br><span class="line">  <span class="built_in">cast</span>(exam_cnt_rank_21 <span class="keyword">AS</span> signed) <span class="operator">-</span> <span class="built_in">cast</span>(exam_cnt_rank_20 <span class="keyword">AS</span> signed) <span class="keyword">AS</span> rank_delta</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  (</span><br><span class="line">    #<span class="number">2020</span>年、<span class="number">2021</span>年上半年各类试卷的做完次数和做完次数排名</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">      tag,</span><br><span class="line">      <span class="built_in">count</span>(</span><br><span class="line">        IF (</span><br><span class="line">          date_format(start_time, <span class="string">&#x27;%Y%m%d&#x27;</span>) <span class="keyword">BETWEEN</span> <span class="string">&#x27;20200101&#x27;</span></span><br><span class="line">          <span class="keyword">AND</span> <span class="string">&#x27;20200630&#x27;</span>,</span><br><span class="line">          start_time,</span><br><span class="line">          <span class="keyword">NULL</span></span><br><span class="line">        )</span><br><span class="line">      ) <span class="keyword">AS</span> exam_cnt_20,</span><br><span class="line">      <span class="built_in">count</span>(</span><br><span class="line">        IF (</span><br><span class="line">          <span class="built_in">substring</span>(start_time, <span class="number">1</span>, <span class="number">10</span>) <span class="keyword">BETWEEN</span> <span class="string">&#x27;2021-01-01&#x27;</span></span><br><span class="line">          <span class="keyword">AND</span> <span class="string">&#x27;2021-06-30&#x27;</span>,</span><br><span class="line">          start_time,</span><br><span class="line">          <span class="keyword">NULL</span></span><br><span class="line">        )</span><br><span class="line">      ) <span class="keyword">AS</span> exam_cnt_21,</span><br><span class="line">      <span class="built_in">rank</span>() <span class="keyword">over</span> (</span><br><span class="line">        <span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">          <span class="built_in">count</span>(</span><br><span class="line">            IF (</span><br><span class="line">              date_format(start_time, <span class="string">&#x27;%Y%m%d&#x27;</span>) <span class="keyword">BETWEEN</span> <span class="string">&#x27;20200101&#x27;</span></span><br><span class="line">              <span class="keyword">AND</span> <span class="string">&#x27;20200630&#x27;</span>,</span><br><span class="line">              start_time,</span><br><span class="line">              <span class="keyword">NULL</span></span><br><span class="line">            )</span><br><span class="line">          ) <span class="keyword">DESC</span></span><br><span class="line">      ) <span class="keyword">AS</span> exam_cnt_rank_20,</span><br><span class="line">      <span class="built_in">rank</span>() <span class="keyword">over</span> (</span><br><span class="line">        <span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">          <span class="built_in">count</span>(</span><br><span class="line">            IF (</span><br><span class="line">              <span class="built_in">substring</span>(start_time, <span class="number">1</span>, <span class="number">10</span>) <span class="keyword">BETWEEN</span> <span class="string">&#x27;2021-01-01&#x27;</span></span><br><span class="line">              <span class="keyword">AND</span> <span class="string">&#x27;2021-06-30&#x27;</span>,</span><br><span class="line">              start_time,</span><br><span class="line">              <span class="keyword">NULL</span></span><br><span class="line">            )</span><br><span class="line">          ) <span class="keyword">DESC</span></span><br><span class="line">      ) <span class="keyword">AS</span> exam_cnt_rank_21</span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">      examination_info</span><br><span class="line">      <span class="keyword">JOIN</span> exam_record <span class="keyword">USING</span> (exam_id)</span><br><span class="line">    <span class="keyword">WHERE</span></span><br><span class="line">      submit_time <span class="keyword">IS</span> <span class="keyword">NOT NULL</span></span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">      tag</span><br><span class="line">  ) main</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">  exam_cnt_21 <span class="operator">*</span> exam_cnt_20 <span class="operator">&lt;&gt;</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">  growth_rate <span class="keyword">DESC</span>,</span><br><span class="line">  exam_cnt_rank_21 <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>

<h2 id="聚合窗口函数"><a href="#聚合窗口函数" class="headerlink" title="聚合窗口函数"></a>聚合窗口函数</h2><h3 id="对试卷得分做-min-max-归一化"><a href="#对试卷得分做-min-max-归一化" class="headerlink" title="对试卷得分做 min-max 归一化"></a>对试卷得分做 min-max 归一化</h3><p><strong>描述</strong>：</p>
<p>现有试卷信息表 <code>examination_info</code>（<code>exam_id</code> 试卷 ID, <code>tag</code> 试卷类别, <code>difficulty</code> 试卷难度, <code>duration</code> 考试时长, <code>release_time</code> 发布时间）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>exam_id</th>
<th>tag</th>
<th>difficulty</th>
<th>duration</th>
<th>release_time</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>9001</td>
<td>SQL</td>
<td>hard</td>
<td>60</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>2</td>
<td>9002</td>
<td>C++</td>
<td>hard</td>
<td>80</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>3</td>
<td>9003</td>
<td>算法</td>
<td>hard</td>
<td>80</td>
<td>2020-01-01 10:00:00</td>
</tr>
<tr>
<td>4</td>
<td>9004</td>
<td>PYTHON</td>
<td>medium</td>
<td>70</td>
<td>2020-01-01 10:00:00</td>
</tr>
</tbody></table>
<p>试卷作答记录表 <code>exam_record</code>（<code>uid</code> 用户 ID, <code>exam_id</code> 试卷 ID, <code>start_time</code> 开始作答时间, <code>submit_time</code> 交卷时间, <code>score</code> 得分）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>uid</th>
<th>exam_id</th>
<th>start_time</th>
<th>submit_time</th>
<th>score</th>
</tr>
</thead>
<tbody><tr>
<td>6</td>
<td>1003</td>
<td>9001</td>
<td>2020-01-02 12:01:01</td>
<td>2020-01-02 12:31:01</td>
<td>68</td>
</tr>
<tr>
<td>9</td>
<td>1001</td>
<td>9001</td>
<td>2020-01-02 10:01:01</td>
<td>2020-01-02 10:31:01</td>
<td>89</td>
</tr>
<tr>
<td>1</td>
<td>1001</td>
<td>9001</td>
<td>2020-01-01 09:01:01</td>
<td>2020-01-01 09:21:59</td>
<td>90</td>
</tr>
<tr>
<td>12</td>
<td>1002</td>
<td>9002</td>
<td>2021-05-05 18:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>3</td>
<td>1004</td>
<td>9002</td>
<td>2020-01-01 12:01:01</td>
<td>2020-01-01 12:11:01</td>
<td>60</td>
</tr>
<tr>
<td>2</td>
<td>1003</td>
<td>9002</td>
<td>2020-01-01 19:01:01</td>
<td>2020-01-01 19:30:01</td>
<td>75</td>
</tr>
<tr>
<td>7</td>
<td>1001</td>
<td>9002</td>
<td>2020-01-02 12:01:01</td>
<td>2020-01-02 12:43:01</td>
<td>81</td>
</tr>
<tr>
<td>10</td>
<td>1002</td>
<td>9002</td>
<td>2020-01-01 12:11:01</td>
<td>2020-01-01 12:31:01</td>
<td>83</td>
</tr>
<tr>
<td>4</td>
<td>1003</td>
<td>9002</td>
<td>2020-01-01 12:01:01</td>
<td>2020-01-01 12:41:01</td>
<td>90</td>
</tr>
<tr>
<td>5</td>
<td>1002</td>
<td>9002</td>
<td>2020-01-02 19:01:01</td>
<td>2020-01-02 19:32:00</td>
<td>90</td>
</tr>
<tr>
<td>11</td>
<td>1002</td>
<td>9004</td>
<td>2021-09-06 12:01:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
<tr>
<td>8</td>
<td>1001</td>
<td>9005</td>
<td>2020-01-02 12:11:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
</tbody></table>
<p>在物理学及统计学数据计算时，有个概念叫 min-max 标准化，也被称为离差标准化，是对原始数据的线性变换，使结果值映射到[0 - 1]之间。</p>
<p>转换函数为：</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/database/sql/29A377601170AB822322431FCDF7EDFE.png"></p>
<p>请你将用户作答高难度试卷的得分在每份试卷作答记录内执行 min-max 归一化后缩放到[0,100]区间，并输出用户 ID、试卷 ID、归一化后分数平均值；最后按照试卷 ID 升序、归一化分数降序输出。（注：得分区间默认为[0,100]，如果某个试卷作答记录中只有一个得分，那么无需使用公式，归一化并缩放后分数仍为原分数）。</p>
<p>由示例数据结果输出如下：</p>
<table>
<thead>
<tr>
<th>uid</th>
<th>exam_id</th>
<th>avg_new_score</th>
</tr>
</thead>
<tbody><tr>
<td>1001</td>
<td>9001</td>
<td>98</td>
</tr>
<tr>
<td>1003</td>
<td>9001</td>
<td>0</td>
</tr>
<tr>
<td>1002</td>
<td>9002</td>
<td>88</td>
</tr>
<tr>
<td>1003</td>
<td>9002</td>
<td>75</td>
</tr>
<tr>
<td>1001</td>
<td>9002</td>
<td>70</td>
</tr>
<tr>
<td>1004</td>
<td>9002</td>
<td>0</td>
</tr>
</tbody></table>
<p>解释：高难度试卷有 9001、9002、9003；</p>
<p>作答了 9001 的记录有 3 条，分数分别为 68、89、90，按给定公式归一化后分数为：0、95、100，而后两个得分都是用户 1001 作答的，因此用户 1001 对试卷 9001 的新得分为(95+100)&#x2F;2≈98（只保留整数部分），用户 1003 对于试卷 9001 的新得分为 0。最后结果按照试卷 ID 升序、归一化分数降序输出。</p>
<p><strong>思路：</strong></p>
<p>注意点：</p>
<ol>
<li>将高难度的试卷，按每类试卷的得分，利用 max&#x2F;min (col) over()窗口函数求得各组内最大最小值，然后进行归一化公式计算，缩放区间为[0,100]，即 min_max*100</li>
<li>若某类试卷只有一个得分，则无需使用归一化公式，因只有一个分 max_score&#x3D;min_score,score，公式后结果可能会变成 0。</li>
<li>最后结果按 uid、exam_id 分组求归一化后均值，score 为 NULL 的要过滤掉。</li>
</ol>
<p>最后就是仔细看上面公式 （说实话，这题看起来就很绕）</p>
<p><strong>答案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  uid,</span><br><span class="line">  exam_id,</span><br><span class="line">  round(<span class="built_in">sum</span>(min_max) <span class="operator">/</span> <span class="built_in">count</span>(score), <span class="number">0</span>) <span class="keyword">AS</span> avg_new_score</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  (</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">      <span class="operator">*</span>,</span><br><span class="line">      IF (</span><br><span class="line">        max_score <span class="operator">=</span> min_score,</span><br><span class="line">        score,</span><br><span class="line">        (score <span class="operator">-</span> min_score) <span class="operator">/</span> (max_score <span class="operator">-</span> min_score) <span class="operator">*</span> <span class="number">100</span></span><br><span class="line">      ) <span class="keyword">AS</span> min_max</span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">      (</span><br><span class="line">        <span class="keyword">SELECT</span></span><br><span class="line">          uid,</span><br><span class="line">          a.exam_id,</span><br><span class="line">          score,</span><br><span class="line">          <span class="built_in">max</span>(score) <span class="keyword">over</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> a.exam_id) <span class="keyword">AS</span> max_score,</span><br><span class="line">          <span class="built_in">min</span>(score) <span class="keyword">over</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> a.exam_id) <span class="keyword">AS</span> min_score</span><br><span class="line">        <span class="keyword">FROM</span></span><br><span class="line">          exam_record a</span><br><span class="line">          <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> examination_info b <span class="keyword">USING</span> (exam_id)</span><br><span class="line">        <span class="keyword">WHERE</span></span><br><span class="line">          difficulty <span class="operator">=</span> <span class="string">&#x27;hard&#x27;</span></span><br><span class="line">      ) t</span><br><span class="line">    <span class="keyword">WHERE</span></span><br><span class="line">      score <span class="keyword">IS</span> <span class="keyword">NOT NULL</span></span><br><span class="line">  ) t1</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">  uid,</span><br><span class="line">  exam_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">  exam_id <span class="keyword">ASC</span>,</span><br><span class="line">  avg_new_score <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<h3 id="每份试卷每月作答数和截止当月的作答总数"><a href="#每份试卷每月作答数和截止当月的作答总数" class="headerlink" title="每份试卷每月作答数和截止当月的作答总数"></a>每份试卷每月作答数和截止当月的作答总数</h3><p><strong>描述:</strong></p>
<p>现有试卷作答记录表 exam_record（uid 用户 ID, exam_id 试卷 ID, start_time 开始作答时间, submit_time 交卷时间, score 得分）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>uid</th>
<th>exam_id</th>
<th>start_time</th>
<th>submit_time</th>
<th>score</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1001</td>
<td>9001</td>
<td>2020-01-01 09:01:01</td>
<td>2020-01-01 09:21:59</td>
<td>90</td>
</tr>
<tr>
<td>2</td>
<td>1002</td>
<td>9001</td>
<td>2020-01-20 10:01:01</td>
<td>2020-01-20 10:10:01</td>
<td>89</td>
</tr>
<tr>
<td>3</td>
<td>1002</td>
<td>9001</td>
<td>2020-02-01 12:11:01</td>
<td>2020-02-01 12:31:01</td>
<td>83</td>
</tr>
<tr>
<td>4</td>
<td>1003</td>
<td>9001</td>
<td>2020-03-01 19:01:01</td>
<td>2020-03-01 19:30:01</td>
<td>75</td>
</tr>
<tr>
<td>5</td>
<td>1004</td>
<td>9001</td>
<td>2020-03-01 12:01:01</td>
<td>2020-03-01 12:11:01</td>
<td>60</td>
</tr>
<tr>
<td>6</td>
<td>1003</td>
<td>9001</td>
<td>2020-03-01 12:01:01</td>
<td>2020-03-01 12:41:01</td>
<td>90</td>
</tr>
<tr>
<td>7</td>
<td>1002</td>
<td>9001</td>
<td>2020-05-02 19:01:01</td>
<td>2020-05-02 19:32:00</td>
<td>90</td>
</tr>
<tr>
<td>8</td>
<td>1001</td>
<td>9002</td>
<td>2020-01-02 19:01:01</td>
<td>2020-01-02 19:59:01</td>
<td>69</td>
</tr>
<tr>
<td>9</td>
<td>1004</td>
<td>9002</td>
<td>2020-02-02 12:01:01</td>
<td>2020-02-02 12:20:01</td>
<td>99</td>
</tr>
<tr>
<td>10</td>
<td>1003</td>
<td>9002</td>
<td>2020-02-02 12:01:01</td>
<td>2020-02-02 12:31:01</td>
<td>68</td>
</tr>
<tr>
<td>11</td>
<td>1001</td>
<td>9002</td>
<td>2020-02-02 12:01:01</td>
<td>2020-02-02 12:43:01</td>
<td>81</td>
</tr>
<tr>
<td>12</td>
<td>1001</td>
<td>9002</td>
<td>2020-03-02 12:11:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
</tbody></table>
<p>请输出每份试卷每月作答数和截止当月的作答总数。<br>由示例数据结果输出如下：</p>
<table>
<thead>
<tr>
<th>exam_id</th>
<th>start_month</th>
<th>month_cnt</th>
<th>cum_exam_cnt</th>
</tr>
</thead>
<tbody><tr>
<td>9001</td>
<td>202001</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>9001</td>
<td>202002</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>9001</td>
<td>202003</td>
<td>3</td>
<td>6</td>
</tr>
<tr>
<td>9001</td>
<td>202005</td>
<td>1</td>
<td>7</td>
</tr>
<tr>
<td>9002</td>
<td>202001</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>9002</td>
<td>202002</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>9002</td>
<td>202003</td>
<td>1</td>
<td>5</td>
</tr>
</tbody></table>
<p>解释：试卷 9001 在 202001、202002、202003、202005 共 4 个月有被作答记录，每个月被作答数分别为 2、1、3、1，截止当月累积作答总数为 2、3、6、7。</p>
<p><strong>思路：</strong></p>
<p>这题就两个关键点：统计截止当月的作答总数、输出每份试卷每月作答数和截止当月的作答总数</p>
<p>这个是关键<code>**sum(count(*)) over(partition by exam_id order by date_format(start_time,&#39;%Y%m&#39;))**</code></p>
<p><strong>答案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> exam_id,</span><br><span class="line">       date_format(start_time, <span class="string">&#x27;%Y%m&#x27;</span>) <span class="keyword">AS</span> start_month,</span><br><span class="line">       <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">AS</span> month_cnt,</span><br><span class="line">       <span class="built_in">sum</span>(<span class="built_in">count</span>(<span class="operator">*</span>)) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> exam_id</span><br><span class="line">                           <span class="keyword">ORDER</span> <span class="keyword">BY</span> date_format(start_time, <span class="string">&#x27;%Y%m&#x27;</span>)) <span class="keyword">AS</span> cum_exam_cnt</span><br><span class="line"><span class="keyword">FROM</span> exam_record</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> exam_id,</span><br><span class="line">         start_month</span><br></pre></td></tr></table></figure>

<h3 id="每月及截止当月的答题情况（较难）"><a href="#每月及截止当月的答题情况（较难）" class="headerlink" title="每月及截止当月的答题情况（较难）"></a>每月及截止当月的答题情况（较难）</h3><p><strong>描述</strong>：现有试卷作答记录表 <code>exam_record</code>（<code>uid</code> 用户 ID, <code>exam_id</code> 试卷 ID, <code>start_time</code> 开始作答时间, <code>submit_time</code> 交卷时间, <code>score</code> 得分）：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>uid</th>
<th>exam_id</th>
<th>start_time</th>
<th>submit_time</th>
<th>score</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1001</td>
<td>9001</td>
<td>2020-01-01 09:01:01</td>
<td>2020-01-01 09:21:59</td>
<td>90</td>
</tr>
<tr>
<td>2</td>
<td>1002</td>
<td>9001</td>
<td>2020-01-20 10:01:01</td>
<td>2020-01-20 10:10:01</td>
<td>89</td>
</tr>
<tr>
<td>3</td>
<td>1002</td>
<td>9001</td>
<td>2020-02-01 12:11:01</td>
<td>2020-02-01 12:31:01</td>
<td>83</td>
</tr>
<tr>
<td>4</td>
<td>1003</td>
<td>9001</td>
<td>2020-03-01 19:01:01</td>
<td>2020-03-01 19:30:01</td>
<td>75</td>
</tr>
<tr>
<td>5</td>
<td>1004</td>
<td>9001</td>
<td>2020-03-01 12:01:01</td>
<td>2020-03-01 12:11:01</td>
<td>60</td>
</tr>
<tr>
<td>6</td>
<td>1003</td>
<td>9001</td>
<td>2020-03-01 12:01:01</td>
<td>2020-03-01 12:41:01</td>
<td>90</td>
</tr>
<tr>
<td>7</td>
<td>1002</td>
<td>9001</td>
<td>2020-05-02 19:01:01</td>
<td>2020-05-02 19:32:00</td>
<td>90</td>
</tr>
<tr>
<td>8</td>
<td>1001</td>
<td>9002</td>
<td>2020-01-02 19:01:01</td>
<td>2020-01-02 19:59:01</td>
<td>69</td>
</tr>
<tr>
<td>9</td>
<td>1004</td>
<td>9002</td>
<td>2020-02-02 12:01:01</td>
<td>2020-02-02 12:20:01</td>
<td>99</td>
</tr>
<tr>
<td>10</td>
<td>1003</td>
<td>9002</td>
<td>2020-02-02 12:01:01</td>
<td>2020-02-02 12:31:01</td>
<td>68</td>
</tr>
<tr>
<td>11</td>
<td>1001</td>
<td>9002</td>
<td>2020-01-02 19:01:01</td>
<td>2020-02-02 12:43:01</td>
<td>81</td>
</tr>
<tr>
<td>12</td>
<td>1001</td>
<td>9002</td>
<td>2020-03-02 12:11:01</td>
<td>(NULL)</td>
<td>(NULL)</td>
</tr>
</tbody></table>
<p>请输出自从有用户作答记录以来，每月的试卷作答记录中月活用户数、新增用户数、截止当月的单月最大新增用户数、截止当月的累积用户数。结果按月份升序输出。</p>
<p>由示例数据结果输出如下：</p>
<table>
<thead>
<tr>
<th>start_month</th>
<th>mau</th>
<th>month_add_uv</th>
<th>max_month_add_uv</th>
<th>cum_sum_uv</th>
</tr>
</thead>
<tbody><tr>
<td>202001</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>202002</td>
<td>4</td>
<td>2</td>
<td>2</td>
<td>4</td>
</tr>
<tr>
<td>202003</td>
<td>3</td>
<td>0</td>
<td>2</td>
<td>4</td>
</tr>
<tr>
<td>202005</td>
<td>1</td>
<td>0</td>
<td>2</td>
<td>4</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>month</th>
<th>1001</th>
<th>1002</th>
<th>1003</th>
<th>1004</th>
</tr>
</thead>
<tbody><tr>
<td>202001</td>
<td>1</td>
<td>1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>202002</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>202003</td>
<td>1</td>
<td></td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>202005</td>
<td></td>
<td>1</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>由上述矩阵可以看出，2020 年 1 月有 2 个用户活跃（mau&#x3D;2），当月新增用户数为 2；</p>
<p>2020 年 2 月有 4 个用户活跃，当月新增用户数为 2，最大单月新增用户数为 2，当前累积用户数为 4。</p>
<p><strong>思路：</strong></p>
<p>难点：</p>
<p>1.如何求每月新增用户</p>
<p>2.截至当月的答题情况</p>
<p>大致流程：</p>
<p>（1）统计每个人的首次登陆月份 <code>min()</code></p>
<p>（2）统计每月的月活和新增用户数：先得到每个人的首次登陆月份，再对首次登陆月份分组求和是该月份的新增人数</p>
<p>（3）统计截止当月的单月最大新增用户数、截止当月的累积用户数 ，最终按照按月份升序输出</p>
<p><strong>答案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 截止当月的单月最大新增用户数、截止当月的累积用户数，按月份升序输出</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	start_month,</span><br><span class="line">	mau,</span><br><span class="line">	month_add_uv,</span><br><span class="line">	<span class="built_in">max</span>( month_add_uv ) <span class="keyword">over</span> ( <span class="keyword">ORDER</span> <span class="keyword">BY</span> start_month ),</span><br><span class="line">	<span class="built_in">sum</span>( month_add_uv ) <span class="keyword">over</span> ( <span class="keyword">ORDER</span> <span class="keyword">BY</span> start_month )</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	(</span><br><span class="line">	<span class="comment">-- 统计每月的月活和新增用户数</span></span><br><span class="line">	<span class="keyword">SELECT</span></span><br><span class="line">		date_format( a.start_time, <span class="string">&#x27;%Y%m&#x27;</span> ) <span class="keyword">AS</span> start_month,</span><br><span class="line">		<span class="built_in">count</span>( <span class="keyword">DISTINCT</span> a.uid ) <span class="keyword">AS</span> mau,</span><br><span class="line">		<span class="built_in">count</span>( <span class="keyword">DISTINCT</span> b.uid ) <span class="keyword">AS</span> month_add_uv</span><br><span class="line">	<span class="keyword">FROM</span></span><br><span class="line">		exam_record a</span><br><span class="line">		<span class="keyword">LEFT</span> <span class="keyword">JOIN</span> (</span><br><span class="line">         <span class="comment">-- 统计每个人的首次登陆月份</span></span><br><span class="line">		<span class="keyword">SELECT</span> uid, <span class="built_in">min</span>( date_format( start_time, <span class="string">&#x27;%Y%m&#x27;</span> )) <span class="keyword">AS</span> first_month <span class="keyword">FROM</span> exam_record <span class="keyword">GROUP</span> <span class="keyword">BY</span> uid ) b <span class="keyword">ON</span> date_format( a.start_time, <span class="string">&#x27;%Y%m&#x27;</span> ) <span class="operator">=</span> b.first_month</span><br><span class="line">	<span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">		start_month</span><br><span class="line">	) main</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">	start_month</span><br></pre></td></tr></table></figure>

<!-- @include: @article-footer.snippet.md -->

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><a class="extend next" rel="next" href="/page/2/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.gif"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">240</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">31</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">38</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/JayVae" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.zhihu.com/people/shi-hai-jie-35" target="_blank" title="Zhihu">
                      
                        <i class="fa fa-fw fa-globe"></i>Zhihu</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="wechat" target="_blank" title="Wechat">
                      
                        <i class="fa fa-fw fa-globe"></i>Wechat</a>
                  </span>
                
            </div>
          

		  <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=554191378&auto=1&height=66"></iframe>
		  
          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">史海杰</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">712.5k</span>
  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  







<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    

    







  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("SWULgkVHBjhFp99nBHCr8oHC-gzGzoHsz", "DQQN5XsGzlq3PIf1OSvGvoRR");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
